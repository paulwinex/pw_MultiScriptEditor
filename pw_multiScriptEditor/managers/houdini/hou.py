import hmath

class EnumValue(object):
    """
    hou.EnumValue

    This class is the base class for an enumeration value.  It cannot be
    instanced and is not meant to be used directly by the user.

    All the built-in HOM enumeration values are derived from this class such
    as hou.paneTabType.*, hou.severityType.*, and hou.connectivityType.*.
    """

class numericData(object):
    
    def __init__(self): raise AttributeError, "No constructor defined"
    
class attribData(object):
    """
    attribData

    Enumeration of attribute data types.

    * hou.attribData.Int
    * hou.attribData.Float
    * hou.attribData.String
    """
    Int=None
    Float=None
    String=None
    def __init__(self): raise AttributeError, "No constructor defined"

class attribType(object):
    """
    hou.attribType

    Enumeration of geometry attribute types.

    * hou.attribType.Point
    * hou.attribType.Prim
    * hou.attribType.Vertex
    * hou.attribType.Global
    Note that global attributes are also known as detail attributes.

    The type of data (e.g. int, float, string) is called the attribute data
    type, can correspond to hou.attribData.

    See hou.Geometry.addAttrib and hou.Attrib for more information.
    """
    Point=None
    Prim=None
    Vertex=None
    Global=None
    def __init__(self): raise AttributeError, "No constructor defined"

class primType(object):
    """
    hou.primType

    Enumeration of primitive types.

    * hou.primType.Polygon
    * hou.primType.NURBSCurve
    * hou.primType.BezierCurve
    * hou.primType.Mesh
    * hou.primType.NURBSSurface
    * hou.primType.BezierSurface
    * hou.primType.Circle
    * hou.primType.Sphere
    * hou.primType.Tube
    * hou.primType.Metaball
    * hou.primType.TriangleFan
    * hou.primType.TriangleStrip
    * hou.primType.TriangleBezier
    * hou.primType.PastedSurface
    * hou.primType.Volume
    * hou.primType.ParticleSystem
    * hou.primType.Tetrahedron
    * hou.primType.PolySoup
    * hou.primType.VDB
    * hou.primType.AlembicRef
    * hou.primType.Custom
    * hou.primType.Unknown
    hou.primType.Custom is a catch-all for all HDK-defined primitives types.
    """
    Polygon=None
    NURBSCurve=None
    BezierCurve=None
    Mesh=None
    NURBSSurfac=None
    BezierSurfa=None
    Circle=None
    Sphere=None
    Tube=None
    Metaball=None
    TriangleFan=None
    TriangleStr=None
    TriangleBez=None
    PastedSurfa=None
    Volume=None
    ParticleSys=None
    Tetrahedron=None
    PolySoup=None
    VDB=None
    AlembicRef=None
    Custom=None
    Unknown    =None
    def __init__(self): raise AttributeError, "No constructor defined"

class parmData(object):
    """
    hou.parmData

    Enumeration of parameter data types.

    * hou.parmData.Int
    * hou.parmData.Float
    * hou.parmData.String
    * hou.parmData.Ramp

    """
    Int=None
    Float=None
    String=None
    Ramp=None
    def __init__(self): raise AttributeError, "No constructor defined"
    
class parmTemplateType(object):
    """
    hou.parmTemplateType

    Enumeration of parameter template types.

    * hou.parmTemplateType.Int
    * hou.parmTemplateType.Float
    * hou.parmTemplateType.String
    * hou.parmTemplateType.Toggle
    * hou.parmTemplateType.Menu
    * hou.parmTemplateType.Button
    * hou.parmTemplateType.FolderSet
    * hou.parmTemplateType.Separator
    * hou.parmTemplateType.Label
    * hou.parmTemplateType.Ramp

    """
    Int=None
    Float=None
    String=None
    Toggle=None
    Menu=None
    Button=None
    FolderSet=None
    Separator=None
    Label=None
    Ramp=None
    def __init__(self): raise AttributeError, "No constructor defined"
    
class parmLook(object):
    """
    hou.parmLook

    Enumeration of available looks for a parameter

    These looks are used by hou.ParmTemplate objects and control the user
    interface of the parameter in parameter editors.

    hou.parmLook.Regular
        The default parameter look.

    hou.parmLook.Logarithmic
        The parameter displays a slider that changes the value on a
        logarithmic scale.

    hou.parmLook.Angle
        The parameter has an arc control to enter an angle.

        If you use this look, set your parameter's naming scheme to
        hou.parmNamingScheme.Base1.

    hou.parmLook.Vector
        The parameter has a handle beside the label to edit the vector
        direction.

        If you use this look, set your parameter's naming scheme to
        hou.parmNamingScheme.XYZW.

    hou.parmLook.ColorSquare
        The parameter has a square button beside the label to display the
        current color.  You can click on the square to edit the color.

        If you use this look, set your parameter's naming scheme to
        hou.parmNamingScheme.RGBA.

    hou.parmLook.HueCircle
        The parameter has a hue circle with a pie-shaped region, like the
        keying nodes in COPs have.

    hou.parmLook.CRGBAPlaneChooser
        The parameter has an RGBA mask, with buttons to toggle the red,
        green, blue, and alpha planes.


    """
    Regular=None
    Logarithmic=None
    Angle=None
    Vector=None
    ColorSquare=None
    HueCircle=None
    CRGBAPlaneChooser=None

    def __init__(self): raise AttributeError, "No constructor defined"
    
class parmNamingScheme(object):
    """
    hou.parmNamingScheme

    Enumeration of available naming schemes for a parameter.

    These naming schemes are stored inside hou.ParmTemplate objects and
    determine the names of hou.Parm objects inside hou.ParmTuple objects.

    The number of components in the parm template determines the number of
    parms inside the parm tuple.  If this number is 1, the parm name is the
    same as the parm tuple name.  If the naming scheme is Base1, the number
    of components may be more than 4.  Otherwise, the component may have
    from 2 components up to the maximum number allowed by the naming scheme.

    The example names below are for a parm template named "foo":

    * hou.parmNamingScheme.Base1

      "foo1", "foo2", "foo3", ...

    * hou.parmNamingScheme.XYZW

      "foox", "fooy", "fooz", "foow"

    * hou.parmNamingScheme.XYWH

      "foox", "fooy", "foow", "fooh"

    * hou.parmNamingScheme.UVW

      "foou", "foov", "foow"

    * hou.parmNamingScheme.RGBA

      "foor", "foog", "foob", "fooa"

    * hou.parmNamingScheme.MinMax

      "foomin", "foomax"

    * hou.parmNamingScheme.MaxMin

      "foomax", "foomin"

    * hou.parmNamingScheme.StartEnd

      "foostart", "fooend"

    * hou.parmNamingScheme.BeginEnd

      "foobegin", "fooend"

    The following restrictions exist on naming schemes:

    * You cannot use the following naming schemes when editing the parameter
      interface on a node or a digital asset: MinMax, MaxMin, StartEnd,
      BeginEnd, XYWH.  However, some built-in node types use parameters with
      these naming schemes, so asking these node types for their parm
      templates may return ones using these naming schemes.
    * String and toggle parameters only support the Base1 naming scheme.
    * Parameters with the hou.parmLook.Vector look must use the XYZW naming
      scheme.
    * Parameters with the hou.parmLook.Angle look must use the Base1 naming
      scheme.
    * Parameters with the hou.parmLook.ColorSquare look must use an RGBA
      naming scheme.

    """
    Base1=None
    XYZW=None
    XYWH=None
    UVW=None
    RGBA=None
    MinMax=None
    MaxMin=None
    StartEnd=None
    BeginEnd=None
    def __init__(self): raise AttributeError, "No constructor defined"

class parmCondType(object):
    """
    hou.parmCondType

    Enumeration of available parameter conditional types.

    * hou.parmCondType.DisableWhen
    * hou.parmCondType.HideWhen

    """
    DisableWhen=None
    HideWhen=None
    def __init__(self): raise AttributeError, "No constructor defined"

class stringParmType(object):
    """
    hou.stringParmType

    Enumeration of string parameter types.

    A hou.StringParmTemplate is set to one of these types to specify whether
    a string parameter will hold an arbitrary string, a reference to a file,
    a reference to a node, or a reference to multiple nodes.

    * hou.stringParmType.Regular
    * hou.stringParmType.FileReference
    * hou.stringParmType.NodeReference
    * hou.stringParmType.NodeReferenceList

    """
    Regular=None
    FileReference=None
    NodeReference=None
    NodeReferenceList=None
    def __init__(self): raise AttributeError, "No constructor defined"

class exprLanguage(object):
    """
    hou.exprLanguage

    Enumeration of available expression languages.

    * hou.exprLanguage.Python
    * hou.exprLanguage.Hscript

    """
    Python=None
    Hscrip=None
    def __init__(self): raise AttributeError, "No constructor defined"

class scriptLanguage(object):
    """
    hou.scriptLanguage

    Enumeration of available script languages.

    * hou.scriptLanguage.Python
    * hou.scriptLanguage.Hscript

    """
    Python=None
    Hscript=None
    def __init__(self): raise AttributeError, "No constructor defined"

class fileType(object):
    """
    hou.fileType

    Enumeration of file types.

    * hou.fileType.Any
    * hou.fileType.Image
    * hou.fileType.Geometry
    * hou.fileType.Ramp
    * hou.fileType.Capture
    * hou.fileType.Clip
    * hou.fileType.Lut
    * hou.fileType.Cmd
    * hou.fileType.Midi
    * hou.fileType.I3d
    * hou.fileType.Chan
    * hou.fileType.Sim
    * hou.fileType.SimData
    * hou.fileType.Hip
    * hou.fileType.Otl
    * hou.fileType.Dae
    * hou.fileType.Gallery
    * hou.fileType.Directory

    """
    Any=Nonr
    Image=Nonr
    Geometry=Nonr
    Ramp=Nonr
    Capture=Nonr
    Clip=Nonr
    Lut=Nonr
    Cmd=Nonr
    Midi=Nonr
    I3d=Nonr
    Chan=Nonr
    Sim=Nonr
    SimData=Nonr
    Hip=Nonr
    Otl=Nonr
    Dae=Nonr
    Gallery=Nonr
    Directory=Nonr
    def __init__(self): raise AttributeError, "No constructor defined"
    
class fileChooserMode(object):
    """
    hou.fileChooserMode

    Enumeration of possible read/write modes for the file chooser.

    See hou.ui.selectFile for more information.

    * hou.fileChooserMode.Read
    * hou.fileChooserMode.Write
    * hou.fileChooserMode.ReadAndWrite

    """
    Read=None
    Write=None
    ReadAndWrite=None
    def __init__(self): raise AttributeError, "No constructor defined"
    
class folderType(object):
    """
    hou.folderType

    Enumeration of folder types for FolderParmTemplates.

    * hou.folderType.Collapsible

      A folder that expands and collapses to show and hide its contents
      respectively.

    * hou.folderType.Simple

      A simple folder for organizing parameters in the form of a group box.

    * hou.folderType.Tabs

      A normal folder represented by a tab.

    * hou.folderType.RadioButtons

      A folder with a radio button.  The open folder is the selected radio
      button in the set of buttons.

    * hou.folderType.MultiparmBlock

      A block of multiparms.  The user can add or remove instances of this
      parameter block.

    * hou.folderType.ScrollingMultiparmBlock

      A multiparm block inside a smaller region with scroll bars.

    * hou.folderType.TabbedMultiparmBlock

      A multiparm block where each instance of the parameters in the block
      appears in its own tab.

    * hou.folderType.ImportBlock

      A block containing parameters imported from another node.

    See also hou.FolderParmTemplate.


    """
    Collapsible=None
    Simple=None
    Tabs=None
    RadioButtons=None
    MultiparmBlock=None
    ScrollingMultiparmBlock=None
    TabbedMultiparmBlock=None
    ImportBlock=None

    def __init__(self): raise AttributeError, "No constructor defined"
    
class menuType(object):
    """
    hou.menuType

    Enumeration of menu types for MenuParmTemplates and StringParmTemplates
    with menus.

    * hou.menuType.Normal

      A standard menu that displays the currently selected menu item.

    * hou.menuType.Mini

      A condensed menu that only displays a dropdown arrow.  Houdini lets
      you choose a menu entry when you click on this arrow.

    * hou.menuType.StringReplace

      A menu that also displays an input field.  Selecting an entry from
      this menu will replace the contents of the field with the menu item.
      This type of menu only has meaning for string parameters.

    * hou.menuType.StringToggle

      A menu that also displays an input field.  Selecting an entry from
      this menu will add the menu item to the field if it was not already
      there, and will remove it from the field it if was.  This type of menu
      only has meaning for string parameters.

    See also hou.MenuParmTemplate and hou.StringParmTemplate.


    """
    Normal=None
    Mini=None
    StringReplace=None
    StringToggle=None

    def __init__(self): raise AttributeError, "No constructor defined"

class paneTabType(PythonPanel, HelpBrowser):
    """
    hou.paneTabType

    Enumeration of pane tab types.

    * hou.paneTabType.SceneViewer
    * hou.paneTabType.ChannelViewer
    * hou.paneTabType.CompositorViewer
    * hou.paneTabType.OutputViewer
    * hou.paneTabType.MaterialPalette
    * hou.paneTabType.IPRViewer
    * hou.paneTabType.NetworkEditor
    * hou.paneTabType.Parm
    * hou.paneTabType.DetailsView
    * hou.paneTabType.ChannelEditor
    * hou.paneTabType.ChannelList
    * hou.paneTabType.Textport
    * hou.paneTabType.HandleList
    * hou.paneTabType.BundleList
    * hou.paneTabType.TakeList
    * hou.paneTabType.TreeView
    * hou.paneTabType.HelpBrowser
    * hou.paneTabType.PythonPanel
    * hou.paneTabType.ParmSpreadsheet
    * hou.paneTabType.LightLinker
    * hou.paneTabType.AssetBrowser

    """
    SceneViewer=None
    ChannelViewer=None
    CompositorViewer=None
    OutputViewer=None
    MaterialPalette=None
    IPRViewer=None
    NetworkEditor=None
    Parm=None
    DetailsView=None
    ChannelEditor=None
    ChannelList=None
    Textport=None
    HandleList=None
    BundleList=None
    TakeList=None
    TreeView=None
    HelpBrowser=None
    PythonPanel=None
    PythonShell=None
    ParmSpreadsheet=None
    LightLinker=None
    AssetBrowser=None
    def __init__(self): raise AttributeError, "No constructor defined"

class paneLinkType(object):
    """
    hou.paneLinkType

    Enumeration of possible pane link values.

    * hou.paneLinkType.Pinned
    * hou.paneLinkType.Group1
    * hou.paneLinkType.Group2
    * hou.paneLinkType.Group3
    * hou.paneLinkType.Group4
    * hou.paneLinkType.Group5
    * hou.paneLinkType.Group6
    * hou.paneLinkType.Group7
    * hou.paneLinkType.Group8
    * hou.paneLinkType.FollowSelection

    """
    Pinned=None
    Group1=None
    Group2=None
    Group3=None
    Group4=None
    Group5=None
    Group6=None
    Group7=None
    Group8=None
    FollowSelection=None
    def __init__(self): raise AttributeError, "No constructor defined"
    
class geometryViewportType(object):
    """
    hou.geometryViewportType

    Enumeration of scene viewer viewport types.

    * hou.geometryViewportType.Perspective
    * hou.geometryViewportType.Top
    * hou.geometryViewportType.Bottom
    * hou.geometryViewportType.Front
    * hou.geometryViewportType.Back
    * hou.geometryViewportType.Right
    * hou.geometryViewportType.Left
    * hou.geometryViewportType.UV

    """
    Perspective=None
    Top=None
    Bottom=None
    Front=None
    Back=None
    Right=None
    Left=None
    UV =None
    def __init__(self): raise AttributeError, "No constructor defined"

class glShadingType(object):
    
    def __init__(self): raise AttributeError, "No constructor defined"

class geometryViewportLayout(object):
    
    def __init__(self): raise AttributeError, "No constructor defined"
    
class snappingMode(object):
    """
    snappingMode

    Enumeration of snapping modes.

    * hou.snappingMode.Off
    * hou.snappingMode.Grid
    * hou.snappingMode.Prim
    * hou.snappingMode.Point
    * hou.snappingMode.Multi
    See hou.SceneViewer.snappingMode.
    """
    Off=None
    Grid=None
    Prim=None
    Point=None
    Multi=None
    def __init__(self): raise AttributeError, "No constructor defined"

class pickStyle(object):
    """
    hou.pickStyle

    Enumeration of pick styles.

    * hou.pickStyle.Box
    * hou.pickStyle.Lasso
    * hou.pickStyle.Brush
    * hou.pickStyle.Laser

    """
    Box=None
    Lasso=None
    Brush=None
    Laser=None
    def __init__(self): raise AttributeError, "No constructor defined"

class pickModifier(object):
    """
    hou.pickModifier

    Enumeration of methods for modifying selections with new components.

    * hou.pickModifier.Add
    * hou.pickModifier.Toggle
    * hou.pickModifier.Remove
    * hou.pickModifier.Replace
    * hou.pickModifier.Intersect

    """
    Add=None
    Toggle=None
    Remove=None
    Replace=None
    Intersect=None
    def __init__(self): raise AttributeError, "No constructor defined"

class pickFacing(object):
    """
    hou.pickFacing

    Enumeration for describing the facing direction of pickable components.

    * hou.pickFacing.Front
    * hou.pickFacing.Back
    * hou.pickFacing.FrontAndBack

    """
    Front=None
    Back=None
    FrontAndBack=None
    def __init__(self): raise AttributeError, "No constructor defined"

class groupListType(object):
    """
    hou.groupListType

    Enumeration of group list types.

    * hou.groupListType.Points
    * hou.groupListType.Vertices
    * hou.groupListType.Edges
    * hou.groupListType.Breakpoints
    * hou.groupListType.Primitives
    * hou.groupListType.MatchPickType

    """
    Points=None
    Vertices=None
    Edges=None
    Breakpoints=None
    Primitives=None
    MatchPickType=None
    def __init__(self): raise AttributeError, "No constructor defined"

class geometryType(object):
    """
    hou.geometryType

    Enumeration of geometry component types.

    * hou.geometryType.Points
    * hou.geometryType.Vertices
    * hou.geometryType.Edges
    * hou.geometryType.Breakpoints
    * hou.geometryType.Primitives

    """
    Points=None
    Vertices=None
    Edges=None
    Breakpoints=None
    Primitives=None
    def __init__(self): raise AttributeError, "No constructor defined"

class connectivityType(object):
    """
    hou.connectivityType

    Enumeration of connectivity types.

    * hou.connectivityType.NoConnectivity
    * hou.connectivityType.Texture
    * hou.connectivityType.Position

    """
    NoConnectivi=None
    Texture=None
    Position=None
    def __init__(self): raise AttributeError, "No constructor defined"

class severityType(object):
    """
    hou.severityType

    Enumeration of dialog message severities.

    * hou.severityType.Message
    * hou.severityType.ImportantMessage
    * hou.severityType.Warning
    * hou.severityType.Error
    * hou.severityType.Fatal

    """
    Message=None
    ImportantMessage=None
    Warning=None
    Error=None
    Fatal=None
    def __init__(self): raise AttributeError, "No constructor defined"
    
class positionType(object):
    """
    hou.positionType

    Enumeration of spaces.

    * hou.positionType.WorldSpace
    * hou.positionType.ViewportXY
    * hou.positionType.ViewportUV

    """
    WorldSpace=None
    ViewportXY=None
    ViewportUV=None
    def __init__(self): raise AttributeError, "No constructor defined"
    
class shadingMode(object):
    """
    hou.shadingMode
    """
    WireBoundingBox=None
    ShadedBoundingBox=None
    Wireframe=None
    HiddenLineInvisible=None
    HiddenLineGhost=None
    FlatShaded=None
    FlatWireShaded=None
    SmoothShaded=None
    SmoothWireShaded=None
    VexShaded=None
    VexWireShaded=None

    def __init__(self): raise AttributeError, "No constructor defined"

class shaderType(object):
    """
    hou.shaderType

    Enumeration of SHOP shader types.

    Each SHOP type defines a particular type of shader.  For example, it
    might be a surface shader or a displacement shader.  This enumeration
    contains all the possible shader types.

    Use hou.ShopNodeType.shaderType to determine what type of shader a
    particular SHOP type is.

    * hou.shaderType.Surface
    * hou.shaderType.SurfaceShadow
    * hou.shaderType.Displacement
    * hou.shaderType.Geometry
    * hou.shaderType.Interior
    * hou.shaderType.Light
    * hou.shaderType.LightShadow
    * hou.shaderType.Atmosphere
    * hou.shaderType.Lens
    * hou.shaderType.Output
    * hou.shaderType.Background
    * hou.shaderType.Photon
    * hou.shaderType.Image3D
    * hou.shaderType.BSDF
    * hou.shaderType.CVEX
    * hou.shaderType.Mutable
    * hou.shaderType.Properties
    * hou.shaderType.Material
    * hou.shaderType.VopMaterial
    * hou.shaderType.ShaderClass
    """
    Surface=None
    SurfaceShadow=None
    Displacement=None
    Geometry=None
    Interior=None
    Light=None
    LightShadow=None
    Atmosphere=None
    Lens=None
    Output=None
    Background=None
    Photon=None
    Image3D=None
    BSDF=None
    CVEX=None
    Mutable=None
    Properties=None
    Material=None
    VopMaterial=None
    ShaderClass=None
    def __init__(self): raise AttributeError, "No constructor defined"

class rampBasis(object):
    """
    hou.rampBasis

    Enumeration of ramp interpolation types.

    These interpolation types specify how Houdini interpolates between
    keyframed values in a hou.Ramp.  See hou.Ramp.basis and
    hou.Ramp.__init__ for more information about how to get and set ramp
    interpolation types.

    hou.rampBasis.Linear
        Does a linear (straight line) interpolation between keys.

    hou.rampBasis.Constant
        Holds the value constant until the next key.

    hou.rampBasis.CatmullRom
        Interpolates smoothly between the keys. See Wikipedia's Catmull-
        Rom_spline page.

    hou.rampBasis.MonotonicCubic
        Another smooth interpolation that ensures that there is no
        overshoot. For example, if a key's value is smaller than the values
        in the adjacent keys, this type ensures that the interpolated value
        is never less than the key's value.

    hou.rampBasis.Bezier
        Cubic Bezier curve that interpolates every third control point and
        uses the other points to shape the curve. See Wikipedia's Bezier
        curve page.

    hou.rampBasis.BSpline
        Cubic curve where the control points influence the shape of the
        curve locally (that is, they influence only a section of the curve).
        See Wikipedia's B-Spline page.

    hou.rampBasis.Hermite
        Cubic Hermite curve that interpolates the odd control points, while
        even control points control the tangent at the previous
        interpolation point. See Wikipedia's Hermite spline page.
    """
    Linear=None
    Constant=None
    CatmullRom=None
    MonotonicCubic=None
    Bezier=None
    BSpline=None
    Hermite=None
    def __init__(self): raise AttributeError, "No constructor defined"

class rampParmType(object):
    """
    hou.rampParmType

    Enumeration of ramp types.

    * hou.rampParmType.Color
    * hou.rampParmType.Float
    :
      * hou.RampParmTemplate
    """
    Color=None
    Float=None
    def __init__(self): raise AttributeError, "No constructor defined"

class colorType(object):
    """
    hou.colorType

    Enumeration of color spaces.

    * hou.colorType.RGB

      The red green blue color model.

    * hou.colorType.HSV

      The hue saturation value color model.

    * hou.colorType.HSL

      The hue saturation lightness color model.

    * hou.colorType.LAB

      The CIE L* a* b* color space model.

    * hou.colorType.XYZ

      The CIE XYZ color space model.


    """
    RGB=None
    HSV=None
    HSL=None
    LAB=None
    XYZ=None

    def __init__(self): raise AttributeError, "No constructor defined"

class componentType(object):
    """
    hou.componentType
    """
    Point=None
    Primitive=None
    Edge=None
    Vertex=None
    Breakpoint=None
    def __init__(self): raise AttributeError, "No constructor defined"

class numericType(object):
    """
    hou.numericType
    """
    Int8=None
    Int16=None
    Int32=None
    Int64=None
    Float16=None
    Float32=None
    Float64=None

    def __init__(self): raise AttributeError, "No constructor defined"

class nodeTypeSource(object):
    """
    hou.nodeTypeSource

    Enumeration of node type sources.

    * hou.nodeTypeSource.Internal
    * hou.nodeTypeSource.CompiledCode
    * hou.nodeTypeSource.VexCode
    * hou.nodeTypeSource.RslCode
    * hou.nodeTypeSource.Subnet

    """
    Internal=None
    CompiledCode=None
    VexCode=None
    RslCode=None
    Subnet=None
    def __init__(self): raise AttributeError, "No constructor defined"

class fieldType(object):
    """
    hou.fieldType

    Enumeration of field types.

    * hou.fieldType.NoSuchField
    * hou.fieldType.Integer
    * hou.fieldType.Boolean
    * hou.fieldType.Float
    * hou.fieldType.String
    * hou.fieldType.Vector2
    * hou.fieldType.Vector3
    * hou.fieldType.Vector4
    * hou.fieldType.Quaternion
    * hou.fieldType.Matrix3
    * hou.fieldType.Matrix4
    * hou.fieldType.UV
    * hou.fieldType.UVW
    * hou.fieldType.IntArray
    * hou.fieldType.FloatArray

    """
    NoSuchField=None
    Integer=None
    Boolean=None
    Float=None
    String=None
    Vector2=None
    Vector3=None
    Vector4=None
    Quaternion=None
    Matrix3=None
    Matrix4=None
    UV=None
    UVW=None
    IntArray=None
    FloatArray=None
    def __init__(self): raise AttributeError, "No constructor defined"

class renderMethod(object):
    """
    hou.renderMethod

    Enumeration of dependency rendering methods.

    * hou.renderMethod.RopByRop
    * hou.renderMethod.FrameByFrame

    """
    RopByRop=None
    FrameByFrame=None
    def __init__(self): raise AttributeError, "No constructor defined"

class updateMode(object):
    """
    hou.updateMode

    Enumeration of interface update modes.

    See hou.updateModeSetting for more information.

    * hou.updateMode.AutoUpdate
    * hou.updateMode.OnMouseUp
    * hou.updateMode.Manual

    """
    AutoUpdate=None
    OnMouseUp=None
    Manual=None
    def __init__(self): raise AttributeError, "No constructor defined"

class licenseCategoryType(object):
    """
    licenseCategoryType

    Enumeration of license category values.

    * hou.licenseCategoryType.Commercial
    * hou.licenseCategoryType.Education
    * hou.licenseCategoryType.ApprenticeHD
    * hou.licenseCategoryType.Apprentice

    """
    Commercial=None
    Education=None
    ApprenticeHD=None
    Apprentice=None
    def __init__(self): raise AttributeError, "No constructor defined"

class hdaLicenseType(object):
    """
    hou.hdaLicenseType

    Enumeration of digital asset license permission levels.

    Enumeration values:

    * Execute
    * Read
    * Full

    """
    Execute=None
    Read=None
    Full=None

    def __init__(self): raise AttributeError, "No constructor defined"

class orientUpAxis(object):
    """
    hou.orientUpAxis

    Enumeration of global orientation mode.

    See hou.ui.orientationUpAxis for more information.

    * hou.orientUpAxis.Y
    * hou.orientUpAxis.Z

    """
    Y=None
    Z=None
    def __init__(self): raise AttributeError, "No constructor defined"

class nodeEventType(object):
    """
    nodeEventType

    Enumeration of types of events that can happen to nodes.

    See hou.Node.addEventCallback for more information.

    * hou.nodeEventType.BeingDeleted
    * hou.nodeEventType.NameChanged
    * hou.nodeEventType.FlagChanged
    * hou.nodeEventType.AppearanceChanged
    * hou.nodeEventType.PositionChanged
    * hou.nodeEventType.InputRewired
    * hou.nodeEventType.ParmTupleChanged
    * hou.nodeEventType.ChildCreated
    * hou.nodeEventType.ChildDeleted
    * hou.nodeEventType.ChildSwitched
    * hou.nodeEventType.ChildSelectionChanged

    """
    BeingDeleted=None
    NameChanged=None
    FlagChanged=None
    AppearanceChanged=None
    PositionChanged=None
    InputRewired=None
    ParmTupleChanged=None
    ChildCreated=None
    ChildDeleted=None
    ChildSwitched=None
    ChildSelectionChanged=None
    def __init__(self): raise AttributeError, "No constructor defined"

class appearanceChangeType(object):
    """
    appearanceChangeType

    Enumeration of types of appearance change events that can happen to
    nodes.

    See hou.Node.addEventCallback for more information.

    * hou.appearanceChangeType.Any
    * hou.appearanceChangeType.ErrorState
    * hou.appearanceChangeType.Pick
    * hou.appearanceChangeType.Color
    * hou.appearanceChangeType.DeleteScript
    * hou.appearanceChangeType.CommentLockFlag
    * hou.appearanceChangeType.CompressFlag
    * hou.appearanceChangeType.OTLMatchState
    * hou.appearanceChangeType.ActiveInput
    * hou.appearanceChangeType.Connections
    * hou.appearanceChangeType.ExpressionLanguage
    * hou.appearanceChangeType.NetworkBox
    * hou.appearanceChangeType.PostIt

    """
    Any=None
    ErrorState=None
    Pick=None
    Color=None
    DeleteScript=None
    CommentLockFlag=None
    CompressFlag=None
    OTLMatchState=None
    ActiveInput=None
    Connections=None
    ExpressionLanguage=None
    NetworkBox=None
    PostIt=None
    def __init__(self): raise AttributeError, "No constructor defined"

class imageDepth(object):
    """
    imageDepth

    Enumeration of image depths (data formats) for representing the pixels
    in an image plane.

    See hou.CopNode.depth for more information.

    * hou.imageDepth.Int8
    * hou.imageDepth.Int16
    * hou.imageDepth.Int32
    * hou.imageDepth.Float16
    * hou.imageDepth.Float32

    """
    Int8=None
    Int16=None
    Int32=None
    Float16=None
    Float32=None
    def __init__(self): raise AttributeError, "No constructor defined"

class playMode(object):
    """
    hou.playMode

    Enumeration of play modes for the main playbar in Houdini.

    * hou.playMode.Loop

      Play through the frame range and when reaching the end of the range
      loop back to the beginning and continue the playback.

    * hou.playMode.Once

      Play through the frame range and when reaching the end of the range
      stop the playback.

    * hou.playMode.Zigzag

      Play through the frame range and when reaching the end of the range
      reverse the playback.  When the reverse playback reaches the beginning
      of the range, then continue playback in the forward direction, etc.
    """
    Loop = None
    Once = None
    Zigzag = None
    def __init__(self): raise AttributeError, "No constructor defined"

class playbarEvent(object):
    """
    hou.playbarEvent

    Enumeration of the playbar events that can be handled by callback
    functions registered with hou.playbar.addEventCallback().

    * hou.playbarEvent.Started

      This event is triggered when the playbar has started playback either
      in the forward or reverse direction.

    * hou.playbarEvent.Stopped

      This event is triggered when running playback has stopped.

    * hou.playbarEvent.FrameChanged

      This event is triggered when the playbar has changed to another frame
      and after the scene has been cooked for the new frame.


    """
    Started=None
    Stopped=None
    FrameChanged=None

    def __init__(self): raise AttributeError, "No constructor defined"

class perfMonTimeFormat(object):
    """
    perfMonTimeFormat

    Enumeration of the different formats used when viewing times in the
    Performance Monitor panetab.

    * hou.perfMonTimeFormat.Absolute
    * hou.perfMonTimeFormat.Percent

    """
    Absolute=None
    Percent=None
    def __init__(self): raise AttributeError, "No constructor defined"

class perfMonObjectView(object):
    """
    perfMonObjectView

    Enumeration of the different structures that are used to view objects in
    the Performance Monitor panetab.

    * hou.perfMonObjectView.List
    * hou.perfMonObjectView.Tree
    * hou.perfMonObjectView.EventLog

    """
    List=None
    Tree=None
    EventLog=None
    def __init__(self): raise AttributeError, "No constructor defined"

class compressionType(object):
    
    def __init__(self): raise AttributeError, "No constructor defined"
    
class nodeTypeFilter(object):
    """
    hou.nodeTypeFilter

    Enumeration of available node type filters.

    These filters are used by node bundles to limit the nodes in the bundle
    based on type.

    hou.nodeTypeFilter.NoFilter
        Any node

    hou.nodeTypeFilter.Sop
        Any SOP

    hou.nodeTypeFilter.Pop
        Any POP

    hou.nodeTypeFilter.Popnet
        Any POP Network

    hou.nodeTypeFilter.Chop
        Any CHOP

    hou.nodeTypeFilter.Chopnet
        Any CHOP Network

    hou.nodeTypeFilter.Cop
        Any COP

    hou.nodeTypeFilter.Copnet
        Any COP Network

    hou.nodeTypeFilter.Vop
        Any VOP

    hou.nodeTypeFilter.Vopnet
        Any VOP Network

    hou.nodeTypeFilter.Rop
        Any ROP

    hou.nodeTypeFilter.Shop
        Any SHOP

    hou.nodeTypeFilter.Obj
        Any Object

    hou.nodeTypeFilter.ObjBone
        Object: Bone Only

    hou.nodeTypeFilter.ObjCamera
        Object: Camera Only

    hou.nodeTypeFilter.ObjFog
        Object: Fog Only

    hou.nodeTypeFilter.ObjGeometry
        Object: Geometry Only

    hou.nodeTypeFilter.ObjGeometryOrFog
        Object: Geometry and Fog Only

    hou.nodeTypeFilter.ObjLight
        Object: Light Only

    hou.nodeTypeFilter.ObjMuscle
        Object: Muscle Only

    hou.nodeTypeFilter.ObjSubnet
        Object: Muscle Only

    hou.nodeTypeFilter.ShopAtmosphere
        Shop: Atmosphere Only

    hou.nodeTypeFilter.ShopCVEX
        Shop: CVEX Only

    hou.nodeTypeFilter.ShopDisplacement
        Shop: Displacement Only

    hou.nodeTypeFilter.ShopImage3D
        Shop: Image3D Only

    hou.nodeTypeFilter.ShopInterior
        Shop: Interior Only

    hou.nodeTypeFilter.ShopLight
        Shop: Light Only

    hou.nodeTypeFilter.ShopLightShadow
        Shop: Light Shadow Only

    hou.nodeTypeFilter.ShopShopMaterial
        Shop: Material Only

    hou.nodeTypeFilter.ShopPhoton
        Shop: Photon Only

    hou.nodeTypeFilter.ShopProperties
        Shop: Properties Only

    hou.nodeTypeFilter.ShopSurface
        Shop: Surface Only


    """
    NoFilter=None
    Sop=None
    Pop=None
    Popnet=None
    Chop=None
    Chopnet=None
    Cop=None
    Copnet=None
    Vop=None
    Vopnet=None
    Rop=None
    Shop=None
    Obj=None
    ObjBone=None
    ObjCamera=None
    ObjFog=None
    ObjGeometry=None
    ObjGeometryOrFog=None
    ObjLight=None
    ObjMuscle=None
    ObjSubnet=None
    ShopAtmosphere=None
    ShopCVEX=None
    ShopDisplacement=None
    ShopImage3D=None
    ShopInterior=None
    ShopLight=None
    ShopLightShadow=None
    ShopShopMaterial=None
    ShopPhoton=None
    ShopProperties=None
    ShopSurface=None
    def __init__(self): raise AttributeError, "No constructor defined"

class vdbData(object):
    """
    hou.vdbData

    Enumeration of hou.VDB voxel data types.

    * hou.vdbData.Boolean
    * hou.vdbData.Float
    * hou.vdbData.Int
    * hou.vdbData.Vector3

    """
    Boolean=None
    Float=None
    Int=None
    Vector3=None
    def __init__(self): raise AttributeError, "No constructor defined"
    
class channelEditorMode(object):
    
    def __init__(self): raise AttributeError, "No constructor defined"
    
class vopParmGenType(object):
    """
    hou.vopParmGenType

    Enumeration of the different node configurations that can be created for
    the inputs of a VOP node when calling hou.VopNode.insertParmGenerator()
    or hou.VopNode.insertParmGeneratorsForAllInputs().

    * hou.vopParmGenType.Constant

      Create a Constant VOP and connect it to the VOP node's input.

    * hou.vopParmGenType.Parameter

      Create a Parameter VOP and connect it to the VOP node's input.  The
      input parameter is automatically promoted to the VOP network's
      parameter interface.

    * hou.vopParmGenType.SubnetInput

      Create a Parameter VOP and connect it to the VOP node's input.
      Additionally set the Parameter VOP's Scope parameter to Subnet.  The
      input parameter is automatically promoted to the owning Subnet VOP's
      parameter interface.
    """
    Constant=None
    Parameter=None
    SubnetInput=None

    def __init__(self): raise AttributeError, "No constructor defined"

class stateGenerateMode(object):
    """
    hou.stateGenerateMode

    Enumeration of possible node generation modes by states.

    See hou.SceneViewer.setCurrentState for more information.

    * hou.stateGenerateMode.Insert
    * hou.stateGenerateMode.Branch

    """
    Insert=None
    Branch=None
    def __init__(self): raise AttributeError, "No constructor defined"
    
class SystemExit:
    """
    hou.SystemExit
    """
   
    def __init__(self, *args): 
        """
        hou.SystemExit
        """
    def code(self):
        """
        code(self) -> int
        """
        return 0

class Error:
    """
    hou.Error

    Base class for all exceptions in the hou module.

    You can check if an exception instance is a Houdini-specific exception
    using isinstance(ex, hou.Error).
    """

    def __init__(self, *args):
        """
        hou.Error

        Base class for all exceptions in the hou module.

        You can check if an exception instance is a Houdini-specific exception
        using isinstance(ex, hou.Error).
        """

    def exceptionTypeName(self):
        """
        exceptionTypeName(self) -> str

        Return the name of the exception type. Instances of different subclasses
        of hou.Error will return different names. Instances of the base class
        will return "Error".

        You can also use str(e.__class__) to get the name of the subclass.
        """
        return ''

    def description(self):
        """
        description(self) -> str

        Return a description of the class of exception. The description is not
        related to the exception instance.
        """
        return ''

    def instanceMessage(self):
        """
        instanceMessage(self) -> str

        Return a message specific to the exception instance.
        """
        return ''

class NotAvailable(Error):
    """
    hou.NotAvailable

    Exception class for when an operation attempted to use a feature that is
    not available.  This class is a subclass of hou.Error.

    RELATED
      * hou.Error


    """
    __swig_setmethods__ = {}
    for _s in [Error]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NotAvailable, name, value)
    __swig_getmethods__ = {}
    for _s in [Error]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, NotAvailable, name)
    def __init__(self, *args):
        """
        hou.NotAvailable

        Exception class for when an operation attempted to use a feature that is
        not available.  This class is a subclass of hou.Error.

        RELATED
          * hou.Error
        """

    def exceptionTypeName(self):
        """
        exceptionTypeName(self) -> str

        Return the name of the exception type. Instances of different subclasses
        of hou.Error will return different names. Instances of the base class
        will return "Error".

        You can also use str(e.__class__) to get the name of the subclass.
        """
        return ''

    def description(self):
        """
        description(self) -> str

        Return a description of the class of exception. The description is not
        related to the exception instance.
        """
        return ''


class ObjectWasDeleted(Error):
    """
    hou.ObjectWasDeleted

    Exception class for when you use a stale variable to attempt to access
    something that was deleted in Houdini.  This class is a subclass of
    hou.Error.

    For example, setting a variable to a Node object, deleting that node in
    Houdini, and attempting to call a method using the variable will raise
    this exception.

    RELATED
      * hou.Error


    """
    __swig_setmethods__ = {}
    for _s in [Error]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ObjectWasDeleted, name, value)
    __swig_getmethods__ = {}
    for _s in [Error]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ObjectWasDeleted, name)
    def __init__(self, *args):
        """
        hou.ObjectWasDeleted

        Exception class for when you use a stale variable to attempt to access
        something that was deleted in Houdini.  This class is a subclass of
        hou.Error.

        For example, setting a variable to a Node object, deleting that node in
        Houdini, and attempting to call a method using the variable will raise
        this exception.

        RELATED
          * hou.Error
        """

    def exceptionTypeName(self):
        """
        exceptionTypeName(self) -> str

        Return the name of the exception type. Instances of different subclasses
        of hou.Error will return different names. Instances of the base class
        will return "Error".

        You can also use str(e.__class__) to get the name of the subclass.
        """
        return ''

    def description(self):
        """
        description(self) -> str

        Return a description of the class of exception. The description is not
        related to the exception instance.
        """
        return ''

    def __repr__(self): return ''
    def __str__(self): return ''

class InvalidInput(Error):
    """
    hou.InvalidInput

    Exception that is raised when you try to set a node's input to something
    invalid.


    """
    __swig_setmethods__ = {}
    for _s in [Error]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InvalidInput, name, value)
    __swig_getmethods__ = {}
    for _s in [Error]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, InvalidInput, name)
    def __init__(self, *args):
        """
        hou.InvalidInput

        Exception that is raised when you try to set a node's input to something
        invalid.
        """
        this = InvalidInput()
        try: self.this.append(this)
        except: self.this = this
    def exceptionTypeName(self):
        """
        exceptionTypeName(self) -> str

        Return the name of the exception type. Instances of different subclasses
        of hou.Error will return different names. Instances of the base class
        will return "Error".

        You can also use str(e.__class__) to get the name of the subclass.
        """
        return ''

    def description(self):
        """
        description(self) -> str

        Return a description of the class of exception. The description is not
        related to the exception instance.
        """
        return ''

    def __repr__(self): return ''
    def __str__(self): return ''

class InvalidSize(Error):
    """
    hou.InvalidSize

    Exception that is raised when you pass a sequence of the wrong length to
    a function.


    """
    __swig_setmethods__ = {}
    for _s in [Error]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InvalidSize, name, value)
    __swig_getmethods__ = {}
    for _s in [Error]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, InvalidSize, name)
    def __init__(self, *args):
        """
        hou.InvalidSize

        Exception that is raised when you pass a sequence of the wrong length to
        a function.
        """
        this = InvalidSize()
        try: self.this.append(this)
        except: self.this = this
    def exceptionTypeName(self):
        """
        exceptionTypeName(self) -> str

        Return the name of the exception type. Instances of different subclasses
        of hou.Error will return different names. Instances of the base class
        will return "Error".

        You can also use str(e.__class__) to get the name of the subclass.
        """
        return ''

    def description(self):
        """
        description(self) -> str

        Return a description of the class of exception. The description is not
        related to the exception instance.
        """
        return ''

    def __repr__(self): return ''
    def __str__(self): return ''

class TypeError(Error):
    """
    hou.TypeError
    """
    __swig_setmethods__ = {}
    for _s in [Error]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypeError, name, value)
    __swig_getmethods__ = {}
    for _s in [Error]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TypeError, name)
    def __init__(self, *args):
        """
        hou.TypeError
        """
        this = TypeError()
        try: self.this.append(this)
        except: self.this = this
    def exceptionTypeName(self):
        """
        exceptionTypeName(self) -> str
        Return the name of the exception type. Instances of different subclasses
        of hou.Error will return different names. Instances of the base class
        will return "Error".

        You can also use str(e.__class__) to get the name of the subclass.
        """
        return ''

    def description(self):
        """
        description(self) -> str

        Return a description of the class of exception. The description is not
        related to the exception instance.
        """
        return ''

class ValueError(Error):
    """
    hou.ValueError
    """
    __swig_setmethods__ = {}
    for _s in [Error]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ValueError, name, value)
    __swig_getmethods__ = {}
    for _s in [Error]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ValueError, name)
    def __init__(self, *args):
        """
        hou.ValueError
        """
        this = self
        try: self.this.append(this)
        except: self.this = this
    def exceptionTypeName(self):
        """
        exceptionTypeName(self) -> str

        Return the name of the exception type. Instances of different subclasses
        of hou.Error will return different names. Instances of the base class
        will return "Error".

        You can also use str(e.__class__) to get the name of the subclass.
        """
        return ''

    def description(self):
        """
        description(self) -> str

        Return a description of the class of exception. The description is not
        related to the exception instance.
        """
        return ''

class OperationFailed(Error):
    """
    hou.OperationFailed
    """
    __swig_setmethods__ = {}
    for _s in [Error]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OperationFailed, name, value)
    __swig_getmethods__ = {}
    for _s in [Error]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, OperationFailed, name)
    def __init__(self, *args):
        """
        hou.OperationFailed
        """
        this = self

    def exceptionTypeName(self):
        """
        exceptionTypeName(self) -> str

        Return the name of the exception type. Instances of different subclasses
        of hou.Error will return different names. Instances of the base class
        will return "Error".

        You can also use str(e.__class__) to get the name of the subclass.
        """
        return ''

    def description(self):
        """
        description(self) -> str

        Return a description of the class of exception. The description is not
        related to the exception instance.
        """
        return ''

class InvalidNodeType(Error):
    """
    hou.InvalidNodeType

    Exception that is raised when you try to call a method on a Node that
    isn't supported by that type of node.

    For example, if you ask a non-subnet node for its indirect inputs,
    hou.Node.indirectInputs raises an instance of this exception.


    """
    __swig_setmethods__ = {}
    for _s in [Error]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InvalidNodeType, name, value)
    __swig_getmethods__ = {}
    for _s in [Error]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, InvalidNodeType, name)
    def __init__(self, *args):
        """
        hou.InvalidNodeType

        Exception that is raised when you try to call a method on a Node that
        isn't supported by that type of node.

        For example, if you ask a non-subnet node for its indirect inputs,
        hou.Node.indirectInputs raises an instance of this exception.
        """

    def exceptionTypeName(self):
        """
        exceptionTypeName(self) -> str

        Return the name of the exception type. Instances of different subclasses
        of hou.Error will return different names. Instances of the base class
        will return "Error".

        You can also use str(e.__class__) to get the name of the subclass.
        """
        return ''

    def description(self):
        """
        description(self) -> str

        Return a description of the class of exception. The description is not
        related to the exception instance.
        """
        return ''


class InitScriptFailed(Error):
    """
    hou.InitScriptFailed


    """
    __swig_setmethods__ = {}
    for _s in [Error]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InitScriptFailed, name, value)
    __swig_getmethods__ = {}
    for _s in [Error]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, InitScriptFailed, name)
    def __init__(self, *args):
        """
        hou.InitScriptFailed
        """

    def exceptionTypeName(self):
        """
        exceptionTypeName(self) -> str

        Return the name of the exception type. Instances of different subclasses
        of hou.Error will return different names. Instances of the base class
        will return "Error".

        You can also use str(e.__class__) to get the name of the subclass.
        """
        return ''

    def description(self):
        """
        description(self) -> str

        Return a description of the class of exception. The description is not
        related to the exception instance.
        """
        return ''

class MatchDefinitionError(Error):
    """
    hou.MatchDefinitionError


    """
    __swig_setmethods__ = {}
    for _s in [Error]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MatchDefinitionError, name, value)
    __swig_getmethods__ = {}
    for _s in [Error]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MatchDefinitionError, name)
    def __init__(self, *args):
        """
        hou.MatchDefinitionError        """

    def exceptionTypeName(self):
        """
        exceptionTypeName(self) -> str

        Return the name of the exception type. Instances of different subclasses
        of hou.Error will return different names. Instances of the base class
        will return "Error".

        You can also use str(e.__class__) to get the name of the subclass.        """
        return ''

    def description(self):
        """
        description(self) -> str

        Return a description of the class of exception. The description is not
        related to the exception instance.
        """
        return ''

class PermissionError(Error):
    """
    hou.PermissionError

    """
    def __init__(self, *args):
        """
        hou.PermissionError        """
    def exceptionTypeName(self):
        """
        exceptionTypeName(self) -> str
        Return the name of the exception type. Instances of different subclasses
        of hou.Error will return different names. Instances of the base class
        will return "Error".

        You can also use str(e.__class__) to get the name of the subclass.        """
        return ''

    def description(self):
        """
        description(self) -> str

        Return a description of the class of exception. The description is not
        related to the exception instance.        """
        return ''

    def instanceMessage(self):
        """
        instanceMessage(self) -> str
        Return a message specific to the exception instance.        """
        return ''

class GeometryPermissionError(Error):
    """
    hou.GeometryPermissionError
    Exception that is raised when you try to modify geometry from outside of
    a Python SOP.

    """
    def __init__(self, *args):
        """
        hou.GeometryPermissionError

        Exception that is raised when you try to modify geometry from outside of
        a Python SOP.        """

    def exceptionTypeName(self):
        """
        exceptionTypeName(self) -> str

        Return the name of the exception type. Instances of different subclasses
        of hou.Error will return different names. Instances of the base class
        will return "Error".

        You can also use str(e.__class__) to get the name of the subclass.        """
        return ''

    def description(self):
        """
        description(self) -> str

        Return a description of the class of exception. The description is not
        related to the exception instance.        """
        return ''

class KeyframeValueNotSet(Error):
    """
    hou.KeyframeValueNotSet

    """
    def __init__(self, *args):
        """
        hou.KeyframeValueNotSet
        """

    def exceptionTypeName(self):
        """
        exceptionTypeName(self) -> str

        Return the name of the exception type. Instances of different subclasses
        of hou.Error will return different names. Instances of the base class
        will return "Error".

        You can also use str(e.__class__) to get the name of the subclass.        """
        return ''

    def description(self):
        """
        description(self) -> str

        Return a description of the class of exception. The description is not
        related to the exception instance.        """
        return ''

class OperationInterrupted(Error):
    """
    hou.OperationInterrupted

    """
    def __init__(self, *args):
        """
        hou.OperationInterrupted        """
    def exceptionTypeName(self):
        """
        exceptionTypeName(self) -> str

        Return the name of the exception type. Instances of different subclasses
        of hou.Error will return different names. Instances of the base class
        will return "Error".

        You can also use str(e.__class__) to get the name of the subclass.        """
        return ''

    def description(self):
        """
        description(self) -> str

        Return a description of the class of exception. The description is not
        related to the exception instance.        """
        return ''

class LoadWarning(Error):
    """
    hou.LoadWarning

    Exception class for when loading a hip file in Houdini generates
    warnings.

    """
    def __init__(self, *args):
        """
        hou.LoadWarning

        Exception class for when loading a hip file in Houdini generates
        warnings.
        """

    def exceptionTypeName(self):
        """
        exceptionTypeName(self) -> str

        Return the name of the exception type. Instances of different subclasses
        of hou.Error will return different names. Instances of the base class
        will return "Error".

        You can also use str(e.__class__) to get the name of the subclass.        """
        return ''

    def description(self):
        """
        description(self) -> str

        Return a description of the class of exception. The description is not
        related to the exception instance.        """
        return ''

class NodeError(Error):
    """
    hou.NodeError

    Exception class used to set errors on nodes implemented via Python.

    Raise instances of this class from within Python SOPs, objects, etc. to
    set an error flag on the node.  See Writing Python SOPs for more
    information.

    RELATED
      * hou.NodeWarning
      * hou.Error

    """

    def __init__(self, *args):
        """
        hou.NodeError

        Exception class used to set errors on nodes implemented via Python.

        Raise instances of this class from within Python SOPs, objects, etc. to
        set an error flag on the node.  See Writing Python SOPs for more
        information.

        RELATED
          * hou.NodeWarning
          * hou.Error        """

    def exceptionTypeName(self):
        """
        exceptionTypeName(self) -> str

        Return the name of the exception type. Instances of different subclasses
        of hou.Error will return different names. Instances of the base class
        will return "Error".

        You can also use str(e.__class__) to get the name of the subclass.
        """
        return ''

    def description(self):
        """
        description(self) -> str

        Return a description of the class of exception. The description is not
        related to the exception instance.        """
        return ''

class NodeWarning(Error):
    """
    hou.NodeWarning

    Exception class used to set warnings on nodes implemented via Python.

    Raise instances of this class from within Python SOPs, objects, etc. to
    set an warning messages on the node.  See Writing Python SOPs for more
    information.

    RELATED
      * hou.NodeError
      * hou.Error
    """

    def __init__(self, *args):
        """
        hou.NodeWarning

        Exception class used to set warnings on nodes implemented via Python.

        Raise instances of this class from within Python SOPs, objects, etc. to
        set an warning messages on the node.  See Writing Python SOPs for more
        information.

        RELATED
          * hou.NodeError
          * hou.Error
        """

    def exceptionTypeName(self):
        """
        exceptionTypeName(self) -> str

        Return the name of the exception type. Instances of different subclasses
        of hou.Error will return different names. Instances of the base class
        will return "Error".

        You can also use str(e.__class__) to get the name of the subclass.
        """
        return ''

    def description(self):
        """
        description(self) -> str

        Return a description of the class of exception. The description is not
        related to the exception instance.
        """
        return ''


class NetworkBox(object):
    """
    hou.NetworkBox

    Represents a network box.

    To create a network box, use the hou.Node.createNetworkBox method on the
    node inside which you want to create the box. To get an existing network
    box, use the hou.Node.findNetworkBox method on the node containing the
    network box. To get a list of all network boxes in a network, use the
    hou.Node.networkBoxes method on the containing node.

    REPLACES
      * nbcolor
      * nbget
      * nblocate
      * nbls
      * nblsop
      * nbname
      * nbop
      * nbrm
      * nbset
      * nbsize
      * opscript


    """

    def __init__(self): raise AttributeError, "No constructor defined"

    def name(self):
        """
        name(self) -> str

        Return the name of the network box.        """
        return ''

    def setName(self):
        """
        setName(self, name)

        Sets the name of the network box.        """

    def parent(self):
        """
        parent(self) -> Node

        Returns the node which contains the network box.        """
        return Node()

    def position(self):
        """
        position(self) -> hou.Vector2

        Return the position of this network box.        """
        return Vector2()

    def setPosition(self, vector2):
        """
        setPosition(self, vector2)

        Sets the position of this network box to the given hou.Vector2. Use
        move() to move the box relative to its current position.        """

    def move(self, vector2):
        """
        move(self, vector2)

        Moves the network box by the increments in the given hou.Vector2. Use
        setPosition() to set the box's absolute position.        """


    def size(self):
        """
        size(self) -> hou.Vector2

        Returns the size of this network box.
        """
        return Vector2()

    def setSize(self, size):
        """
        setSize(self, size)

        Sets the size of this network box to the given hou.Vector2. Use resize()
        to set the box's size relative to its current size.        """

    def resize(self, vector2):
        """
        resize(self, vector2)

        Resizes a network box by the increments in the given hou.Vector2. Use
        setSize() to set the box's absolute size.        """

    def fitAroundContents(self):
        """
        fitAroundContents(self)

        Resizes the network box to fit its contents.        """

    def isMinimized(self):
        """
        isMinimized(self) -> bool

        Returns whether the network box is minimized.        """
        return True

    def setMinimized(self):
        """
        setMinimized(self, on)

        Minimizes or restores the network box.        """

    def isPicked(self):
        """
        isPicked(self) -> bool

        Returns whether the network box is selected.        """
        return True

    def setPicked(self, on):
        """
        setPicked(self, on)

        Selects or deselects the network box.        """

    def color(self):
        """
        color(self) -> hou.Color
        Returns the color of this network box.
        """
        return Color()

    def setColor(self, color):
        """
        setColor(self, color)
        Set the color of this network box to the given hou.Color.
        """

    def nodes(self, recurse=True):
        """
        nodes(self, recurse=True) -> tuple of hou.Node

        Returns the nodes inside the network box.

        recurse
            If True, recurses down into nested network boxes.        """
        return (Node(),)

    def addNode(self, node):
        """
        addNode(self, node)
        Adds a node to the network box.
        """
    def removeNode(self, node):
        """
        removeNode(self, node)

        Removes the given node from the network box.
        """

    def removeAllNodes(self):
        """
        removeAllNodes(self)

        Removes all nodes from the network box.
        """

    def networkBoxes(self, recurse=True):
        """
        networkBoxes(self, recurse=True) -> tuple of hou.NetworkBox
        Returns the network boxes inside the network box.

        recurse
            If True, recurses down into nested network boxes.
        """
        return (NetworkBox(),)

    def stickyNotes(self, recurse=True):
        """
        stickyNotes(self, recurse=True) -> tuple of hou.StickyNote

        Returns the sticky notes inside the network box.

        recurse
            If True, recurses down into nested network boxes.        """
        return (StickyNote(),)

    def destroy(self, destroy_contents=False):
        """
        destroy(self, destroy_contents=False)

        Remove and delete the network box, optionally deleting the nodes it
        contains.        """


    def asCode(self, brief=False, recurse=False, save_box_contents=False,
        save_channels_only=False, save_creation_commands=False,
        save_keys_in_frames=False, save_parm_values_only=False,
        save_spare_parms=False, function_name=None):
        """
        asCode(self, brief=False, recurse=False, save_box_contents=False,
        save_channels_only=False, save_creation_commands=False,
        save_keys_in_frames=False, save_parm_values_only=False,
        save_spare_parms=False, function_name=None) -> string

        Prints the Python code necessary to recreate a network box.

        See hou.Node.asCode for information on the keyword arguments.        """
        return ''

class StickyNote(object):
    """
    hou.StickyNote

    Represents a sticky note.

    To create a sticky note, use the hou.Node.createStickyNote method on the
    node inside which you want to create the note. To get an existing sticky
    note, use the hou.Node.findStickyNote method on the node containing the
    sticky note. To get a list of all notes in a network, use the
    hou.Node.stickyNotes method on the containing node.

    """

    def __init__(self): raise AttributeError, "No constructor defined"

    def name(self):
        """
        name(self) -> str

        Return the name of the sticky note.        """
        return ''

    def setName(self, name):
        """
        setName(self, name)

        Sets the name of the sticky note.
        """

    def text(self):
        """
        text(self) -> str

        Return the text of the sticky note.        """
        return ''

    def setText(self, str):
        """
        setText(self, str)

        Sets the text of the sticky note.
        """

    def parent(self):
        """
        parent(self) -> Node

        Returns the node which contains the sticky note.        """
        return Node()

    def color(self):
        """
        color(self) -> hou.Color

        Returns the color of this sticky note.        """
        return Color()

    def setColor(self, color):
        """
        setColor(self, color)

        Set the color of this sticky note to the given hou.Color.
        """

    def position(self):
        """
        position(self) -> hou.Vector2
        Return the position of this sticky note.        """
        return Vector2()

    def setPosition(self, vector2):
        """
        setPosition(self, vector2)

        Sets the position of this sticky note to the given hou.Vector2. Use
        move() to move the note relative to its current position.
        """

    def move(self, vector2):
        """
        move(self, vector2)

        Moves the sticky note by the increments in the given hou.Vector2. Use
        setPosition() to set the note's absolute position.
        """

    def size(self):
        """
        size(self) -> hou.Vector2

        Returns the size of this sticky note.        """
        return Vector2()

    def setSize(self, size):
        """
        setSize(self, size)

        Sets the size of this sticky note to the given hou.Vector2. Use resize()
        to set the note's size relative to its current size.
        """

    def resize(self, vector2):
        """
        resize(self, vector2)

        Resizes a sticky note by the increments in the given hou.Vector2. Use
        setSize() to set the note's absolute size.
        """


    def isMinimized(self):
        """
        isMinimized(self) -> bool

        Returns whether the sticky note is minimized.        """
        return True

    def setMinimized(self, on):
        """
        setMinimized(self, on)

        Minimizes or restores the sticky note.        """

    def isPicked(self):
        """
        isPicked(self) -> bool

        Returns whether the sticky note is selected.        """
        return True

    def setPicked(self, on):
        """
        setPicked(self, on)

        Selects or deselects the sticky note.        """

    def destroy(self):
        """
        destroy(self)

        Remove and delete the sticky note.        """

    def asCode(self, brief=False, recurse=False, save_box_contents=False,
        save_channels_only=False, save_creation_commands=False,
        save_keys_in_frames=False, save_parm_values_only=False,
        save_spare_parms=False, function_name=None):
        """
        asCode(self, brief=False, recurse=False, save_box_contents=False,
        save_channels_only=False, save_creation_commands=False,
        save_keys_in_frames=False, save_parm_values_only=False,
        save_spare_parms=False, function_name=None) -> string

        Prints the Python code necessary to recreate a sticky note.

        See hou.Node.asCode for information on the keyword arguments.
        """
        return ''

class ObjNode(object):
    """
    hou.ObjNode

    An instance of an object node in the Houdini scene.

    Each object has a "transformation" (or "transform") encapsulating
    its position (or "translation"), rotation, and scale. For a subnet
    object, the subnet's transform is applied to the objects inside the
    subnet. An object can have additional transforms from parent objects on
    top of the transform defined by its parameters, as well as a normally
    hidden pretransform that defines the object's "rest" or "zero"
    position (normally all zeros). An object's final position/rotation/scale
    in world space is defined by (object's transform) * (pretransform) *
    (parent transform).


    You can set an object's position/rotation/scale to certain world space
    values regardless of parent/pre-transform values with the
    hou.ObjNode.setWorldTransform method.


    Houdini does not support shear parameters on objects. If you try to set
    an object's parameters to a transform containing shear, Houdini will
    automatically remove the shear.


    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def origin(self):
        """
        origin(self) -> hou.Vector3

        Return the object's origin position, in world space.

        obj.origin() is equivalent to obj.Vector3(0, 0, 0) *
        obj.worldTransform().

          # To compute the world space vector from obj1's origin to obj2's origin, you
          # can write:
          obj2.origin() - obj1.origin()

          # To compute the distance, in world space, between the origins of two
          # objects, simply take the length of this vector:
          (obj2.origin() - obj1.origin()).length()

          # If there are no rotations or scales, the vtorigin() hscript expression
          # function will return the same result as obj2.origin() - obj1.origin().
          # If there are rotations or scales, though, it won't.  A Python equivalent
          # of vtorigin() is defined by:
          def vtorigin(obj1, obj2):
              return (obj2.worldTransform() * obj1.worldTransform().inverted()).extractTranslates()

        See also the hou.ObjNode.worldTransform and
        hou.ObjNode.getTransformToNode methods.

        REPLACES
            origin function        """
        return Vector3()

    def localTransform(self):
        """
        localTransform(self) -> hou.Matrix4

        Return the matrix that transforms this object's geometry into space of
        its input.

        The local transform matrix contains the cumulative transforms of:

        * The node's pre-transform
        * The transform defined by the node's transform parameters
        * The transform adjustment by the node's lookat and path parameters
        See also hou.ObjNode.localTransformAtTime and
        hou.ObjNode.worldTransform.
        """
        return Matrix4()

    def localTransformAtTime(self, time):
        """
        localTransformAtTime(self, time) -> hou.Matrix4

        Return, for the specified time, the matrix that transforms this object's
        geometry into the space of its input.

        If the object's local transform is animated, this method provides a way
        to get the transformation at a specific time.

        See hou.ObjNode.localTransform for more information.
        """
        return Matrix4()

    def worldTransform(self):
        """
        worldTransform(self) -> hou.Matrix4

        Return the matrix that transforms this object's geometry into world
        space.

        The world transform matrix contains the cumulative transforms of:

        * The node's pre-transform
        * The transform defined by the node's parameters
        * The transforms of parent nodes or containing networks
        This method can approximately be implemented as follows:

              def worldTransform(self):
                  return (self.localTransform() * self.parentAndSubnetTransform())



        See also hou.ObjNode.setWorldTransform and
        hou.ObjNode.worldTransformAtTime.

        REPLACES
            optransform function        """
        return Matrix4()

    def worldTransformAtTime(self, time):
        """
        worldTransformAtTime(self, time) -> hou.Matrix4

        Return, for the specified time, the matrix that transforms this object's
        geometry into world space.

        If the object's world transform is animated, this method provides a way
        to get the transformation at a specific time.

        See hou.ObjNode.worldTransform for more information.
        """
        return Matrix4()

    def setWorldTransform(self, matrix, fail_on_locked_parms=False):
        """
        setWorldTransform(self, matrix, fail_on_locked_parms=False)

        Adjust this object's parameters to achieve the desired world
        transformation.

        This method will adjust the translate, rotate, and scale values of this
        object to achieve the desired final world transform.  It accounts for
        the transforms of containing networks, parent transforms, and pre-
        transforms.

        If fail_on_locked_parms is True, and any of the translate, rotate, or
        scale parameters of the object are locked, this method raises
        hou.OperationFailed.  If it is False and any of those parameters are
        locked, this method will change their values but leave them locked.

        Suppose:

        * W is the desired new world transform,
        * W' is the existing world transform,
        * L is the desired transform defined by the node's parameters,
        * L' is the existing parm transform,
        * P is the object's pre-transform,
        * O is the parent transform combined with the containing subnet's,
          transform
        Then, since W = L * P * O we have P = W * O^ * R^.  So, this method
        could be implemented as follows:
          def setWorldTransform(self):
              self.setParmTransform(
                  matrix * self.parentAndSubnetTransform().inverted() * self.preTransform().inverted(),
                  fail_on_locked_parms)


        Alternately, we can derive L from W' and L' as follows:

        * W' = L' * P * O
        * so P * O = L^' * W'
        * and (P * O)^ = W^' * L'
        and

        * W = L * P * O
        * so L = W * (P * O)^
        * giving L = W * W'^ * L'
        Thus, this method could also be implemented using the current world and
        parm transforms as follows:
          def setWorldTransform(self):
              self.setParmTransform(
                  matrix * self.worldTransform().inverted() * self.parmTransform(),
                  fail_on_locked_parms)


        Note that, because parm transforms cannot contain shears, it is possible
        that the resulting world transform will not match the desired transform.
        If r is a function that removes shears from a transform then the new
        world transform will actually be L * P * O = r(W * O^ * P^) * P * O.

        See also hou.ObjNode.worldTransform and hou.ObjNode.setParmTransform.
        """

    def setCookTransform(self, matrix):
        """
        setCookTransform(self, matrix)

        Set the parameter transform for the Python object that's cooking.  Call
        this method from objects implemented in Python to set the result of the
        cook.

        Note that an object implemented in Python controls the parameter
        transform (i.e. the result of hou.ObjNode.parmTransform).  The world
        transform (i.e. the result of hou.ObjNode.worldTransform) is still
        affected by parent node's transforms, pre-transforms, etc.

        This method raises hou.OperationFailed if you call it on an object that
        is not implemented in Python or if you call it from outside that
        object's Python cook code.

        See the Transforms from Disk example.        """


    def parmTransform(self):
        """
        parmTransform(self) -> hou.Matrix4

        Return the transform defined by the parameters on this node.

        This method can approximately be implemented as follows:
          def parmTransform(self):
              pivot_transform = hou.hmath.buildTranslate(self.evalParmTuple("p"))
              return (
                  pivot_transform.inverted() *
                  hou.hmath.buildTransform({
                          "translate": self.evalParmTuple("t"),
                          "rotate": self.evalParmTuple("r"),
                          "scale": [self.evalParm("scale") * s
                              for s in self.evalParmTuple("s")],
                          "shear": (0.0, 0.0, 0.0)},
                      transform_order=self.parm("xOrd").evalAsString(),
                      rotate_order=self.parm("rOrd").evalAsString()) *
                  pivot_transform)


        See the class documentation for the relation between this transform and
        the world space transform.  See also hou.ObjNode.worldTransform.


        For Python Objects, the python code sets the parm transform as well and

        won't necessarily have any visible parameters. To get the local
        transform of an object (ie. the transform without any parenting), use
        hou.ObjNode.localTransform.
        """
        return Matrix4()

    def setParmTransform(self, matrix, fail_on_locked_parms=False):
        """
        setParmTransform(self, matrix, fail_on_locked_parms=False)

        Sets the transform controlled by this object's parameters.

        This method will adjust the translate, rotate, and scale values of this
        object to achieve the desired parameter, or local, transform.  It will
        account for the existing pivot position, transformation order, and
        rotation order, and will leave them unchanged.

        Note that object nodes do not currently have shears parameters, so any
        shears in the matrix will be discarded.

        If fail_on_locked_parms is True, and any of the translate, rotate, or
        scale parameters of the object are locked, this method will raise
        hou.OperationFailed.  If it is False and any of those parameters are
        locked, this method will change their values but leave them locked.

        See also hou.ObjNode.parmTransform and hou.ObjNode.setWorldTransform.

        This method can be approximately implemented as follows, ignoring locked
        parameters:
          def setParmTransform(self, matrix):
              parm_values = matrix.explode(
                  transform_order=self.parm('xOrd').evalAsString(),
                  rotate_order=self.parm('rOrd').evalAsString(),
                  pivot=hou.Vector3(self.evalParmTuple('p')))

              for parm_name, key in ('t', 'translate'), ('r', 'rotate'), ('s', 'scale'):
                  self.parmTuple(parm_name).set(parm_values[key])


        See also hou.Matrix4.explode.        """


    def preTransform(self):
        """
        preTransform(self) -> hou.Matrix4

        Return this object's pretransform.

        The pre-transform allows you to apply a transform after the parameter
        transform but before input and containing object transforms.  See the
        class documentation for more details.

        Unlike the parameter transform, the pretransform is not stored using any
        parameters on the node.  Instead, Houdini stores the pretransform as a
        matrix.  Because it is directly as a matrix, the pretransform may
        contain shears.

        REPLACES
            objpretransform command
            objpretransform function        """
        return Matrix4()

    def setPreTransform(self, matrix):
        """
        setPreTransform(self, matrix)

        Set this object's pretransform.  See hou.ObjNode.preTransform for more
        information.

        REPLACES
            objpretransform command
            objresetpretransform command        """

    def movePreTransformIntoParmTransform(self):
        """
        movePreTransformIntoParmTransform(self)

        Set this object's pre-transform to the identity and adjust the parm
        transform so that the world transform does not change.

        This method is implemented approximately as follows:
          def movePreTransformIntoParmTransform(self):
              self.setParmTransform(self.parmTransform() * self.preTransform())
              self.setPreTransform(hou.hmath.identityTransform())


        See also hou.ObjNode.movePreTransformIntoParmTransform.

        REPLACES
            objextractpretransform command        """

    def moveParmTransformIntoPreTransform(self):
        """
        moveParmTransformIntoPreTransform(self)

        Set this object's parm transform to the identity and adjust the pre-
        transform so that the world transform does not change.

        This method is implemented approximately as follows:
          def moveParmTransformIntoPreTransform(self):
              self.setPreTransform(self.parmTransform() * self.preTransform())
              self.setParmTransform(hou.hmath.identityTransform())


        See also hou.ObjNode.moveParmRotateIntoPreTransform,
        hou.ObjNode.moveParmScaleIntoPreTransform, and
        hou.ObjNode.moveParmTranslateIntoPreTransform.  Also see
        hou.ObjNode.movePreTransformIntoParmTransform.

        REPLACES
            objcleantransform command
        """


    def moveParmTranslateIntoPreTransform(self):
        """
        moveParmTranslateIntoPreTransform(self)

        Set this object's translate values to zero and adjust the pre-transform
        so that the world transform does not change.

        See hou.ObjNode.moveParmRotateIntoPreTransform for more information.

        REPLACES
            objcleantransform command        """

    def moveParmRotateIntoPreTransform(self):
        """
        moveParmRotateIntoPreTransform(self)

        Set this object's rotate values to zero and adjust the pre-transform so
        that the object's world transform does not change.

        Suppose:

        * W is the world transform,
        * L is the parameter transform without any rotate component,
        * L' is the existing parm transform,
        * P is the desired new pre-transform,
        * P' is the current pre-transform,
        * O is the parent transform combined with the containing subnet's,
          transform
        Then,

        * W = L * P * O and W = L' * P' * O
        * L * P = L' * P'
        * P = L^ * L' * P'
        So, this method is implemented approximately as follows:
          def moveParmRotateIntoPreTransform(self):
              old_parm_transform = self.parmTransform()
              self.parmTuple("r").set((0.0, 0.0, 0.0))
              self.setPreTransform(
                  self.parmTransform() * old_parm_transform * self.preTransform())


        See also hou.ObjNode.preTransform and the class documentation.

        REPLACES
            objcleantransform command        """

    def moveParmScaleIntoPreTransform(self):
        """
        moveParmScaleIntoPreTransform(self)

        Set this object's scale values to one and adjust the pre-transform so
        that the world transform does not change.

        See hou.ObjNode.moveParmRotateIntoPreTransform for more information.

        REPLACES
            objcleantransform command        """

    def parentAndSubnetTransform(self):
        """
        parentAndSubnetTransform(self) -> hou.Matrix4

        Return the input node's world space transform (if there is an input
        connected), combined with the world space transform of the containing
        subnet object (if there is one).  See the class documentation for more
        information.

        This method can approximately be implemented as follows:
          def parentAndSubnetTransform(self):
              if len(self.inputConnectors()[0]) != 0:
                  return self.inputs()[0].worldTransform()

              containing_subnet = self.parent()
              if containing_subnet.type().category() == hou.objNodeTypeCategory():
                  return containing_subnet.worldTransform()

              return hou.hmath.identityMatrix()
        """
        return Matrix4()

    def getTransformToNode(self, obj_node):
        """
        getTransformToNode(self, obj_node) -> hou.Matrix4

        TODO: Document the relationship with vtorigin.
        **********************************************

        Return a matrix that transforms this node to line up with the other
        node.

        The following invariant is true: node1.worldTransform() *
        node1.getTransformToNode(node2) == node2.worldTransform().

        This method can be implemented as follows:
          def getTransformToNode(self, obj_node):
              self.worldTransform().inverted() * obj_node.worldTransform()


        To align node1 (an ObjNode object) with node2 (another ObjNode object),
        you don't need to use getTransformToNode(). You can simply write:
        node1.setWorldTransform(node2.worldTransform()).

        See also hou.ObjNode.origin(), hou.ObjNode.worldTransform(), and
        hou.ObjNode.setWorldTransform().

        REPLACES
            vorigin function
            vrorigin function
            vtorigin function        """
        return Matrix4()

    def getTransformFromPointToPoint(self, pos3, other_node, other_pos3):
        """
        getTransformFromPointToPoint(self, pos3, other_node, other_pos3) ->
        hou.Matrix4

        Return the transform matrix that rotates the point pos3 (in this object
        node's transform space) to the point other_pos3 (in another object
        node's transform space).

          obj1.getTransformFromPointToPoint(pos1, obj2, pos2)

        ...is equivalent to...

          (obj1.worldTransform().inverted() *
              hou.hmath.buildTranslate(-pos1) *
              hou.hmath.buildTranslate(pos2) *
              obj2.worldTransform())

        See also the hou.ObjNode.getTransformToNode and
        hou.ObjNode.worldTransform methods, and the functions in the hou.hmath
        module.

        REPLACES
            originoffset function        """
        return Matrix4()

    def buildLookatRotation(self, to_node, up_vector=None):
        """
        buildLookatRotation(self, to_node, up_vector=None) -> hou.Matrix4

        Return a matrix that will rotate this object to look at the specified
        object.

        The returned hou.Matrix4 object transforms this object from its current
        position in world space so that its negative z axis points at the origin
        of the to_node object.

        up_vector can either be a hou.Vector3 object or None.  If it is None,
        this method uses an up vector of hou.Vector3(0, 1, 0).

        You can extract the rotation values from the return value with
        hou.Matrix4.extractRotates.  You can set an object's transform with
        hou.ObjNode.setWorldTransform.

          # Set the cam1 object's transform so it points at geo1.
          cam1 = hou.node("/obj/cam1")
          lookat_obj = hou.node("/obj/geo1")
          cam1.setWorldTransform(cam1.buildLookatRotation(lookat_obj))

        See also hou.ObjNode.setWorldTransform.

        REPLACES
            mlookat function
            mobjlookat function        """
        return Matrix4()

    def isObjectDisplayed(self):
        """
        isObjectDisplayed(self) -> bool

        Return whether or not this object is displayed.  This method takes into
        account both the display flag and the display parameter.  If the display
        parameter is enabled, because the tdisplay parameter is set, this
        parameter overrides the flag.

        See also hou.ObjNode.isDisplayFlagSet, which returns the current state
        of the flag.
        """
        return True

    def isDisplayFlagSet(self):
        """
        isDisplayFlagSet(self) -> bool

        Return whether or not this object's display flag is turned on.  Note
        that the display flag and the display parameter both determine whether
        the object is actually displayed.

        Use hou.ObjNode.isObjectDisplayed to determine if the object is actually
        displayed.

        REPLACES
            opget command
            opflag function        """
        return True

    def setDisplayFlag(self, on):
        """
        setDisplayFlag(self, on)

        Turn the object's display flag on or off.  See also
        hou.ObjNode.isDisplayFlagSet.

        REPLACES
            opset command        """

    def isSelectableInViewport(self):
        """
        isSelectableInViewport(self) -> bool

        Return whether or not the selectable flag is set.  When it is not set,
        it is not possible to select this object or any of its geometry
        interactively in the viewport.

        REPLACES
            opget command
            opflag function        """
        return True

    def setSelectableInViewport(self, on):
        """
        setSelectableInViewport(self, on)

        Set the object's selectable flag.  See
        hou.ObjNode.isSelectableInViewport for more information.

        REPLACES
            opset command        """

    def isShowingOrigin(self):
        """
        isShowingOrigin(self) -> bool

        Return whether or not this object displays its local origin gnomon in
        the viewport.

        Note that you can change this setting by right-clicking on the node.

        REPLACES
            opget command
            opflag function        """
        return True

    def showOrigin(self, on):
        """
        showOrigin(self, on)

        Show or hide this object's local origin gnomon in the viewport.  See
        also hou.ObjNode.isShowingOrigin.

        REPLACES
            opset command        """

    def isUsingXray(self):
        """
        isUsingXray(self) -> bool

        Return whether or not this object displays its geometry in xray mode.
        Houdini displays xrayed geometry in wireframe and makes it visible even
        when it is hidden behind another surface.

        Note that you can change this setting by right-clicking on the node.

        REPLACES
            opget command
            opflag function        """
        return True

    def useXray(self, on):
        """
        useXray(self, on)

        Turn this object's xray mode on or off.  See also
        hou.ObjNode.isUsingXray.

        REPLACES
            opset command        """

    def displayNode(self):
        """
        displayNode(self) -> hou.Node or None

        If this object contains SOPs or DOPs, return the one that has its
        display flag on.  Otherwise, return None.
        """
        return Node()

    def renderNode(self):
        """
        renderNode(self) -> hou.Node or None

        If this object contains SOPs or DOPs, return the one that has its render
        flag on.  Otherwise, return None.
        """
        return Node()

    def combine(self, nodes):
        """
        combine(self, nodes)

        Combine the geometry from the given list of hou.ObjNode's into this
        object. After this operation, the old objects will be deleted.

        Raises hou.ObjectWasDeleted if any of the nodes no longer exist in
        Houdini.  Raises TypeError if any of the nodes are not of type
        hou.ObjNode.  These exceptions are raised prior to performing the
        combine operation to avoid partial results.        """

    def material(self, operation, parameter):
        """
        material(self, operation, parameter)

        Manages object-local overrides of material parameters. This is basically
        the scripting equivalent of the Material Override menu in the parameter
        editor for objects. It allows you to create parameters on an object that
        override the equivalent values on the object's material.

        The operation argument should be one of the following strings:

        "override"
            Create parameters on the object to override _all_ material
            parameters.

        "select"
            Select and create object parameters to override material parameters.

        "remove"
            Removes _all_ object parameter overrides.

        "rmdefault"
            Removes any unchanged object parameters (that is, that are currently
            set to their default value).

        "sync"
            Synchronize the object parameter overrides with the parameter
            definitions on the material.

        "revert"
            Revert any parameter overrides on the object to their values on the
            material.

        "addlist"
            (Followed by a second argument containing a list of parameter names
            strings.) Creates object parameters to override the named parameters
            on the material.


          myobject = hou.node("/obj/obj1")

          # Add all material overrides
              myobject.material("override")

              # Remove all material overrides
              myobject.material("remove")

              # Add specific overrides for "baseColor" and "roughness" parameters
              myobject.material("addlist", ["baseColor", "roughness"])

        REPLACES
            objmaterial command        """

class NodeGroup(object):
    """
    hou.NodeGroup

    Represents a node group.

    In Houdini, a node group contains a set of nodes from the same network.
    Each group is named, and you can edit a group's contents from the
    network view pane by selecting Viewing Controls > Show Groups from its
    right-mouse menu.

    A node bundle, on the other hand, may contain nodes from multiple
    networks, and corresponds to a hou.NodeBundle object.  You can edit a
    node bundle from the bundle list pane.


    """

    def __init__(self): raise AttributeError, "No constructor defined"

    def name(self):
        """
        name(self) -> str

        Returns the name of this group.
        """
        return ''

    def nodes(self):
        """
        nodes(self) -> tuple of hou.Node

        Return a tuple containing the nodes in this group.

        REPLACES
            opgls command        """
        return (Node(),)

    def parent(self):
        """
        parent(self) -> hou.Node

        Returns the network node containing this group.
        """
        return Node()

    def addNode(self, node):
        """
        addNode(self, node)

        Add a hou.Node to this group.

        If the node is already in the group, this method does nothing.  If the
        node is not in the correct network for this group, raises
        hou.OperationFailed.

        REPLACES
            opgop command        """

    def removeNode(self, node):
        """
        removeNode(self, node)

        Remove a hou.Node from this group.

        Raises hou.OperationFailed if the node is not in the group.

        REPLACES
            opgop command        """

    def clear(self):
        """
        clear(self)

        Remove all nodes from this group.

        REPLACES
            opgop command        """


    def destroy(self):
        """
        destroy(self)

        Delete this group.  Does not delete the nodes that were contained in it.

        REPLACES
            opgrm command
        """

    def asCode(self, save_creation_commands=False, function_name=None):
        """
        asCode(self, save_creation_commands=False, function_name=None) -> str

        Returns the Python code necessary to recreate this group.

        save_creation_commands
            Generate a creation script for the node group.  If set to False (the
            default), the generated script assumes that the node group already
            exists.  When set to True, the script will begin by creating the
            node group.

        function_name
            If a function_name is specified, the output will be wrapped in a
            Python function.

        REPLACES
            opscript command        """
        return ''

class Prim(object):
    """
    hou.Prim

    Each Prim resides inside a Geometry object and stores some sort of 3D
    geometric primitive, like a polygon, a NURBS curve, or a volume.  Each
    primitive usually contains a set of Vertex objects, each of which
    references a Point object.

    This class has a number of subclasses for the different primitive types,
    such as hou.Polygon and hou.Volume.


    """

    def __init__(self): raise AttributeError, "No constructor defined"

    def geometry(self):
        """
        geometry(self) -> hou.Geometry

        Return the hou.Geometry object containing this primitive.        """
        return Geometry()

    def number(self):
        """
        number(self) -> int

        Return the number of this primitive.  Primitives are numbered
        sequentially starting from 0, and the primitives returned by
        hou.Geometry.prims are in order by their number.

        REPLACES
            pointlist function
            primlist function        """
        return 0

    def type(self):
        """
        type(self) -> hou.primType enum value

        Return a hou.primType value containing the type of this primitive (e.g.
        polygon, NURBS curve, metaball, etc).
        """
        return primType()

    def attribType(self):
        """
        attribType(self) -> hou.attribType enum value

        Return the enumerated value hou.attribType.Prim.  Points, primitives,
        vertices, and geometry support the same set of methods for querying
        their attributes, and this method is one of them.

        See also:

        * hou.Point.attribType
        * hou.Vertex.attribType
        * hou.Geometry.attribType
        * hou.attribType        """
        return primType()

    def vertices(self):
        """
        vertices(self) -> generator of hou.Vertex

        Return a sequence of the vertices contained in this primitive.

        If the primitive is a face (e.g. a polygon or NURBS curve), the result
        corresponds to the order of the vertices in that face.  If it is a
        surface (e.g. a NURBS mesh), however, the primitive has a 2D array of
        vertices, and this method returns all vertices in the 2D array, ordered
        by the rows.

        See hou.Surface.vertex for more information about the relationship
        between the 2D vertex array and the sequential vertex index, and for
        more ways to access the vertices in a surface.
        """
        return (Vertex(),)

    def numVertices(self):
        """
        numVertices(self) -> int

        A shortcut for len(self.vertices()).  You probably don't need to call
        this method.
        """
        return 0

    def edges(self): return (Edge(),)
    def numEdges(self): return 0
    def floatAttribValue(self, attrib):
        """
        floatAttribValue(self, attrib) -> float

        Return the primitive attribute value for a particular floating point
        attribute.  The attribute may be specified by name or by hou.Attrib
        object.

        Raises hou.OperationFailed if no attribute exists with this name or the
        attribute is not float of size 1.

        In most cases, you'll just use hou.Prim.attribValue to access attribute
        values.  Houdini uses this method internally to implement attribValue.
        """
        return 0.0

    def floatListAttribValue(self, name_or_attrib):
        """
        floatListAttribValue(self, name_or_attrib) -> tuple of float

        Return the primitive attribute value for a particular floating point
        attribute.  The attribute may be specified by name or by hou.Attrib
        object.  The return value is a tuple of floats.

        It is valid to call this method when the attribute's size is 1.  In this
        case, a tuple with one element is returned.

        See also hou.Prim.attribValue.        """
        return (0.0,)

    def intAttribValue(self, name_or_attrib):
        """
        intAttribValue(self, name_or_attrib) -> int

        Return the primitive attribute value for a particular integer attribute
        of size 1.  The attribute may be specified by name or by hou.Attrib
        object.  See hou.Point.floatAttribValue for more information.
        """
        return (0,)

    def intListAttribValue(self, name_or_attrib):
        """
        intListAttribValue(self, name_or_attrib) -> tuple of int

        Return the primitive attribute value for a particular integer attribute.
        The attribute may be specified by name or by hou.Attrib object.  The
        return value is a tuple of ints.  See hou.Prim.floatListAttribValue for
        more information.
        """
        return (0,)

    def stringAttribValue(self, name_or_attrib):
        """
        stringAttribValue(self, name_or_attrib) -> str

        Return the primitive attribute value for a particular string attribute.
        The attribute may be specified by name or by hou.Attrib object.  See
        hou.Prim.floatAttribValue for more information.
        """
        return ''

    def stringListAttribValue(self, name_or_attrib):
        """
        stringListAttribValue(self, name_or_attrib) -> tuple of str

        Return the primitive attribute value for a particular string attribute.
        The attribute may be specified by name or by hou.Attrib object.  The
        return value is a tuple of strings.

        It is valid to call this method when the attribute's size is 1.  In this
        case, a tuple with one element is returned.

        See also hou.Prim.attribValue.
        """
        return ('',)

    def setAttribValue(self, name_or_attrib, attrib_value):
        """
        setAttribValue(self, name_or_attrib, attrib_value)

        Store an attribute value in this primitive.  The attribute may be
        specified by name or by hou.Attrib object, and must be an existing
        primitive attribute in the geometry.  You would typically call this
        method from the code of a Python-defined SOP.

        Raises hou.OperationFailed if no attribute exists with this name or if
        the attribute's data type does not match the value passed in.  If the
        attribute's size is more than 1, the attribute value must be a sequence
        of integers/floats, and the size of the sequence must match the
        attribute's size.

        Raises hou.GeometryPermissionError if this geometry is not modifiable.

          # Create a float primitive attribute of size 3 named "Cd", and assign
          # each primitive a unique color.  This code will work from inside a Python
          # SOP, but not from the Python shell.
          geo = hou.pwd().geometry()
          color_attrib = geo.addAttrib(hou.attribType.Prim, "Cd", (1.0, 1.0, 1.0))
          num_prims = len(geo.prims())
          color = hou.Color()
          for prim in geo.prims():
              fraction = float(prim.number()) / num_prims
              # Give each primitive a different hue, but full saturation and value.
              # Store the RGB value in the attribute.
              color.setHSV((fraction * 255, 1, 1))
              prim.setAttribValue(color_attrib, color.rgb())
        """


    def intrinsicNames(self):
        """
        intrinsicNames(self) -> tuple of str
        """
        return ('',)

    def intrinsicValue(self, intrinsic_name):
        """
        intrinsicValue(self, intrinsic_name) -> int, float, str, or tuple
        """

    def intrinsicSize(self, intrinsic_name):
        """
        intrinsicSize(self, intrinsic_name) -> int

        Returns the intrinsic value tuple size.        """
        return 0

    def intrinsicReadOnly(self, intrinsic_name):
        """
        intrinsicReadOnly(self, intrinsic_name) -> bool

        Returns whether the intrinsic is read-only or can be modified with
        setIntrinsicValue()        """
        return True

    def setIntrinsicValue(self, intrinsic_name, value):
        """
        setIntrinsicValue(self, intrinsic_name, value)        """

    def attribValue(self, name_or_attrib):
        """
        attribValue(self, name_or_attrib) -> int, float, str or tuple

        Return the value stored in this primitive for a particular attribute.
        The attribute may be specified by name or by hou.Attrib object.

        Looking an attribute value using a hou.Attrib object is slightly faster
        than looking it up by name.  When looking up attribute values inside a
        loop, look up the hou.Attrib object outside the loop, and pass it into
        this method.

        When looking up the attribute values of all primitives, it is faster to
        call hou.Geometry.primFloatAttribValues or
        hou.Geometry.primFloatAttribValuesAsString than to call this method for
        each primitive in the geometry.

        Raises hou.OperationFailed if no attribute exists with this name.

        REPLACES
            prim function
            prims function        """

    def positionAtInterior(self, u, v, w=0.0):
        """
        positionAtInterior(self, u, v, w=0.0) -> hou.Vector3

        Given normalized (i.e. from 0 to 1) u, v, w values, return the interior
        position of the primitive at that parametric location.

        Use hou.Face.positionAt for querying positions along the perimeter.

        REPLACES
            primuv function        """
        return Vector3()

    def attribValueAtInterior(self, attrib_or_name, u, v, w=0.0):
        """
        attribValueAtInterior(self, attrib_or_name, u, v, w=0.0) -> int, float,
        str or tuple

        Return an attribute value at the normalized u, v, w parametric position
        in the interior of the primitive.

        Raises hou.OperationFailed if the attribute is not a point or vertex
        attribute.  If you want a primitive attribute value, it doesn't vary
        across the surface, so use hou.Prim.attribValue.

        Use hou.Face.attribValueAt for querying attributes along the perimeter.

        REPLACES
            primuv function        """

    def nearestToPosition(self, pos3):
        """
        nearestToPosition(self, pos3)

        Given a sequence of three floats containing a position, find the
        location on this primitive that is closest to that position.  Returns a
        tuple containing the u value on this primitive, the v value on this
        primitive, and the distance to this primitive.

        REPLACES
            xyzdist function        """

    def groups(self):
        """
        groups(self) -> tuple of hou.PrimGroup

        Return a tuple of the primitive groups that contain this primitive.
        """
        return (PrimGroup(),)

class Face(Prim):
    """
    hou.Face

    A Face is a kind of geometry primitive (Prim object) that contains a
    sequence of vertices (Vertex objects).  How these vertices are used
    depends on the type of face; polygons, for example, use the vertices to
    define the edges of the polygon, while NURBS curves use them as control
    points.

    A hou.Surface, on the other hand, stores a two dimension grid of
    vertices, and might be a NURBS surface, Bezier surface, or quadrilateral
    mesh.

    """

    def __init__(self): raise AttributeError, "No constructor defined"

    def isClosed(self):
        """
        isClosed(self) -> bool

        Return whether the first and last vertex are connected.

        An open face forms a multi-segment line or curve, since the first and
        last vertices are not connected.  A closed face forms a very thin
        surface.

        REPLACES
            isclosed function        """
        return True

    def closed(self): return
    def setIsClosed(self, on):
        """
        setIsClosed(self, on)

        Set whether the face is open or closed.  See hou.Face.isClosed for more
        information.  You would typically call this method from the code of a
        Python-defined SOP.

        Note that this method will raise hou.OperationFailed on a Bezier curve.
        See hou.Geometry.createBezierCurve for more information.

        Raises hou.GeometryPermissionError if this geometry is not modifiable.
        """

    def normal(self):
        """
        normal(self) -> hou.Vector3

        Return the vector that's perpendicular to the face.
        """
        return Vector3()

    def positionAt(self, u):
        """
        positionAt(self, u) -> hou.Vector3

        Given a normalized (i.e. from 0 to 1) u value, return the position of
        the curve at that parametric location.

        REPLACES
            primuv function        """
        return Vector3()

    def attribValueAt(self, attrib_or_name, u, du=0):
        """
        attribValueAt(self, attrib_or_name, u, du=0) -> int, float, str or tuple

        Return an attribute value at a normalized u parametric position on the
        curve.  If du is 0, returns the interpolated attribute value; otherwise,
        returns the derivative of the attribute value.

        Raises hou.OperationFailed if the attribute is not a point or vertex
        attribute.  If you want a primitive attribute value, it doesn't vary
        across the surface, so use hou.Prim.attribValue.

        REPLACES
            primuv function        """

    def vertex(self, index):
        """
        vertex(self, index) -> hou.Vertex

        A shortcut for self.vertices()[index].  You probably don't need to call
        this method.

        This method supports negative indices to index from the end, just like
        self.vertices()[index] would.  Also, like Python's indexing operator, it
        will raise IndexError when the index is out of range.        """
        return Vertex()

    def addVertex(self, point):
        """
        addVertex(self, point) -> hou.Vertex

        Create a new vertex inside this face, adding it to the end of the vertex
        list.  You would typically call this method from the code of a Python-
        defined SOP.

        point is a hou.Point object that the new vertex will refer to.  See
        hou.Vertex for information on the relationship between points and
        vertices.

        Raises hou.GeometryPermissionError if this geometry is not modifiable.

          # These arrays define point positions and a set of polygons composed
          # of those points.  Note that the point positions could also be floating
          # point values.
          point_positions = ((0,0,0), (1,0,0), (1,1,0), (0,1,0))
          poly_point_indices = ((0,1,2), (2,3,0))

          geo = hou.pwd().geometry()

          # Create all the points.
          points = []
          for position in point_positions:
              points.append(geo.createPoint())
              points[-1].setPosition(position)

          # Now create the polygons, adding vertices that refer to the points.
          for point_indices in poly_point_indices:
              poly = geo.createPolygon()
              for point_index in point_indices:
                  poly.addVertex(points[point_index])

        See also:

        * hou.Geometry.createPoint
        * hou.Geometry.createPolygon        """
        return Vertex()

class BaseKeyframe(object):
    """
    hou.BaseKeyframe

    Abstract base class for all keyframe class.

    REPLACES
      * chkey
      * chkeyls
      * chkey
      * chround
      * chsraw
      * lock
      * opscript
    """

    def __init__(self): raise AttributeError, "No constructor defined"

    def evaluatedType(self):
        """
        evaluatedType(self) -> hou.parmData enum value

        Returns the type that the keyframe evaluates to.
        """
        return parmData()

    def setExpression(self, expression, language=None):
        """
        setExpression(self, expression, language=None)

        Sets the keyframe's expression and language.

        This function raises hou.TypeError if language is not a value from
        hou.exprLanguage.

        See expression(), expressionLanguage(), isExpressionSet(),
        isExpressionLanguageSet().
        """

    def expression(self):
        """
        expression(self) -> str

        Returns the keyframe's expression. For example, in cases where the
        keyframe has had two values set the interpolating function is returned
        e.g. "bezier()", "spline()" etc.

        This function raises hou.KeyframeValueNotSet if an expression has not
        been set.

        See setExpression() and isExpressionSet().
        """
        return ''

    def isExpressionSet(self):
        """
        isExpressionSet(self) -> bool

        Returns whether the keyframe's expression is set.

        See setExpression() and expression().        """
        return True

    def expressionLanguage(self):
        """
        expressionLanguage(self) -> hou.exprLanguage enum value

        Returns the keyframe's expression's language.

        This function raises hou.KeyframeValueNotSet if an expression language
        has not ben set.

        See setExpression(), and isExpressionLanguageSet().        """
        return exprLanguage()

    def isExpressionLanguageSet(self):
        """
        isExpressionLanguageSet(self) -> bool

        Returns whether the keyframe expression's language is set.

        See setExpression() and expressionLanguage().
        """
        return True

    def setTime(self, time):
        """
        setTime(self, time)

        Sets the keyframe's time in seconds.  Using the number of frames per
        second (hou.fps), setting the time also sets the frame number.  For
        example, with an fps of 24, then setting the time to 2 seconds will set
        the frame number to 49.
        See time().        """

    def isTimeSet(self):
        """
        isTimeSet(self) -> bool

        Returns whether the keyframe's time is set.

        See setTime() and time().
        """
        return True

    def time(self):
        """
        time(self) -> double

        Returns the keyframe's time in seconds.

        This function raises hou.KeyframeValueNotSet if the time or frame has
        not been set.

        See setTime() and setFrame().
        """
        return 0.0

    def setFrame(self, frame):
        """
        setFrame(self, frame)

        Sets the keyframe's frame number.  Using the number of frames per second
        (hou.fps), setting the frame number also sets the time.  For example,
        with an fps of 24, then setting the frame number to 49 will set the time
        to 2 seconds.

        See frame().
        """


    def frame(self):
        """
        frame(self) -> double

        Returns the keyframe's frame number.

        This function raises hou.KeyframeValueNotSet if the frame or time has
        not been set.

        See setFrame() and setTime().
        """
        return 0.0

    def asCode(self, brief=False, save_keys_in_frames=False, function_name=None):
        """
        asCode(self, brief=False, save_keys_in_frames=False, function_name=None)
        -> str

        Returns a script of Python statements that can be executed to create the
        keyframe.  To run the script, use either Python's exec  or execfile
        functions.

        brief
            When <brief> is True, the output script omits commands for  setting
            unused values, slopes and accelerations.  This parameter  only
            applies to non-string keyframes.  The value of <brief> must be
            either True or False.

        save_keys_in_frames
            When <save_keys_in_frames> is True, asCode outputs commands for
            setting channel and key times in samples (frames) instead  of
            seconds.  The value of <save_keys_in_frames> must be either True or
            False.

        function_name
            If <function_name> is specified, then the output script  is wrapped
            in a Python function definition with the given name. <function_name>
            must be a non-zero length string consisting of  only alphanumeric
            and underscore characters.  Any invalid characters  are internally
            converted to underscores.

            The function returns a reference to the newly created keyframe
            object.

        Here is an example of saving the output to a file and then loading  it
        back into Houdini:
          # Get a reference to the target keyframe.
          tx_parm = hou.parm("/obj/geo1/tx")
          key = tx_parm.keyframes()[0]

          # Execute asCode and write the output script to file.
          script = key.asCode()
          f = open("create_key.py", "w")
          f.write(script)
          f.close()

          # Execute the script.  The new keyframe will be stored
          # in the 'hou_keyframe' variable.
          execfile("create_key.py")

          # Commit the keyframe back into the node parameter.
          tx_parm.setKeyframe(hou_keyframe)


        Here is an example of saving the output into a function and then
        calling it in Houdini:
          # Get a reference to the target keyframe.
          tx_parm = hou.Node("/obj/geo1").Parm("tx")
          key = tx_parm.keyframes()[0]

          # Execute asCode and write the function definition to file.
          func = key.asCode(function_name="createKeyframe")
          f = open("keylib.py", "w")
          f.write(func)
          f.close()

          # Call the function definition.
          import keylib
          hou_keyframe = keylib.createKeyframe()

          # Commit the keyframe back into the node parameter.
          tx_parm.setKeyframe(hou_keyframe)
        """
        return ''

class NodeType(object):
    """
    hou.NodeType

    A NodeType specifies the information common to all instances of a type
    of node, such as the parameter set, algorithm, minimum number of inputs,
    etc. For example, the geometry object and subdivide SOP are node types.
    /obj/geo1 and /obj/geo2, on the other hand, are Nodes that are instances
    of the geometry object node type.

    Note that a digital asset defines a node type.  The nodes contained
    inside the asset's definition implement the node type's algorithm, and
    you can customize the parameters in the node type using the Type
    Properties dialog,

    You can get a NodeType object from a Node object with hou.Node.type. For
    example, if /obj/geo1 is a geometry object,
    hou.node("/obj/geo1").type() will return the NodeType corresponding to
    all geometry objects.

    All the node types in Houdini are organized into categories, and a node
    type is uniquely identified by its category and node type name.  For
    example, objects, SOPs, POPs, etc. are node type categories.  You can
    also access a NodeType object from a category with
    hou.NodeTypeCategory.nodeTypes.  Similarly, you can call hou.nodeType_
    with the category and node type name.

    See also hou.Node and hou.NodeTypeCategory.


    """

    def __init__(self): raise AttributeError, "No constructor defined"

    def category(self):
        """
        category(self) -> hou.NodeTypeCategory

        Return the node type category for this node type.  For example, for the
        geometry object, the result is the object returned by
        hou.objNodeTypeCategory.

        REPLACES
            optypeinfo function        """
        return NodeTypeCategory()

    def name(self):
        """
        name(self) -> str

        Return the name of this node type.  For example, for the geometry object
        type, the name is "geo".  The name and the node type category together
        uniquely identify a node type.

        REPLACES
            optype command
            optypeinfo function        """
        return ''

    def nameComponents(self):
        """
        nameComponents(self) -> tuple of str

        Returns a tuple of node type name components that constitute the full
        node type name. The components in the tuple appear in the following
        order: scope network type, node type namespace, node type core name, and
        version.

          # parse the full name into components
          >>> node_type = hou.nodeType(hou.dopNodeTypeCategory(), 'pyrosolver::2.0')
          >>> node_type.nameComponents()
          ('', '', 'pyrosolver', '2.0')
        """
        return ('',)

    def description(self):
        """
        description(self) -> str

        Return the description of this node type that appears in the tab menu.
        For example, for the geometry object, the description is "Geometry".
        This description is also called the operator label in Houdini.

        REPLACES
            optype command
            optypeinfo function        """
        return ''

    def nameWithCategory(self):
        """
        nameWithCategory(self) -> str

        Return the name of the node type, prefixed with the name of the node
        type category. For example, for the geometry object, this function
        returns "Object/geo".  The category name and type name together
        uniquely identify a node type.

          >>> hou.nodeType(hou.objNodeTypeCategory(), "geo").nameWithCategory()
          'Object/geo'
        """
        return ''

    def namespaceOrder(self):
        """
        namespaceOrder(self) -> tuple of str

        Returns a node type name list sorted in the descending namespace
        precedence  order. The node types in the list have the same base type as
        this node type. They have different namespace and/or version.

        Houdini uses this list when resolving an unqualified type name in
        hou.Node.createNode(); it will use the first entry in that list that
        matches the name specified in the function.

          # parse the full name into components
          >>> node_type = hou.nodeType(hou.dopNodeTypeCategory(), 'pyrosolver')
          >>> node_type.namespaceOrder()
          ('pyrosolver::2.0', 'pyrosolver')
        """
        return ('',)

    def source(self):
        """
        source(self) -> hou.nodeTypeSource enum value

        Return a hou.nodeTypeSource enumerated value to indicate if this node
        type is implemented in VEX, RSL, or the HDK (in C++), or if it is a
        built-in node type that ships with Houdini.

          >>> obj_cat = hou.objNodeTypeCategory()
          >>> sop_cat = hou.sopNodeTypeCategory()
          >>> hou.nodeType(obj_cat, "biped_auto_rig").source()
          nodeTypeSource.Subnet
          >>> hou.nodeType(sop_cat, "mountain").source()
          nodeTypeSource.VexCode

        REPLACES
            dsoinfo command        """
        return nodeTypeSource()

    def sourcePath(self):
        """
        sourcePath(self) -> str

        Return the path to the source for this node type, or "Internal" if it
        is a built-in node type.  If the node was created using the HDK, return
        the path to the shared object/dll for the node type.

          >>> obj_cat = hou.objNodeTypeCategory()
          >>> hou.nodeType(obj_cat, "biped_auto_rig").sourcePath()
          'oplib:/Object/biped_auto_rig?Object/biped_auto_rig'
          >>> hou.nodeType(obj_cat, "geo").sourcePath()
          'Internal'

        REPLACES
            dsoinfo command        """
        return ''

    def sourceNetwork(self):
        """
        sourceNetwork(self) -> hou.Node or None

        If this node type is a digital asset, return the Node instance whose
        contents define the digital asset.  Otherwise, return None.
        """
        return Node()

    def definition(self):
        """
        definition(self) -> hou.HDADefinition

        If this node type corresponds to a digital asset, return the
        hou.HDADefinition.  Otherwise, return None.

        REPLACES
            otgetotl command        """
        return HDADefinition()

    def allInstalledDefinitions(self):
        """
        allInstalledDefinitions(self) -> tuple of hou.HDADefinition

        Search all installed operator type libraries and return a tuple of
        available hou.HDADefinition objects providing definitions for this node
        type.

        Houdini allows multiple otl files to be loaded at the same time that
        each contain definitions for the same node type.  The definition in use
        is called the current definition.  See also hou.HDADefinition.isCurrent.

        REPLACES
            otls command        """
        return HDADefinition()

    def icon(self):
        """
        icon(self) -> str

        Return the name or path of the icon for this node type.  Note that node
        types that ship with Houdini use a name instead of a full path, and
        Houdini uses its search path to locate the icon with that name.
        """
        return ''

    def minNumInputs(self):
        """
        minNumInputs(self) -> int

        Return the minimum number of inputs that nodes of this type can have.
        If these inputs are not connected, the node will generate an error.
        """
        return 0

    def maxNumInputs(self):
        """
        maxNumInputs(self) -> int

        Return the maximum number of inputs that nodes of this type can have.
        Return 9999 if this node type can accept an unlimited number of inputs
        (e.g. the merge SOP).
        """
        return 0

    def maxNumOutputs(self):
        """
        maxNumOutputs(self) -> int

        Return the maximum number of outputs that nodes of this type can have.
        Most node types have only one output, but some, like the split dop, can
        have multiple.
        """
        return 0

    def isGenerator(self):
        """
        isGenerator(self) -> bool

        Return if this node type has been flagged as a generator.  For example,
        a grid SOP generates new geometry, while a subdivide SOP does not, and
        instead processes the geometry passed into it.  See also
        hou.NodeType.minNumInputs.
        """
        return True

    def generatorFlag(self): return
    def isManager(self):
        """
        isManager(self) -> bool

        Return whether this NodeType is a manager.  The manager node instances
        are /obj, /out, /part, /ch, /shop, /img, and /vex, as well as manager
        nodes like SHOP networks.        """
        return True

    def managerFlag(self): return
    def hasUnorderedInputs(self):
        """
        hasUnorderedInputs(self) -> bool

        Return whether it is impossible for this node type to have gaps in its
        connected inputs.  For example, the cookie SOP has two inputs, and it's
        possible for only the second input to be connected, so this method would
        return False.  However, the merge SOP cannot have any gaps in its
        inputs, so this method would return True.

        See also hou.Node.inputs, hou.Node.inputConnections, and
        hou.Node.inputConnectors.        """
        return True

    def unorderedInputsFlag(self): return True
    def aliases(self):
        """
        aliases(self) -> tuple of str

        Return all current aliases for this node type.  See
        hou.NodeType.addAlias for an example.

        REPLACES
            opalias command        """
        return ('',)

    def addAlias(self, alias):
        """
        addAlias(self, alias)

        Add an alias for this node type.  You can use this alias when creating
        new nodes.

          >>> geo_type = hou.nodeType(hou.objNodeTypeCategory(), "geo")
          >>> geo_type.addAlias("transformable")
          >>> geo_type.aliases()
          ('transformable',)
          >>> hou.node("/obj").createNode("transformable")
          <hou.ObjNode of type geo at /obj/geo1>

        REPLACES
            opalias command        """
        pass

    def removeAlias(self, alias):
        """
        removeAlias(self, alias)

        Remove an alias for this node type.

        REPLACES
            opalias command        """
        pass

    def hidden(self):
        """
        hidden(self) -> bool

        Return whether or not this node type appears in the tab menu.  See also
        hou.NodeType.setHidden.        """
        return True

    def setHidden(self, hidden):
        """
        setHidden(self, hidden)

        Set whether or not this node type appears in the tab menu.  See also
        hou.NodeType.hidden.

        REPLACES
            opexclude command        """
        pass

    def instances(self):
        """
        instances(self) -> tuple of hou.Node

        Return a tuple of all the nodes of this type in the current scene.

        REPLACES
            opstat command
            otinuse command        """
        return (Node(),)

    def parmTemplates(self):
        """
        parmTemplates(self) -> tuple of hou.ParmTemplate

        Return a tuple of parm templates for the parameters on this node type.
        Note that spare parameters on individual node instances are not included
        in this tuple, since they are independent from the node type.
        """
        return (ParmTemplate(),)

    def parmTemplateGroup(self):
        """
        parmTemplateGroup(self) -> hou.ParmTemplateGroup

        Return the group of parm templates corresponding to this node type's
        parameter interface.

        See hou.ParmTemplateGroup for more information on parm template groups.
        To change the parameter interface for a node type defined by a digital
        asset, see hou.HDADefinition.setParmTemplateGroup.
        """
        return ParmTemplateGroup()

    def uninstallFromPath(self): return
    def hdaModule(self):
        """
        hdaModule(self) -> hou.HDAModule

        Return the HDAModule object for this node type.  If the type is not for
        a digital asset, the module is empty.  Otherwise, the module contains
        the functions, constants, classes, etc. in the user-defined
        "PythonModule" section of the digital asset.

        You can use hou.Node.hdaModule as a shortcut to access the HDAModule
        from a node instance.

        See hou.HDAModule for more information.
        """
        return HDAModule()

    def hasPermanentUserDefaults(self):
        """
        hasPermanentUserDefaults(self) -> bool

        Returns whether a user has set permanent defaults for this node type.

        See also hou.Parm.hasTemporaryDefaults        """
        return True

    def _asVoidPointer(self): return

class ParmTemplate(object):
    """
    hou.ParmTemplate

    Describes a parameter tuple (its name, type, etc.).  This is base class
    for all parameter templates.

    ParmTemplates are most often used when describing a parameter in a
    digital asset definition's parameter interface or when describing an
    individual node's parameter layout (including its spare parameters).  A
    ParmTemplate describes a parameter and the type of data it holds, but it
    does not store the current value of a parameter; only hou.Parm objects
    inside hou.ParmTuple objects actually store parameter values.  You can
    think of a hou.ParmTuple as an instance of a ParmTemplate.  For example,
    the "t" parm tuple on geometry objects can be described by a
    hou.FloatParmTemplate -- it has a label of "Transform", a data type of
    hou.parmData.Float, 3 components, a naming scheme of
    hou.parmNamingScheme.XYZW, etc.  Each geometry object node has a
    hou.ParmTuple named "t" that uses this ParmTemplate.

    Note that ParmTemplate objects are just data containers, and they have
    no live relationship with objects in Houdini.  For example, a hou.Node
    object corresponds directly to a node in Houdini, and if the node is
    renamed in Houdini hou.Node.name will return the new name.
    ParmTemplates, on the other hand, do not have a live relationship.
    Creating a ParmTemplate based on a spare parameter or asset definition
    parameter will simply copy the information into the ParmTemplate object,
    and modifying the object will not affect the spare parameter/asset
    parameter.

    Note also that ParmTemplate objects are always instances of a subclass
    of this class, so you cannot construct an instance of this class
    directly.

    To manipulate the parameters of a digital asset, you can retrieve the
    asset's current set of ParmTemplates into a hou.ParmTemplateGroup using
    hou.HDADefinition.parmTemplateGroup.  You can then modify the group,
    adding parameters to it and replacing parameters in it, and save the
    group back to the asset definition with
    hou.HDADefinition.setParmTemplateGroup. Similarly, you can change a
    node's parameter layout with hou.Node.parmTemplateGroup and
    hou.Node.setParmTemplateGroup.

    You can also ask a hou.ParmTuple for its ParmTemplate in order to find
    out information about the parameter, such as allowed ranges of values,
    the label displayed to the user in the parameter pane, the parameter's
    popup help, etc.


    """

    def __init__(self): raise AttributeError, "No constructor defined"

    def clone(self):
        """
        clone(self) -> hou.ParmTemplate

        Return a copy of this parm template.

        This method can be called on an instance of a ParmTemplate subclass and
        an instance of the subclass is properly returned.
        """
        return ParmTemplate()

    def name(self):
        """
        name(self) -> string

        Return the internal name of the parm template.  This is the name that
        hou.ParmTuple objects created from this parm template will have.

        Note that the names of hou.Parm objects inside ParmTuples based off this
        ParmTemplate are determined by this name, the number of components in
        this parm template, and the naming scheme.  See the namingScheme method
        for more information.
        """
        return ''

    def setName(self, name):
        """
        setName(self, name)

        Change the internal name of this parm template.  Remember that
        ParmTemplates just store data, so the name change will not have any
        effect unless this parm template is later used to modify a parameter
        layout in Houdini.
        """


    def label(self):
        """
        label(self) -> string

        Return the name of the parameter tuple that is displayed in the
        parameter pane.
        """
        return ''

    def setLabel(self, label):
        """
        setLabel(self, label)

        Change the name of the label that is displayed in the parameter pane.
        """


    def type(self):
        """
        type(self) -> hou.parmTemplateType enum value

        Return the enumerated value identifying the type of this parameter.

        Remember that ParmTemplate objects are always instances of a subclass of
        this class.  The following table shows the mapping between
        hou.parmTemplateType enumeration values and ParmTemplate subclasses:

        Enumerated Value
            ParmTemplate Subclass

        hou.parmTemplateType.Int
            hou.IntParmTemplate

        hou.parmTemplateType.Float
            hou.FloatParmTemplate

        hou.parmTemplateType.String
            hou.StringParmTemplate

        hou.parmTemplateType.Toggle
            hou.ToggleParmTemplate

        hou.parmTemplateType.Menu
            hou.MenuParmTemplate

        hou.parmTemplateType.Button
            hou.ButtonParmTemplate

        hou.parmTemplateType.FolderSet
            hou.FolderSetParmTemplate

        hou.parmTemplateType.Folder
            hou.FolderParmTemplate

        hou.parmTemplateType.Separator
            hou.SeparatorParmTemplate

        hou.parmTemplateType.Label
            hou.LabelParmTemplate

        hou.parmTemplateType.Ramp
            hou.RampParmTemplate
        """
        return parmTemplateType()

    def dataType(self):
        """
        dataType(self) -> hou.parmData enum value

        Return the data type stored in hou.Parm instances inside hou.ParmTuple
        instances corresponding to this ParmTemplate.

        For example, suppose this parm tuple is a hou.FloatParmTemplate with 3
        components.  The corresponding hou.ParmTuple will have 3 hou.Parm
        objects inside it, and each will store a floating point value.  In this
        example, this method would return hou.parmData.Float.
        """
        return parmData()

    def look(self):
        """
        look(self) -> hou.parmLook enum value

        Return the look of this parameter in the parameter pane.  For example, a
        tuple of 3 floats can be displayed as a 3D vector or as an RGB color.

        See hou.parmLook for more information.
        """
        return parmLook()

    def setLook(self, look):
        """
        setLook(self, look)

        Set the look of this parameter to a hou.parmLook enum value.

        See the look method for more information.
        """


    def namingScheme(self):
        """
        namingScheme(self) -> hou.parmNamingScheme enum value

        Return the naming scheme used to name parameters inside the parm tuple
        for this ParmTemplate.

        For example, if the naming scheme is hou.parmNamingScheme.XYZW and the
        parm template is named "foo" and has 3 components, the parameters will
        be named "foox", "fooy", and "fooz".  On the other hand, if the
        naming scheme was hou.parmNamingScheme.Base1, the parameters would be
        named "foo1", "foo2", and "foo3".

        Note that when the parm template only has 1 component, the parm name is
        the same as the parm tuple name.

        See hou.parmNamingScheme for more information.
        """
        return parmNamingScheme()

    def setNamingScheme(self, naming_scheme):
        """
        setNamingScheme(self, naming_scheme)

        Set the naming scheme used to name parameters inside the parm tuple for
        this ParmTemplate to a hou.parmNamingScheme enum value.

        See the namingScheme method for more information.
        """


    def numComponents(self):
        """
        numComponents(self) -> int

        Return the number of values stored inside hou.ParmTuple instances of
        this ParmTemplate.

        For example, if this parm template has 3 components, there will be 3
        parameter fields displayed in the parameter pane and there will be 3
        hou.Parm objects inside a hou.ParmTuple based off this parm template.
        """
        return 0

    def setNumComponents(self, num_components):
        """
        setNumComponents(self, num_components) -> int

        Set the number of values stored inside hou.ParmTuple instances of this
        ParmTemplate.

        Note that some ParmTemplate subclasses only support one component, so
        calling this method with a value other than 1 may raise a
        hou.OperationFailed exception.  Also, changing the number of components
        may automatically change the size of the tuple of default values for
        some ParmTemplate subclasses.
        """
        return 0

    def disableWhen(self):
        """
        disableWhen(self) -> str

        This method is deprecated in favor of the conditionals method.
        """
        return ''

    def setDisableWhen(self, disable_when):
        """
        setDisableWhen(self, disable_when)

        This method is deprecated in favor of the setConditional method.
        """

    def conditionals(self):
        """
        conditionals(self) -> dict of [Hom:hou.parmCondType] enum value to
        string

        Returns the set of conditionals currently affecting this parameter.

        See the Conditionals section of the <Operator Type Properties window>
        help for more information on this string.
        """
        return {'':parmCondType(),}

    def setConditional(self, type, conditional):
        """
        setConditional(self, type, conditional)

        Set a conditional string of the given hou.parmCondType type for this
        parameter. This string consists of rules on how this parameter's display
        behaves when other parameters change.

        See the Conditionals section of the <Operator Type Properties window>
        help for more information on this string.
        """


    def isHidden(self):
        """
        isHidden(self) -> bool

        Return whether this parameter is hidden in the parameter pane.
        """
        return True

    def hide(self, on):
        """
        hide(self, on)

        Marks this parameter as visible or invisible in the parameter pane.

        Note that hidden parameters still exist, and can be evaluated, channel-
        referenced, etc.  They simply will not be displayed in the parameter
        pane.
        """

    def isLabelHidden(self):
        """
        isLabelHidden(self) -> bool

        Return whether the label for this parameter is hidden in the parameter
        pane.
        """
        return True

    def hideLabel(self, on):
        """
        hideLabel(self, on)

        Hide or show the label for this parameter in the parameter pane.
        """


    def joinsWithNext(self):
        """
        joinsWithNext(self) -> bool

        Return whether this parameter is displayed on the same line as the next
        parameter in the parameter pane.
        """
        return True

    def setJoinWithNext(self, on):
        """
        setJoinWithNext(self, on)

        Sets whether this parameter is displayed on the same line as the next
        parameter in the parameter pane.
        """

    def joinWithNext(self):
        """
        joinWithNext(self) -> bool

        This method is deprecated in favor of the joinsWithNext method.
        """
        return True

    def help(self):
        """
        help(self) -> str

        Return the help that Houdini displays when you hover over the parameter
        label in the parameter pane.
        """
        return ''

    def setHelp(self, help):
        """
        setHelp(self, help)

        Set the help that Houdini displays when you hover over the parameter
        label in the parameter pane.
        """

    def scriptCallback(self):
        """
        scriptCallback(self) -> str

        Return the contents of the script that Houdini runs when this parameter
        changes.  This script is most commonly used in hou.ButtonParmTemplate
        objects to respond to the button being pressed.

        Note that Houdini uses the tags dictionary to store the script callback
        information.
        """
        return ''

    def setScriptCallback(self, script_callback):
        """
        setScriptCallback(self, script_callback)

        Set the callback script to the given string.  This script runs in
        response to a parameter change.

        See the scriptCallback method for more information.
        """


    def scriptCallbackLanguage(self):
        """
        scriptCallbackLanguage(self) -> hou.scriptLanguage enum value

        Return the language of the script that Houdini runs when this parameter
        changes.

        Note that Houdini uses the tags dictionary to store the script callback
        information.

        See also the scriptCallback method.
        """
        return scriptLanguage()

    def setScriptCallbackLanguage(self, script_callback_language):
        """
        setScriptCallbackLanguage(self, script_callback_language)

        Set the script callback language to a hou.scriptLanguage enum value.

        See the scriptCallbackLanguage method for more information.
        """

    def tags(self):
        """
        tags(self) -> dict of string to string

        Return a dictionary of extra data stored in the parm template.

        Houdini uses this dictionary to attach arbitrary data to parm templates.
        The keys in this dictionary vary depending on the ParmTemplate type and
        its use.
        """
        return {'':'',}

    def setTags(self, tags):
        """
        setTags(self, tags)

        Set the dictionary of extra data stored in this parm template.

        See the tags method for more information.
        """

    def asCode(self, function_name=None, variable_name=None):
        """
        asCode(self, function_name=None, variable_name=None) -> str

        Return a string containing Python statements that can be executed to
        recreate the parameter template.  To run the string, use Python's
        compile, or execfile functions or the exec statement.

        function_name
            If <function_name> is specified, then the code returned creates a
            Python function with the given name.  <function_name> must be a non-
            zero length string consisting of only alphanumeric and underscore
            characters.  Any invalid characters are internally converted to
            underscores.

            The function returns a reference to the newly created parameter
            template object.

        variable_name
            The name of a Python variable that the result code will assign to.
            If None, Houdini uses the variable name "hou_parm_template".

        Here is an example of saving the output to a file and then loading  it
        back into Houdini:

          # Get a reference to the target parameter template.
          node = hou.node("/obj/geo1")
          parm_template = node.parm("tx").parmTemplate()

          # Execute asCode and write the output script to a file.
          code = parm_template.asCode()
          source_file = open("create_parm_template.py", "w")
          source_file.write(code)
          source_file.close()

          # Execute the script.  The new parameter template will be stored
          # in the 'hou_parm_template' variable.
          execfile("create_parm_template.py")

          # Add a spare parameter to the node using the saved parameter
          # template.
          node.addSpareParmTuple(hou_parm_template)

        Here is an example of saving the output into a function in a file and
        then calling it from Houdini:

          # Get a reference to the target parameter template.
          node = hou.node("/obj/geo1")
          parm_template = node.parm("tx").parmTemplate()

          # Execute asCode and write the function definition to a file.
          code = parm_template.asCode(function_name="createParmTemplate")
          source_file = open("parmtemplatelib.py", "w")
          source_file.write(code)
          source_file.close()

          # Call the function definition.
          import parmtemplatelib
          hou_parm_template = parmtemplatelib.createParmTemplate()

          # Add a spare parameter to the node using the saved parameter
          # template.
          node.addSpareParmTuple(hou_parm_template)
        """
        return ''

class ParmTemplateGroup(object):
    """
    hou.ParmTemplateGroup

    A group of parameter templates used to represent the parameter layout of
    a node or the parameters in a digital asset definition.

    This class stores a group of hou.ParmTemplate objects.  You can create
    an empty group, create a group from a sequence of parm templates, or
    create a group from the parameter definitions of a digital asset or from
    a particular node's current parameter layout.  Similarly, you can set an
    asset's parameters or a node's parameter interface to the contents of a
    parameter group.

    You can get an asset's parm templates with
    hou.HDADefinition.parmTemplateGroup and set them with
    hou.HDADefinition.setParmTemplateGroup.  Similarly, you can get an
    individual node's parameter definition with hou.Node.parmTemplateGroup
    and set it with hou.Node.setParmTemplateGroup.  When setting a node's
    parameter interface, any parms that are not in the node's type's set of
    parms will be added as spare parameters.  Similarly, if parameters in
    the node's type are not present in the group, they will be automatically
    added at the end and made invisible.  Also, if they exist but the types,
    labels, looks, naming schemes, etc are different, Houdini will discard
    all changes you attempt to make to these reserved parameters except for
    visibility settings.

    Note that ParmTemplateGroups store their own copy of the parm templates.
    Asking for the parm templates in a group will return a copy of the parm
    templates; modifying those copies will not change the contents of the
    group. For example, to change a parameter in a group you cannot simply
    call find and modify the hou.ParmTemplate it returned.  Instead, you
    must call replace.

    It is important to understand the difference between folder parm
    templates and folder set parm templates when using ParmTemplateGroups.
    Folder sets correspond directly to hou.ParmTuple objects -- there is one
    parm tuple (that contains one parm) for each set of folders, and
    changing the value of that parm changes which folder is displayed.
    Individual Folders, on the other hand, do not directly correspond to
    hou.ParmTuple objects, but they are used in Houdini's <Type Properties>
    dialog and they make it easy to add individual folders and control which
    parameters are inside a folder. Unlike a hou.FolderSetParmTemplate, a
    hou.FolderParmTemplate stores the set of parm templates inside that
    folder.  When a node or definition's parameters are set to the contents
    of a parm template group, the folder sets are determined and the parm
    tuple name for the set is the name of the first folder in that set.  The
    names of the other folders in the set are not used.

    ParmTemplateGroups use folder parm templates instead of folder set parm
    templates.  Attempting to add a FolderSetParmTemplate to a group will
    raise hou.OperationFailed.  Asking a parm tuple for its parm template,
    on the other hand, may return a folder set but will never return a
    folder. Previously, folder parameter templates and parm template groups
    did not exist, so the only way to add folders were with special methods
    like hou.HDADefinition.addParmFolder and hou.Node.addSpareParmFolder.
    Now that that they exist, you may create folders by passing folder parm
    templates to hou.HDADefinition.addParmTuple and
    hou.Node.addSpareParmTuple.  However, using parm template groups is
    preferred over calling these methods.

    Note that folder parm templates are also used to represent multiparm
    blocks, much like the <Type Properties> dialog does.  The folder parm
    template's hou.folderType determines whether it is a folder or a
    multiparm block.   Unlike folder parm templates, which do not correspond
    directly to parameter instances, a multiparm parm template does
    correspond to an integer parameter that controls the number of instances
    of the multiparm.


    """

    def __init__(self, parm_templates=()):
        """
        __init__(self, parm_templates=())

        Create a new group from an optional sequence of parm templates.  If none
        are passed in, the new group will be empty.

        Because groups and folder parm templates can both be constructed using a
        sequence of contained parm templates, it is possible to construct a parm
        template group with parameters inside folders using a single expression.
        The following example creates a group with two folders and with
        parameters inside each of those folders:

          >>> group = hou.ParmTemplateGroup((
              hou.FolderParmTemplate("folder", "Physical", (
                  hou.FloatParmTemplate("mass", "Mass", 1),
                  hou.FloatParmTemplate("density", "Density", 1),
              )),
              hou.FolderParmTemplate("folder", "Divisions", (
                  hou.FloatParmTemplate("divisions", "Divisions", 3),
                  hou.ToggleParmTemplate("laser", "Laser Scan", default_value=True),
              )),
          ))
          >>> group.entries()
          (<hou.FolderParmTemplate name='folder' label='Physical' folder_style=Tabs>,
          <hou.FolderParmTemplate name= 'folder' label='Divisions' folder_style=Tabs>)
          >>> group.entries()[0].parmTemplates()[0]
          <hou.FloatParmTemplate name='mass' label='Mass' length=1 naming_scheme=XYZW look=Regular default_value=(0,)>
          >>> group.entriesWithoutFolders()
          (<hou.FloatParmTemplate name='mass' label='Mass' length=1 naming_scheme=XYZW look=Regular default_value=(0,)>,
           <hou.FloatParmTemplate name='density' label='Density' length=1 naming_scheme=XYZW look=Regular default_value=(0,)>,
            <hou.FloatParmTemplate name='divisions' label='Divisions' length=3 naming_scheme=XYZW look=Regular default_value=(0,0,0)>,
             <hou.ToggleParmTemplate name='laser' label='Laser Scan' default_value=True>)

        Raises hou.OperationFailed if any of the parm templates in the sequence
        are hou.FolderSetParmTemplate objects.
        """
    def find(self, name):
        """
        find(self, name) -> hou.ParmTemplate or None

        Search in this group for a parm template whose name matches the
        specified one.  Return a copy of the parm template or None if no match
        was found.

        Note that this function returns a copy of the parm template stored in
        this group.  Modifying the copy will not affect the parameters in this
        group. The following example shows how to use the find and replace
        methods to modify the "pos" parm template in the group:
          >>> parm_template = group.find("pos")
          >>> parm_template.setLabel("Position")
          >>> parm_template.replace("pos", parm_template)


        If you created the group from existing parameters, folder parm templates
        in the same folder set will share the same name, so searching for a
        folder using this method may return the first folder in the folder set.
        To instead search for a folder by its folder label, use findFolder.

        Note that, in general, the group does not prevent you from adding two
        parameters with the same name.  In this case, searching for a parameter
        with this name will return the first one.  Note, though, that when when
        setting this group to a node or asset definition's parms, either the
        duplicate parameters will be renamed on an exception will be raised. See
        the rename_conflicting_parms parameter to
        hou.HDADefinition.setParmTemplateGroup for more information.
        """
        return ParmTemplate()

    def findIndices(self, name_or_parm_template):
        """
        findIndices(self, name_or_parm_template) -> tuple of int

        Search in this group for a parm template and return a tuple of integers
        corresponding to the indices of the parm in the group.  Return an empty
        tuple if no match was found.

        name_or_parm_template
            Either the name of the parm template or another hou.ParmTemplate
            object to compare against when searching for a match.

        If the parm template was found and it is not inside any folders, the
        result tuple will contain a single integer with the index of the parm
        template.  Otherwise, the first entry will be the index of a folder
        inside the group, the next will be an index of a folder inside that
        folder, and so on until the last index is an index of a parm template
        inside a folder.

        See also findIndicesForFolder.
        """
        return (0,)

    def findFolder(self, label_or_labels):
        """
        findFolder(self, label_or_labels) -> hou.FolderParmTemplate or None

        Search in this group for a folder parm template with the given label.
        Return a copy of the hou.FolderParmTemplate or None if the folder wasn't
        found.

        label_or_labels
            Either a string containing the folder's label or a tuple of strings
            containing the labels of containing folders as well as the folder's
            label.

        Note that a folder parm template's label is what appears in the
        interface in the parameter dialog.  The folder parm template's name is
        used to determine the name of the parm tuple for the folder set, if the
        folder is the first in the folder set.  See the documentation for this
        class for more information.
        """
        return FolderParmTemplate()

    def findIndicesForFolder(self, label_or_labels):
        """
        findIndicesForFolder(self, label_or_labels) -> tuple of int

        Search in this group for a folder parm template with the given label.
        Return an empty tuple if no match was found.

        See findFolder for a description of the parameter and findIndices for a
        description of the return value.

        Note that this method does not accept a parm template.  However, if you
        have a folder parm template and want to find its indices, simply call
        findIndices on the folder parm template.
        """
        return (0,)

    def entryAtIndices(self, indices):
        """
        entryAtIndices(self, indices) -> hou.ParmTemplate

        Given a sequence of integer indices return a copy of the
        hou.ParmTemplate object at that location.  The indices are of the format
        returned by findIndices.

        Like the hou.ParmTemplate.find and hou.ParmTemplate.entries methods,
        this method returns a copy of the parm template stored inside this
        group.  Modifying the copied parm template will not affect the contents
        of this group.  Use replace to change a parm template.

        Raises hou.OperationFailed if the indices are invalid, including when
        the indices sequence is empty.

        This method could be implemented as follows:
          def entryAtIndices(self, indices):
              if len(indices) == 0:
                  raise hou.OperationFailed("Invalid indices")
              parm_template = self.entries()[indices[0]]

              # If there are multiple indices then we should have just looked up
              # a folder parm template.
              for index in indices[1:]:
                  parm_template = parm_template.parmTemplates()[index]
              return parm_template        """
        return ParmTemplate(self)

    def containingFolderIndices(self, name_or_parm_template_or_indices):
        """
        containingFolderIndices(self, name_or_parm_template_or_indices) -> tuple
        of int

        Return the indices of the folder in this group containing a given parm
        template.  Return an empty tuple if no match was found.

        See replace for a description of the parameter and findIndices for a
        description of the return value.

        Raises hou.OperationFailed if the parameter is not inside the group or
        is not inside a folder.
        """
        return (0,)

    def containingFolder(self, name_or_parm_template):
        """
        containingFolder(self, name_or_parm_template) -> hou.FolderParmTemplate

        Return a copy of the hou.FolderParmTemplate in this group containing a
        parm template.

        name_or_parm_template
            Either the name of the parm template or another hou.ParmTemplate
            object to compare against when searching for a match.

        Raises hou.OperationFailed if the parameter is not inside the group or
        is not inside a folder.
        """
        return FolderParmTemplate()

    def entries(self):
        """
        entries(self) -> tuple of hou.ParmTemplate

        Return a tuple containing copies of the parm templates inside this
        group.

        Note that folders are returned as hou.FolderParmTemplate objects, and
        each folder parm template contains the parm templates inside it. Use
        hou.FolderParmTemplate.parmTemplates to access the elements in a folder.

        The following example creates a function named allParmTemplates that
        returns a single sequence of parm templates, including folders, for all
        parm templates in the group:
          def allParmTemplates(group_or_folder):
              for parm_template in group_or_folder.parmTemplates():
                  yield parm_template

                  # Note that we don't want to return parm templates inside multiparm
                  # blocks, so we verify that the folder parm template is actually
                  # for a folder.
                  if (parm_template.type() == hou.parmTemplateType.Folder and
                          parm_template.isActualFolder()):
                      for sub_parm_template in allParmTemplates(parm_template):
                          yield sub_parm_template


        See also the parmTemplates method.
        """
        return (ParmTemplate(),)

    def parmTemplates(self):
        """
        parmTemplates(self) -> tuple of hou.ParmTemplate

        This method is simply an alias for the entries method.

        It makes it easier to search down through a parm template group for
        items nested in folders, since the hou.FolderParmTemplate class also has
        a method named parmTemplates.  The following example shows how to look
        up the labels for a folder parameter given its indices:
          def folderLabels(parm_template_group, indices):
              container = parm_template_group
              result = []
              for index in indices:
                  container = container.parmTemplates()[index]
                  result.append(container.label())
              return result        """
        return (ParmTemplate(),)

    def entriesWithoutFolders(self):
        """
        entriesWithoutFolders(self) -> tuple of hou.ParmTemplate

        Return a tuple containing all the non-folder parm templates inside this
        group.  The output is the flattened set of parm templates in the group,
        and includes the non-folder parms inside folders.

        Like entries, this method returns a copy of the parm templates inside
        this group.

        Note that this function does not return parm templates for entries
        inside multiparm blocks.

        Also see the entries method for the example function allParmTemplates.
        """
        return (ParmTemplate(),)

    def replace(self, name_or_parm_template_or_indices, parm_template):
        """
        replace(self, name_or_parm_template_or_indices, parm_template)

        Replace a parm template inside this group with another parm template.

        name_or_parm_template_or_indices
            Either the name of the parm template being replaced, a copy of the
            parm template, or a tuple of integer indices that identify the parm
            template and any containing folders.

        This method changes the contents of this group.  Note that it stores a
        copy of the parm template in the group, so future changes to the parm
        template passed in will not affect the group.

        See the find method for a simple example of how to use this method.

        Note that parm templates for reserved parameters (for example, the
        transform parameters in object-level digital assets) can be replaced in
        the parm template group, but all aspects of reserved parameters except
        for their visibility and join settings will be restored to their
        defaults when you save this group to a node or asset definition.

        Raises hou.OperationFailed if the parm template doesn't exist.
        """

    def insertBefore(self, name_or_parm_template_or_indices, parm_template):
        """
        insertBefore(self, name_or_parm_template_or_indices, parm_template)

        Insert a parm template inside this group before an existing one.  The
        new parm template will be in the same folder as the existing one.

        See replace for a description of the name/parm template/indices
        parameter.

        Use appendToFolder to add an entry to a empty folder.  Use append to add
        an entry to an empty parm template group.
        """

    def insertAfter(self, name_or_parm_template_or_indices, parm_template):
        """
        insertAfter(self, name_or_parm_template_or_indices, parm_template)

        Insert a parm template inside this group after an existing one.  The new
        parm template will be in the same folder as the existing one.

        See replace for a description of the name/ parm template/indices
        parameter.

        Use appendToFolder to add an entry to a empty folder.  Use append to add
        an entry to an empty parm template group.
        """

    def append(self, parm_template):
        """
        append(self, parm_template)

        Add a parm template after all existing parm templates, outside of any
        folder.

        See also appendToFolder.
        """

    def appendToFolder(self, label_or_labels_or_parm_template_or_indices, parm_template):
        """
        appendToFolder(self, label_or_labels_or_parm_template_or_indices,
        parm_template)

        Add a parm template to the bottom of an existing folder.

        Note that you cannot add to a folder by simply looking up the folder
        parm template and calling hou.FolderParmTemplate.addParmTemplate on it,
        because asking for a folder will return a deep copy.  The parm templates
        inside the copied folder will be separate from those inside this group,
        and modifying the folder will not affect the group.  Consider the
        following example:

          >>> folder = group.findFolder("Transform")
          # "folder" now has its own copy of the parms inside it.
          >>> folder.addParmTemplate(new_parm_template)
          # "folder"'s parm templates are updated, but the group's parm templates are
          # unchanged.

          >>> group.appendToFolder(folder, new_parm_template)
          # The group is modified.  "folder"'s contents are unchanged.
        """

    def addParmTemplate(self, parm_template):
        """
        addParmTemplate(self, parm_template)

        This method is simply an alias for the append method.

        It makes it easier to treat parm template groups and
        hou.FolderParmTemplate objects uniformly, since hou.FolderParmTemplate
        has an addParmTemplate method.
        """

    def remove(self, name_or_parm_template_or_indices):
        """
        remove(self, name_or_parm_template_or_indices)

        Remove a parm template from the group.  Note that if you remove a
        folder, all of the parm templates in the folder are also removed.

        See replace for a description of the name/parm template/indices
        parameter.

        Raises hou.OperationFailed if the parm template could not be found.
        """

    def hide(self, name_or_parm_template_or_indices, on):
        """
        hide(self, name_or_parm_template_or_indices, on)

        Hide a parameter by making it invisible.  The parameter still exists in
        the group, but parameter dialogs will not display it.

        See replace for a description of the name/parm template/indices
        parameter.

        This method could be implemented as follows:
          def hide(self, name_or_parm_template_or_indices, on):
              parm_template = self.find(name_or_parm_template_or_indices)
              parm_template.hide(on)
              self.replace(name_or_parm_template_or_indices, parm_template)


        See also hideFolder and hou.ParmTemplate.hide.
        """

    def hideFolder(self, label_or_labels, on):
        """
        hideFolder(self, label_or_labels, on)

        Hide a folder and all the parameters in it.

        You may pass in either a string containing a single folder name or a
        sequence of strings to indentify a nested folder.  For example, the
        sequence ("Render", "Dicing") identifies the Dicing folder inside
        the Render folder.  The folder is hidden if on is True and unhidden if
        it is False.

        The following example hides the Transform parameter in a geometry
        object:
          >>> group = geo_node.parmTemplateGroup()
          >>> group.hideFolder("Transform", True)
          >>> geo_node.setParmTemplateGroup(group)


        The following example hides the Dicing folder inside the Render folder
        on a geometry object:
          >>> group = geo_node.parmTemplateGroup()
          >>> group.hideFolder(("Render", "Dicing"), True)
          >>> geo_node.setParmTemplateGroup(group)


        This method could be implemented as follows:
          def hideFolder(self, label_or_labels, on):
              self.hide(self.findFolder(label_or_labels), on)


        See also hide.
        """

    def isHidden(self, name_or_parm_template_or_indices):
        """
        isHidden(self, name_or_parm_template_or_indices) -> bool

        Return whether the given parameter is itself hidden or lies inside a
        hidden folder.

        See replace for a description of the name/parm template/indices
        parameter.

        Note that if the parameter is inside a hidden folder but the parameter
        is not marked as hidden, calling hou.ParmTemplate.isHidden on the parm
        template will return False, while this method will return True.
        """
        return True

    def isFolderHidden(self, label_or_labels):
        """
        isFolderHidden(self, label_or_labels) -> bool

        Return whether a folder or one of its containing folders is hidden.

        Note that if a folder is inside a hidden folder but this folder is not
        marked as hidden, calling hou.ParmTemplate.isHidden on the folder parm
        template will return False, while this method will return True.

        You may pass in either a string containing a single folder name or a
        sequence of strings to indentify a nested folder.  For example, the
        sequence ("Render", "Dicing") identifies the Dicing folder inside
        the Render folder.  The folder is hidden if on is True and unhidden if
        it is False.
        """
        return True

    def clear(self):
        """
        clear(self)

        Remove all parm templates from this group.
        """

    def asDialogScript(rename_conflicting_parms=False):
        """
        asDialogScript(rename_conflicting_parms=False)

        Return a string containing the dialog script file contents corresponding
        to this parm template group.

        Houdini saves parameter definitions in this format when saving digital
        asset definitions (in the DialogScript section of the digital asset) and
        when saving parameter layouts of nodes.
        """

    def setToDialogScript(dialog_script):
        """
        setToDialogScript(dialog_script)

        Set the contents of this group to match the parameters defined by the
        given dialog script string.

        Raises hou.OperationFailed if there is an error in the dialog script
        contents.
        """

    def asCode(self, function_name=None, variable_name=None):
        """
        asCode(self, function_name=None, variable_name=None)

        Return Python code that will recreate this group.

        function_name
            If not None, the returned code will create a Python function.

        variable_name
            The name of the variable that will be assigned the newly-created
            parm template group.
        """
        return ''

    def sourceNode(self):
        """
        sourceNode(self) -> hou.Node or None

        Return the node that the parameter template group was generated from. If
        the group was not generated from a node, then return None.

        Raises hou.ObjectWasDeleted if the source node has been destroyed.
        """
        return Node()

class Pane(object):
    """
    hou.Pane

    A rectangular area of the desktop that contains one or more pane tabs.

    Desktops (and floating panels) are composed of one or more panes.
    Initially a desktop contains one pane, and more panes are added to it by
    splitting existing panes in two, either horizontally or vertically.

    See hou.Desktop for more information about panes and pane tabs.  See
    hou.FloatingPanel for more information about floating panels.


    """

    def __init__(self): raise AttributeError, "No constructor defined"

    def desktop(self):
        """
        desktop(self) -> hou.Desktop or None

        Return the desktop in which this pane exists, or None if it is in a
        floating panel that's not attached to the desktop.
        """
        return Desktop()

    def id(self): return 0
    def floatingPanel(self): return FloatingPanel ()
    def tabs(self):
        """
        tabs(self) -> tuple of hou.PaneTab

        Return the pane tabs in this pane.
        """
        return (PaneTab(),)

    def createTab(self, type):
        """
        createTab(self, type) -> hou.PaneTab

        Create a new pane tab with the desired type and return it.  The new pane
        tab will be current (i.e. it will be the pane tab that's open).
        """
        return PaneTab()

    def currentTab(self):
        """
        currentTab(self) -> hou.PaneTab

        Return the currently focused pane tab.

        See also hou.PaneTab.setIsCurrentTab.
        """
        return PaneTab()

    def tabOfType(self, type, index=0):
        """
        tabOfType(self, type, index=0) -> hou.PaneTab or None

        Find and return a pane tab with the desired type, or None if no such tab
        exists in the pane.

        If there are multiple tabs in the pane with the desired type, then the
        first found tab is returned.  Use 'index' to return the other tabs.  For
        example, use 'index=0' to return the first found tab, use 'index=1' to
        return the second found tab, etc.

        See also hou.ui.paneTabOfType.
        """
        return PaneTab()

    def splitHorizontally(self):
        """
        splitHorizontally(self) -> hou.Pane

        Split the pane, adding a new pane to the right, and return the new pane.
        The new pane will have a single tab whose type is the same as the type
        of this pane's current tab.

        See also hou.Pane.splitVertically.

        REPLACES
            pane command        """
        return Pane()

    def splitVertically(self):
        """
        splitVertically(self) -> hou.Pane

        Split the pane, adding a new pane to the bottom, and return the new
        pane. The new pane will have a single tab whose type is the same as the
        type of this pane's current tab.

        See also hou.Pane.splitHorizontally.

        REPLACES
            pane command        """
        return Pane()

class PythonPanel(object):
    """
    hou.PythonPanel

    Class representing a pane tab that can display an embedded PySide or
    PyQt  interface.

    See also hou.pypanel and hou.PythonPanelInterface.


    PySide and PyQt interfaces can only be created from the main Houdini
    application thread.  You cannot call any method in this class from a
    separate thread (i.e. do not call from a Python Shell).
    """
    def __init__(self): raise AttributeError, "No constructor defined"
    def setInterface(self,interface):
        """
        setInterface(self,interface)

        Show the specified interface in the Python Panel.  interface is a
        hou.PythonPanelInterface object.

        Raises hou.OperationFailed if interface is not an installed  Python
        Panel interface.
        """
    def showToolbar(self, show):
        """
        showToolbar(self, show)

        Show or hide the toolbar.  show must be either True or False.
        """
    def isToolbarShown(self):
        """
        isToolbarShown() -> bool

        Return True if the toolbar is shown and False otherwise.
        """
        return True
    def expandToolbar(self, on): return
    def isToolbarExpanded(self):
        """
        isToolbarExpanded() -> bool

        Return True if the toolbar is expanded and False otherwise.
        """
        return True
    def activeInterface(self):
        """
        Returns the interface currently assigned to the Python Panel, or None if no interface has been assigned.
        """
        return  PythonPanelInterface()
    def activeInterfaceRootWidget(self):
        """
        Returns a reference to the user-defined root widget created by the active interface in the Python Panel. Returns None if there is no active interface or widget.
        """
        from PySide.QtGui import QWidget
        return QWidget()

    def setActiveInterface(self, interface):
        """
        Show the specified interface in the Python Panel. interface is a hou.PythonPanelInterface object.
        Raises /hom/hou/OperationFailed if interface is not an installed Python Panel interface.
        """
        pass


class HelpBrowser(PaneTab):
    """
    hou.HelpBrowser

    Class representing a help browser pane tab.  Provides methods for
    controlling the help browser.

    REPLACES
      * helpbrowser


    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def displayHelp(self, node_type):
        """
        displayHelp(self, node_type)

        Loads the help for the specified node type.

        Raises HOM_ObjectWasDeleted if the help browser pane tab was deleted.
        """
        return _hou.HelpBrowser_displayHelp(*args)

    def displayHelpPath(self, help_path):
        """
        displayHelpPath(self, help_path)
        """

    def homePage(self):
        """
        homePage(self) -> str

        Returns the home page URL of this help browser.

        Raises HOM_ObjectWasDeleted if the help browser pane tab was deleted.
        """
        return ''

    def setHomePage(self, home_page):
        """
        setHomePage(self, home_page)

        Sets the home page for this help browser to the specified URL.

        Raises HOM_ObjectWasDeleted if the help browser pane tab was deleted,
        and raises HOM_Error if home_page is not given.
        """

    def url(self):
        """
        url(self) -> str

        Return the current URL of this help browser.

        Raises HOM_ObjectWasDeleted if the help browser pane tab was deleted.
        """
        return ''

    def setUrl(self, url):
        """
        setUrl(self, url)

        Loads the specified URL.

        Raises HOM_ObjectWasDeleted if the help browser pane tab was deleted,
        and raises HOM_Error if url is not given.
        """

    def showUI(self, show):
        """
        showUI(self, show)

        Shows or hides the help browser's navigation controls.

        Raises HOM_ObjectWasDeleted if the help browser pane tab was deleted.
        """

class PaneTab(PythonPanel, HelpBrowser):
    """
    hou.PaneTab

    One of the tabs inside a desktop pane.

    Each pane type is of a particular type (e.g. scene viewer, network view,
    parameters, etc.).  A pane may contain multiple tabs and displays the
    contents of one tab at a time.

    See hou.Desktop for more information about panes and pane tabs.
    """

    def __init__(self): raise AttributeError, "No constructor defined"

    def pane(self):
        """
        pane(self) -> hou.Pane or None

        Return the pane in the desktop that contains this pane tab.  Note that
        pane tabs in regular floating panels are always in a pane, since regular
        floating panels contain one or more panes.

        However, some floating panels have their content stripped down to only
        contain one particular pane tab type, and do not display the user
        interface to add more pane tabs, split the pane, etc.  This method
        returns None for these stripped down floating panels.
        """
        return Pane()

    def name(self):
        """
        name(self) -> str

        Return the name of this tab.

        REPLACES
            pane command        """
        return ''

    def setName(self, name):
        """
        setName(self, name)

        Set the name of this pane tab.  A pane tab name may contain spaces.

        Note that this name is the internal name of the tab, and is different
        from the label displayed in the interface.

        REPLACES
            pane command        """

    def isCurrentTab(self):
        """
        isCurrentTab(self) -> bool

        Return whether this tab is the selected tab in the containing pane.
        """
        return True

    def setIsCurrentTab(self):
        """
        setIsCurrentTab(self)

        Set this tab as the selected tab in the containing pane.
        """

    def isFloating(self):
        """
        isFloating(self) -> bool

        Return whether this pane tab is in a floating panel.

        This method can be approximately implemented as follows:
          def isFloating(self):
              return self.pane() is None or self.pane().floatingPanel() is not None


        REPLACES
            pane command        """
        return True

    def clone(self):
        """
        clone(self) -> hou.PaneTab

        Create a floating copy of the pane tab and return the cloned pane tab.
        The new pane tab is in a new floating panel.
        """
        return PaneTab()

    def close(self):
        """
        close(self)

        Close the pane tab.

        REPLACES
            pane command        """

    def type(self):
        """
        type(self) -> hou.paneTabType enum value

        Return the type of this tab (i.e. whether it is a scene viewer,
        parameter editor, network editor, etc.).
        """
        return paneTabType()

    def setType(self, type):
        """
        setType(self, type) -> hou.PaneTab

        Create a new pane tab of the given type, replace this tab with it, and
        return the new pane tab.  Use the returned pane tab afterward;
        references to this tab become invalid.

        REPLACES
            pane command        """
        return PaneTab()

    def linkGroup(self):
        """
        linkGroup(self) -> hou.paneLinkType enum value

        Return the link group that this pane tab belongs to.

        See also hou.PaneTab.isPin.
        """
        return paneLinkType()

    def setLinkGroup(self, group):
        """
        setLinkGroup(self, group)

        Set the link group membership of this pane tab.
        """

    def isPin(self):
        """
        isPin(self) -> bool

        Return whether this pane tab is pinned.  This method is equivalent to
        (self.linkGroup() == hou.paneLinkType.Pinned)

        See also hou.PaneTab.linkGroup.
        """
        return True

    def setPin(self, pin):
        """
        setPin(self, pin)

        If pin is True, set the link group membership to
        hou.paneLinkType.Pinned. Otherwise, set it to
        hou.paneLinkType.FollowSelection.  This method can be implemented using
        hou.PaneTab.setLinkGroup as follows:

          def setPin(self, pin):
              if pin:
                  self.setLinkGroup(hou.paneLinkType.Pinned)
              else:
                  self.setLinkGroup(hou.paneLinkType.FollowSelection)

        See also hou.PaneTab.setLinkGroup.
        """

    def cd(self):
        pass
    def currentNode(self):
        return Node()
    def pwd(self):
        return Node()
    def setCurrentNode(self, node):
        pass
    def setPwd(self, node):
        pass

class PathBasedPaneTab(PaneTab):
    """
    hou.PathBasedPaneTab

    REPLACES
      * bookmark
      * pane
      * mousepath


    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def pwd(self):
        """
        pwd(self) -> Node
        """
        return Node()

    def setPwd(self, node):
        """
        setPwd(self, node)
        """

    def cd(self, path):
        """
        cd(self, path)
        """

    def currentNode(self):
        """
        currentNode(self) -> Node
        """
        return Node()

    def setCurrentNode(self, node):
        """
        setCurrentNode(self, node)
        """

class DopData(object):
    """
    hou.DopData

    A piece of data stored inside a DOP network's simulation.

    Each DOP network builds a tree of data, and then Houdini examines and
    updates this tree when it runs the simulation.  DOP data elements can be
    DOP objects, geometry, volumes, forces, solvers, etc.  The data is
    arranged in a tree structure, where child nodes are called subdata and
    are said to be attached to their parent nodes.  Under the root of the
    tree are usually the DOP objects and data describing their
    relationships.

    Note that the same piece of data can appear in the tree in multiple
    locations, with different names.  DopData objects thus do not store
    their name, and the name of a piece of data in the tree is instead
    stored with its parent data(s).

    By default, DopData objects store the path within the tree to the data.
    As a consequence, if the time changes and the solvers within the
    simulation change the contents of the tree of data, the Python DopData
    object will update to refer to the simulation's new state.  If the data
    path no longer refers to valid data, Houdini raises hou.ObjectWasDeleted
    when you try to access the DopData object from Python.

    If you do not want the DopData to update with changes to the simulation,
    you can call hou.DopData.freeze.  freeze returns another DopData object
    that refers the simulation's state at the current time, and will not
    change when the simulation time changes.

    Each piece of data can contain records, and each record stores a list of
    name and value pairs called fields.  Each record has a name, but it's
    possible for multiple records with the same name to exist in the same
    piece of data.  In this case, the record also has an index, and you can
    think of the records as rows of a spreadsheet.
    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def freeze(self):
        """
        freeze(self) -> hou.DopData

        Return a frozen version of this DopData.  Frozen versions of the data
        will not update when the simulation updates.  Instead, they will refer
        to the state of the simulation at the time they were frozen.

        It is ok to call this method on a DopData object that is already frozen.
        """
        return DopData()

    def isFrozen(self):
        """
        isFrozen(self) -> bool

        Return whether or not this data is frozen.

        See hou.DopData.freeze for more information.
        """
        return True

    def path(self):
        """
        path(self) -> str

        Return the path to this object within the tree of DOP data.  This path
        includes the DOP object or relationship as the first part of the path.

        Note that the same piece of DOP data can exist in multiple places of the
        tree.  The path returned is the path stored inside this Python DopData
        object, since the Python object uses the path to look up the underlying
        data each time you call a method on it.

        Note that the path is only available for unfrozen objects.  If you call
        this method on a frozen DopData object it raises hou.OperationFailed.
        """
        return ""

    def dopNetNode(self):
        """
        dopNetNode(self) -> hou.Node

        Return the DOP network node containing this DOP data.
        """
        return Node()

    def simulation(self):
        """
        simulation(self) -> hou.DopSimulation

        Return the DOP simulation containing this DOP data.  This method is a
        shortcut for self.dopNetNode().simulation().
        """
        return DopSimulation()

    def creator(self):
        """
        creator(self) -> hou.DopNode

        Return the DOP node that created this DOP data inside the DOP network.
        """
        return DopNode()

    def id(self):
        """
        id(self) -> str

        Return the globally unique identifier (GUID) for this DOP data.  This
        method is a shortcut for self.record("Basic").field("uniqueid").

        If you want an object's index, hou.DopObject.objid.
        """
        return ''

    def dataType(self):
        """
        dataType(self) -> str

        Return a string describing the type of data this object contains.

          >>> obj = hou.node("/obj/AutoDopNetwork").simulation().objects()[0]
          >>> obj.dataType()
          'SIM_Object'

        See also hou.DopData.dataTypeObject.
        """
        return ''

    def recordTypes(self):
        """
        recordTypes(self) -> tuple of str

        Return a tuple of strings containing the record types stored inside this
        DOP data.  Each DOP data contains records named "Basic" and
        "Options", and some types of DOP data contain additional records.

        REPLACES
            dopnumrecordtypes function
            doprecordtypename function        """
        return ('',)

    def record(self, record_type, record_index=0):
        """
        record(self, record_type, record_index=0) -> hou.DopRecord

        Given a record type name return that record, or None if no record exists
        with that name.  If this DOP data contains multiple records with this
        record type name you can think of each record as a row in a spreadsheet,
        and record_index determines which one is returned.  Use
        len(self.records(record_type)) to determine how many records of this
        type are in this DOP data.

        Use hou.DopData.recordTypes to get a tuple of record types in a DOP
        data.  See also hou.DopData.records for an example, and see
        hou.DopData.options for a way to easily access the "Options" record.

        REPLACES
            dopfield function        """
        return DopRecord()

    def records(self, record_type):
        """
        records(self, record_type) -> tuple of hou.DopRecord

        Return a tuple of all the records of this record type.  See also
        hou.DopData.record.

        This example lists the input affectors for a rigid body box that
        collides with a ground plane:
          >>> obj = hou.node("/obj/AutoDopNetwork").simulation().objects()[-1]
          >>> obj.records("RelInAffectors")
          (<hou.DopRecord of type RelInAffectors index 0>, <hou.DopRecord of type RelInAffectors index 1>)
          >>> [record.field("relname") for record in obj.records("RelInAffectors")]
          ['merge1', 'staticsolver1_staticsolver1']
          >>> obj.record("RelInAffectors", 1).field("relname")
          'staticsolver1_staticsolver1'


        REPLACES
            dopnumrecords function        """
        return (DopRecord(),)

    def options(self):
        """
        options(self) -> hou.DopRecord

        Return the Options record.  This method is a shortcut for
        self.record("Options").

        REPLACES
            dopoption function
            dopoptions function        """
        return DopRecord()

    def subData(self):
        """
        subData(self) -> dict of str to hou.DopData

        Return a dictionary mapping names to DOP data instances for the subdata
        attached to this data.

          # The following code assumes you have created a box from the shelf and used
          # Rigid Bodies > RBD Object on the shelf to make it a rigid body.
          >>> obj = hou.node("/obj/AutoDopNetwork").simulation().objects()[0]
          >>> obj
          <hou.DopObject box_object1 id 0>
          >>> obj.recordTypes()
          ('Basic', 'Options', 'RelInGroup', 'RelInAffectors')
          >>> record = obj.record("Options")
          >>> record.fieldNames()
          ('name', 'groups', 'affectors', 'affectorids', 'objid')
          >>> record.field("name")
          'box_object1'

          >>> obj.subData().keys()
          ['PhysicalParms', 'ODE_Body', 'Solver', 'Geometry', 'SolverParms', 'ODE_Geometry', 'Forces', 'Position', 'Colliders']
          >>> obj.findSubData("Forces/Gravity_gravity1")
          <hou.DopData of type SIM_ForceGravity>
          >>> obj.findSubData("Forces/Gravity_gravity1").options().field("force")
          <hou.Vector3 [0, -9.80665, 0]>

        REPLACES
            dopsubdataname function
            dopnumsubdata function        """
        return {'':DopData()}

    def findSubData(self, data_spec):
        """
        findSubData(self, data_spec) -> hou.DopData or None

        Return the DOP data with the given name that is attached to this DOP
        data, or None if no such data exists.  Note that the name may also be a
        slash-separated path to nested subdata.

        See hou.DopData.subData for an example.

        This method can be approximately implemented as follows:
          def findSubData(self, data_spec):
              data = self
              for name in data_spec.split("/"):
                  if name not in data.subData():
                      return None
                  data = data.subData()[name]
              return data


        REPLACES
            dophassubdata function        """
        return DopData()

    def findAllSubData(self, data_spec, recurse=False):
        """
        findAllSubData(self, data_spec, recurse=False) -> dict of str to
        hou.DopData

        Given a pattern, return a dictionary mapping subdata paths to DOP data
        instances for all the subdatas whose name matches the pattern.  If
        recurse is True, all grandchildren subdata will be added to the result.

          # The following code assumes you have created a box from the shelf and used
          # Rigid Bodies > RBD Object on the shelf to make it a rigid body.
          >>> obj = hou.node("/obj/AutoDopNetwork").simulation().objects()[0]
          >>> obj.findAllSubData("S*").keys()
          ['SolverParms', 'Solver']
          >>> obj.findAllSubData("S*", recurse=True).keys()
          ['SolverParms', 'Solver/Random', 'SolverParms/ActiveValue', 'Solver']
          >>> obj.findAllSubData("S*/*", recurse=True).keys()
          ['SolverParms/ActiveValue', 'Solver/Random']
        """
        return {"":DopData(),}

    def createSubData(self, data_name, data_type="SIM_EmptyData",
        avoid_name_collisions=False):
        """
        createSubData(self, data_name, data_type="SIM_EmptyData",
        avoid_name_collisions=False) -> hou.DopData

        Create subdata under this data with the specified name and type.  You
        would call this method from a script solver DOP.

        data_name
            The name of the new data.  Note that this name may contain slashes
            to create subdata on existing data.

        data_type
            Either the name of the data type to create or a hou.DopDataType
            instance.  If you simply want something containing an empty options
            record, use "SIM_EmptyData".

        avoid_name_collisions
            If True and data with the specified name exists, Houdini will create
            a unique name that does not conflict with any existing data.

        Raises hou.OperationFailed if data with this name already exists.  If
        you want to replace existing data it is up to you to first call
        hou.DopData.removeData.

        Raises hou.PermissionError if called from outside a script solver DOP.

        Use hou.DopData.attachSubData to create a reference to existing data.
        See hou.DopData.copyContentsFrom for an example of how to create a copy
        of existing data.

        REPLACES
            dopsolveadddata command        """
        return DopData()

    def attachSubData(self, data, new_data_name, avoid_name_collisions=False):
        """
        attachSubData(self, data, new_data_name, avoid_name_collisions=False)

        Make existing data become subdata of this data.  Houdini does not create
        a duplicate of the data.  Instead, the data's parent(s) and this data
        will both refer to the same instance of subdata.  You would call this
        method from a script solver DOP.

        data
            The DopData that will become subdata of this data.

        new_data_name
            The name of the new subdata.

        avoid_name_collisions
            If True and data with the specified name exists, Houdini will create
            a unique name that does not conflict with any existing data.

        Raises hou.OperationFailed if data with this name already exists.  If
        you want to replace existing data it is up to you to first call
        hou.DopData.removeData.

        Raises hou.PermissionError if called from outside a script solver DOP.

        See hou.DopData.copyContentsFrom for an example of how to create a copy
        of existing data.

        REPLACES
            dopsolvecopydata command        """

    def removeSubData(self, data_spec):
        """
        removeSubData(self, data_spec)

        Remove subdata with the given name.  Raises hou.PermissionError if
        called from outside a script solver DOP.

        Raises hou.OperationFailed if data with that name already exists.

        REPLACES
            dopsolveremovedata command        """

    def copyContentsFrom(self, data):
        """
        copyContentsFrom(self, data)

        Copy the contents of the given DopData into this one, adapting the data
        if it is of a different type.  You would call this method from a script
        solver DOP.

        Raises hou.PermissionError if called from outside a script solver DOP.

        Use this method along with hou.DopData.createSubData to copy existing
        subdata:
          def copySubData(new_parent_data, data_to_copy, new_data_name, avoid_name_collisions=False):
              '''Create a copy of data and attach it to other data.'''
              new_data = new_parent_data.createSubData(new_data_name, data_to_copy.dataType(), avoid_name_collisions)
              new_data.copyContentsFrom(data_to_copy)
              return new_data


        REPLACES
            dopsolveadddata command        """

    def _asVoidPointer(self): return

class ShelfElement(object):
    """
    hou.ShelfElement
    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def filePath(self):
        """
        filePath(self) -> str
        """
        return ''

    def setFilePath(self, file_path):
        """
        setFilePath(self, file_path)
        """

    def name(self):
        """
        name(self) -> str
        """
        return ''

    def setName(self):
        """
        setName(self, name)
        """

    def label(self):
        """
        label(self) -> str
        """
        return ''

    def setLabel(self, label):
        """
        setLabel(self, label)
        """

class anonstats(object):

    def __init__(self): raise AttributeError, "No constructor defined"
    def recordOccurrence(self): return
    def recordString(self): return
    def hasString(self): return True
    def getString(self): return ''
    def incrementCount(self): return 0
    def logEvent(self): return
    def addSum(self): return

class AssetBrowser(PathBasedPaneTab):

    def __init__(self): raise AttributeError, "No constructor defined"
    def reload(self): return
    def installRequiredDefinitionsForNodeTypeName(self): return
    def storeUpdateSessionKey(self): return
    def updateAssetDownloadFraction(self): return
    def storeSyncSessionKey(self): return

class Attrib(object):
    """
    hou.Attrib

    This class stores information about a Geometry attribute.

    An attribute describes extra data you can attach to different elements
    of geometry.  The attribute values are the individual instances of that
    data, and for each attribute there is exactly one attribute value per
    geometry element.  For example, if you look at the points in Houdini's
    geometry spreadsheet, the point numbers are listed down the side, the
    point attributes are listed across the top, and the point attribute
    values are contained in the table.

    The attribute specifies which elements store the attribute values:
    points, primitives, or vertices.  An attribute can also be global (also
    known as a detail attribute), in which case there is one instance of the
    attribute value in the geometry.

    The attribute also specifies the data type of the attribute values.

    To look up existing attributes, use hou.Geometry.findPointAttrib,
    hou.Geometry.findPrimAttrib, hou.Geometry.findVertexAttrib, and
    hou.Geometry.findGlobalAttrib.  To add a new attribute, use
    hou.Geometry.addAttrib.


    Point positions are stored in a point attribute named P and point
    weights are stored in Pw.  See hou.Point.position and hou.Point.weight
    for more information.

    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def destroy(self):
        """
        destroy(self)

        Remove this attribute from the geometry.  You would typically call this
        method from the code of a Python-defined SOP.

        Raises hou.GeometryPermissionError if this geometry is not modifiable.

        Raises hou.OperationFailed if you try to destroy the P or Pw point
        attributes.
        """

    def geometry(self):
        """
        geometry(self) -> hou.Geometry

        Return the Geometry object containing this attribute.
        """
        return Geometry()

    def name(self):
        """
        name(self) -> str

        Return the attribute's name.  Each attribute in the geometry has a
        unique name.
        """
        return ''

    def dataType(self):
        """
        dataType(self) -> hou.attribData enum value

        Return the attribute's data type (int, float or string).

        The size of the attribute also determines the format of the attribute
        values.  For example, if the data type is int and the size is 3, the
        attribute value will be a tuple of 3 ints.  If the size was 1, the
        attribute value would simply be an int.

        Note that a string attribute's size must be 1.
        """
        return attribData()

    def type(self):
        """
        type(self) -> hou.attribType enum value

        Return the type of attribute (point, primitive, vertex, or global).
        """
        return attribType()

    def qualifier(self):
        """
        qualifier(self) -> str

        Return the attribute's type qualifier.  The qualifier is a description
        of the data contained in the attribute.  An empty string is returned if
        the attribute has no numeric representation or if the attribute is the
        pseudo Pw point attribute.
        """
        return ''

    def size(self):
        """
        size(self) -> int

        Return the number of data components in the attribute value.  See
        hou.Attrib.dataType for more information.

        REPLACES
            pointattribsize function
            primattribsize function
            vertexattribsize function        """
        return 0

    def setSize(self):
        """
        setSize(self)
        Sets the number of data components in the attribute value.  See
        hou.Attrib.dataType for more information.
        """

    def isTransformedAsVector(self): return
    def isTransformedAsNormal(self):
        """
        isTransformedAsNormal(self) -> bool

        Return whether attribute values in the geometry are automatically
        transformed as a normal when Houdini transforms (e.g. rotates) the
        geometry.

        For more information, see the hou.Geometry.addAttrib, in the
        transform_as_normal parameter documentation.
        """
        return True

    def boostAnyDefaultValue(self): return
    def strings(self):
        """
        strings(self) -> tuple of str

        Return the string table for this attribute.  If the attribute is not a
        string, returns an empty tuple.

        A string attribute does not store each string value inside the attribute
        element (i.e. point, primitive, etc.).  Instead, the unique string
        attribute values are stored in a table inside the attribute, and each
        attribute value stores an index to that string.

        For example, suppose this attribute stores strings on points.  If all
        points have the attribute value "foo" then the string table will be
        just ("foo",) and each point will store the index 0.  When you set
        some points' values to "bar", Houdini adds sets the string table to
        ("foo", "bar") and sets stores the index 1 in those points.  When
        you set one of those points back to "foo", Houdini leaves the string
        table unchanged and stores the index 0 in that point.

        When using string attribute values, this implementation is hidden from
        you, and you get and set those attributes as strings.  This method is
        provided only in case you need access to the string table.
        """
        return ('',)

    def indexPairPropertyTables(self):
        """
        indexPairPropertyTables(self) -> tuple of hou.IndexPairPropertyTable

        Return the property tables for this attribute.  If the attribute is not
        an index pair, returns an empty tuple.
        """
        return (IndexPairPropertyTable(),)

    def optionType(self, name):
        """
        optionType(self, name) -> hou.fieldType enum value

        Return a hou.fieldType enumerated value that describes the type of data
        stored in an option.  Returns hou.fieldType.NoSuchField if no field
        exists with that name.
        """
        return fieldType()

    def setOption(self, name, value, type_hint = fieldType.NoSuchField):
        """
        setOption(self, name, value, type_hint = hou.fieldType::NoSuchField)

        Set an entry in the dictionary of options.  See hou.Attrib.options for
        more information.

        name
            The name of the option to set.

        value
            An integer, float, string, hou.Vector2, hou.Vector3, hou.Vector4,
            hou.Quaternion, hou.Matrix3, hou.matrix4, or sequence of numbers.

        type_hint
            Used to determine the exact hou.fieldType desired when the specified
            value type is not enough to unambiguously determine it.
        """

    def removeOption(self, name):
        """
        removeOption(self, name)

        Remove an entry in the dictionary of options.  See hou.Attrib.options
        for more information.

        Raises hou.OperationFailed if there is no entry in the dictionary with
        this name.
        """

    def defaultValue(self):
        """
        defaultValue(self) -> int or float or str or tuple

        Return the attribute's default value.  Returns a single int/float/string
        for attributes of size 1 and a tuple of values for attributes with more
        than one component.

        This method is useful when duplicating an attribute.  See
        hou.Geometry.addAttrib for an example.
        """
        return 0

    def options(self, name):
        """
        option(self, name) -> bool, int, float, str, hou.Vector2,
        Hom.hou.Vector3, hou.Vector4, hou.Quaternion, hou.Matrix3, hou.Matrix4,
        tuple of int, or tuple of float

        Return the value of an individual option, on None if no such option
        exists.

        See also hou.Attrib.options, hou.Attrib.setOption and
        hou.Attrib.removeOption.
        """
        return 0

    def option(self): return

class audio(object):
    """
    hou.audio

    Functions related to playing audio using Houdini's playbar.

    REPLACES
      * audiopanel
    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def turnOffAudio(self):
        """
        turnOffAudio()

        Turn off the audio playback.
        """

    def useTimeLineMode(self):
        """
        useTimeLineMode()

        Put the Audio Panel into a scrub mode.

        When the Audio Panel is in the scrub (a.k.a. timeline) mode, Houdini
        will play the audio during the animation or when scrubbing the thumb in
        the playbar.
        """

    def useTimeSliceMode(self):
        """
        useTimeSliceMode()

        Put the Audio Panel into realtime (a.k.a. timeslice) mode.
        """

    def useTestMode(self):
        """
        useTestMode()

        Put the Audio Panel into a mode that tests the audio playback.

        When the Audio Panel is in the test mode, it will play the entire audio
        soundtrack. The test can be stopped and resumed with stop() and play()
        functions.

        The sound will not play when scrubbing the thumb in the playbar or when
        playing the animation in the playbar. The audio must be in either scrub
        or realtime mode for playing the sound during animation or scrubbing.
        """

    def setMono(self,on):
        """
        setMono(on)

        Set whether the audio will play in mono or stereo mode.
        """

    def setVolumeTied(self, on):
        """
        setVolumeTied(self, on)

        Set whether changing the volume of one channel affects the volume of the
        other channel. If so, both channels will have the same volume set.
        """

    def setMeter(self):
        """
        setMeter(on)

        Ses whether the meter will show the volume levels during the audio
        playback.
        """

    def setLeftVolume(self, value):
        """
        setLeftVolume(value)

        Set the volume for the left audio channel.
        """

    def setRightVolume(self,value):
        """
        setRightVolume(value)

        Set the volume for the right channel.
        """
        
    def useChops(self):
        """
        useChops()

        Set the Audio Panel to use a CHOP node for the audio.
        """

    def useAudioFile(self, file):
        """
        useAudioFile()

        Set the Audio Panel to use a disk file for the audio.
        """

    def setChopPath(self):
        """
        setChopPath(path)

        Set the Audio Panel to play the sound inside a CHOP node.  Houdini plays
        this sound during testing, animation or scrubbing.  See also
        hou.audio.useChops.

        path
            A string containing the path to the CHOP node.
        """

    def setAudioFileName(self,path):
        """
        setAudioFileName(path)

        Set the Audio Panel to play the sound inside an audio file.  Houdini
        plays this sound during testing, animation or scrubbing.  See also
        hou.audio.useAudioFile.
        """

    def setAudioOffset(self ,offset):
        """
        setAudioOffset(offset)

        Set the time offset of the sound to sync the audio.  This offset,
        specified in seconds, will coincide with the audio frame.  See also
        hou.audio.setAudioFrame.
        """

    def setAudioFrame(self, frame):
        """
        setAudioFrame(frame)

        Set the frame to sync the audio. The audio offset (in seconds) will
        coincide with this frame.  See also hou.audio.setAudioOffset.
        """

    def setScrubRepeat(self,on):
        """
        setScrubRepeat(on)

        Set whether the sound chunk is repeated during scrubbing.  See also
        hou.audio.useTimeSliceMode.
        """

    def setScrubSustain(self, value):
        """
        setScrubSustain(value)

        Set the length of time the that the sound chunk is repeatedly played
        when scrubbing comes to a standstill on a particular single frame. In
        practice, when the value is zero, no sound will be played when scrubbing
        keeps hovering over one frame.  But, when the value is non-zero, a small
        sound chunk will keep playing repeatedly with a specified frequency.
        See also hou.audio.useTimeSliceMode.
        """

    def setScrubRate(self, value):
        """
        setScrubRate(value)

        When the sustain period is non-zero, the small chunk of the sound will
        be repeated with this frequency when the scrubbing comes to a standstill
        at a single frame.  See also hou.audio.useTimeSliceMode.
        """

    def reverse(self):
        """
        reverse()

        When the Audio Panel is in the test mode, start playing the sound in
        reverse.
        """

    def stop(self):
        """
        stop()

        When the Audio Panel is in the test mode, stop the test playback if any
        audio is currently playing.
        """

    def play(self):
        """
        play()

        When the Audio Panel is in the test mode, start playing the Audio
        Panel's specified audio file or CHOP.  See also
        hou.audio.setAudioFileName and hou.audio.setChopPath.
        """

    def setLooping(self):
        """
        setLooping(on)

        When the Audio Panel is in the test mode, set whether the test should
        start playing from the beginning once the end is reached.  See also
        hou.audio.setRewind.
        """

    def setRewind(self):
        """
        setRewind(on)

        When the Audio Panel is in the test mode, set whether the sound should
        rewind to the beginning when the test is stopped. If not, on subsequent
        start, the sound will resume from the point at which it was previously
        stopped.  See also hou.audio.setLooping.
        """

class BoundingBox(object):
    """
    hou.BoundingBox

    An axis-aligned 3D rectangular region.

    For example, a bounding box might describe a piece of geometry's minimum
    and maximum values on each of the coordinate axes.  See
    hou.Geometry.boundingBox for an example of a function that returns a
    bounding box.
    """

    def __init__(self, *args):
        """
        __init__(self, xmin=0.0, ymin=0.0, zmin=0.0, xmax=0.0, ymax=0.0,
        zmax=0.0)

        Construct a new bounding box with the specified minimum and maximum
        bounds.  Use hou.BoundingBox.setTo to change the position of an existing
        bounding box.
        """
    def isAlmostEqual(self, bbox, tolerance=0.00001):
        """
        isAlmostEqual(self, bbox, tolerance=0.00001) -> bool

        Returns whether this bounding box is equal to another, subject to
        numerical tolerances.
        """
        return True

    def almostEqual(self, other): return True
    def __mul__(self, matrix4):
        """
        __mul__(self, matrix4) -> BoundingBox

        Take this bounding box, transform it by the given matrix, compute the
        axis-aligned bounding box around this transformed box, and return it.
        """
        return BoundingBox()

    def isValid(self):
        """
        isValid(self) -> bool

        Returns whether this bounding box is valid.
        """
        return True

    def setTo(self,bounds_sequence):
        """
        setTo(self, bounds_sequence)

        Given a sequence of (xmin, ymin, zmin, xmax, ymax, zmax) values, set the
        position of the bounding box.

        Raises hou.InvalidSize if the tuple does not contain six elements.
        """

    def minvec(self):
        """
        minvec(self) -> hou.Vector3

        Return a vector describing the corner of the box with the smallest x, y,
        and z values.
        """
        return Vector3()

    def maxvec(self):
        """
        maxvec(self) -> hou.Vector3

        Return a vector describing the corner of the box with the largest x, y,
        and z values.
        """
        return Vector3()

    def sizevec(self):
        """
        sizevec(self) -> hou.Vector3

        Return a vector describing the size of the box in each of the x, y, and
        z axes.

        This method can be implemented as follows:
          def sizevec(self):
              return self.maxvec() - self.minvec()
        """
        return Vector3()

    def center(self):
        """
        center(self) -> hou.Vector3

        Return the position of the center of the bounding box.

        This method can be implemented as follows:
          def sizevec(self):
              return (self.minvec() + self.maxvec()) * 0.5
        """
        return Vector3()

    def enlargeToContain(self,point_or_bbox):
        """
        enlargeToContain(self, point_or_bbox)

        Enlarge the bounding box to contain the given element.  The element may
        be a sequence of 3 floats (such as a hou.Vector3) describing a position
        or another bounding box.  If this box does not need to grow because it
        already completely contains the element, it won't be modified.
        """

    def contains(self, point):
        """
        contains(self, point)

        Given a sequence of 3 floats (such as a hou.Vector3) describing a
        position, return whether the position is inside the box.
        """

    def _asVoidPointer(self): return

class ButtonParmTemplate(ParmTemplate):
    """
    hou.ButtonParmTemplate

    Describes a parameter tuple containing a button.
    """
    def __init__(self, name, label, disable_when=None, is_hidden=False,
        is_label_hidden=False, join_with_next=False, help=None,
        script_callback=None,
        script_callback_language=hou.scriptLanguage.Hscript, tags={}):
        """
        __init__(self, name, label, disable_when=None, is_hidden=False,
        is_label_hidden=False, join_with_next=False, help=None,
        script_callback=None,
        script_callback_language=hou.scriptLanguage.Hscript, tags={})

        Creates a new ButtonParmTemplate instance.

        Construct a new ButtonParmTemplate.

        name
            See hou.ParmTemplate.name for more information.

        label
            See hou.ParmTemplate.label for more information.

        disable_when
            See hou.ParmTemplate.disableWhen for more information.

        is_hidden
            See hou.ParmTemplate.isHidden for more information.

        is_label_hidden
            See hou.ParmTemplate.isLabelHidden for more information.

        join_with_next
            See hou.ParmTemplate.joinsWithNext for more information.

        help
            See hou.ParmTemplate.help for more information.

        script_callback
            See hou.ParmTemplate.scriptCallback for more information.

        script_callback_language
            See hou.ParmTemplate.scriptCallbackLanguage for more information.

        tags
            See hou.ParmTemplate.tags for more information.
        """

class ChannelEditorPane(PaneTab):
    """
    hou.ChannelEditorPane

    REPLACES
      * chanlist
      * animeditor
    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def graph(self):
        """
        graph(self) -> hou.ChannelGraph

        Return the channel graph for this pane.
        """
        return ChannelGraph()

    def channelListSplitFraction(self):
        """
        channelListSplitFraction(self) -> double

        Return the width of the embedded channel list as fraction (0-1 value) of
        the pane's width.
        """
        return 0.0

    def setChannelListSplitFraction(self, value):
        """
        setChannelListSplitFraction(self, value)

        Set the width of the embedded channel list as fraction (0-1 value) of
        the pane's width.
        """

    def displayFilter(self):
        """
        displayFilter(self) -> string

        Return the filter pattern for which channels are displayed.
        """
        return ''

    def setDisplayFilter(self, filter):
        """
        setDisplayFilter(self, filter)

        Set the filter pattern for which channels are displayed. The channel
        name is used to match against the pattern.
        """

    def editorMode(self):
        """
        editorMode(self) -> hou.channelEditorMode enum value

        Return the animation editor mode.
        """
        return channelEditorMode()

    def setEditorMode(self, mode):
        """
        setEditorMode(self, mode)

        Set the animation editor mode.
        """

    def templateFilter(self):
        """
        templateFilter(self) -> string

        Return the filter pattern for which channels are templated.
        """
        return ''

    def setTemplateFilter(self, filter):
        """
        setTemplateFilter(self, filter)

        Set the filter pattern for which channels are templated. The channel
        name is used to match against the pattern.
        """

    def colorsCallback(self):
        """
        colorsCallback(self) -> string

        Return the active channel colors callback name.
        """
        return ''

    def setColorsCallback(self, callback_name):
        """
        setColorsCallback(self, callback_name) -> bool

        Set the active channel colors callback name. If the callback name is
        invalid, the active callback will be reset to default. Return True if
        the callback was successfully changed. Return False if the callback name
        was invalid.
        """
        return True

    def unregisterColorsCallback(self, callback_name):
        """
        unregisterColorsCallback(self, callback_name) -> bool

        Unregister a callback by name. It also resets the active callback if the
        callback to remove was the active one. Return True if the callback was
        successfully removed. Return False if the callback name was invalid.
        """
        return True

    def colorsCallbacks(self):
        """
        colorsCallbacks(self) -> tuple of string

        Return the list of registered channel colors callback.
        """
        return ('',)

    def registerColorsCallback(self, callback_name, callback_object ):
        """
        registerColorsCallback(self, callback_name, callback_object ) -> bool

        Registers a callback to generate custom channel colors based on the node
        and parameter names.

        callback_name
            A name for the custom color scheme. You can use this to remove the
            callback with the unregisterColorsCallback method.

        callback_object
            A Python object with a getChannelColor method. For example:


              class MyChannelColors(object):
                  def getChannelColor(self, node_path, channel_name):
                      return 0, 0, 0

            The node argument is the path to the node (for example, /obj/table).
            The parm argument is the internal name of the channel (for example,
            tx). The method must return a 3-tuple representing normalized (0-1,
            not 0-255) red, green, and blue values. If the method returns (0, 0,
            0) Houdini uses the default channel color.

        You should register the callback in a session-independent startup
        script. When you register the callback, Houdini will call it once with
        empty string arguments to make sure it returns a triple. Your
        getChannelColor() method needs to handle this case.

        The following example object uses the custom color tint of a node to
        color its channels:


          import hou

          class NodeColors:
              '''
              Use hue variants of a node's color for parameter names
              ending in x, y or z.
              '''

              def getChannelColor(self, node_path, channel_name):
                  # Handle the empty string case
                  if not node_path:
                      return 0, 0, 0

                  # Get a Node object from the path
                  n = hou.node(node_path)
                  # Get the node's color as a hou.Color object
                  color = n.color()
                  # Get the color's HSV values as a triple
                  hue, sat, val = n.color().hsv()

                  # If the color is gray, use the default
                  if not sat:
                      return 0, 0, 0

                  # Hue-shift the node color for X, Y, and Z channels:
                  if channel_name.endswith("x"):
                      color.setHSV(hue - 50, sat * 2, val * 1.2)
                  elif channel_name.endswith("y"):
                      color.setHSV(hue, sat * 2, val * 1.2)
                  elif channel_name.endswith("z"):
                      color.setHSV(hue + 50, sat * 2, val * 1.2)

                  # Return the color as normalized (r, g, b)
                  return color.rgb()
        """
        return True

class ChannelGraph(object):
    """
    hou.ChannelGraph

    REPLACES
      * animeditor
    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def selectedKeyframes(self):
        """
        selectedKeyframes(self) -> dictionary of (hou.Parm, tuple of
        hou.BaseKeyframe) pairs

        Returns a dictionary of (hou.Parm, keyframes) which are currently
        selected in the playbar.  Here is an example of how to scale the
        selected key values by 2:
          keyframes = hou.playbar.selectedKeyframes()
          for parm in keyframes.keys():
              for key in keyframes[parm]:
                  key.setValue(2 * key.value())
                  parm.setKeyframe(key)
        """
        return {Parm():BaseKeyframe()}

class ChopNode(Node):
    """
    hou.ChopNode

    Class representing a CHOP node.

    REPLACES
      * chopls
      * opget
      * opsave
      * opset
      * chop
      * chope
      * chopn
      * chopr
      * chops
      * ic
      * ice
      * icl
      * icmax
      * icmin
      * icn
      * icr
      * ics
      * oc
      * opflag
    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def isBypassed(self):
        """
        isBypassed(self) -> bool

        Returns whether the node's bypass flag is on.
        """
        return True

    def bypass(self, on):
        """
        bypass(self, on)

        Turn the node's bypass flag on or off, making this node have no effect.
        """

    def isLocked(self):
        """
        isLocked(self) -> bool

        Returns whether this node's lock flag is on.
        """
        return True

    def setLocked(self, on):
        """
        setLocked(self, on)

        Turn this node's lock flag on or off.  Locking a node saves its current
        cooked channel data into the node.  If you unlock a locked node, it will
        discard its locked channel data and recook, computing its channel data
        from its inputs and parameters.

        REPLACES        """

    def isDisplayFlagSet(self):
        """
        isDisplayFlagSet(self) -> bool

        Returns whether the node's display flag is on.
        """
        return True

    def setDisplayFlag(self, on):
        """
        setDisplayFlag(self, on)

        Turns the node's display flag to on or off.
        """

    def isAudioFlagSet(self):
        """
        isAudioFlagSet(self) -> bool

        Returns whether the node's audio flag is on.
        """
        return True

    def setAudioFlag(self, on):
        """
        setAudioFlag(self, on)

        Turns the node's audio flag on or off.
        """

    def isExportFlagSet(self):
        """
        isExportFlagSet(self) -> bool

        Returns whether the node's export flag is on.
        """
        return True

    def setExportFlag(self, on):
        """
        setExportFlag(self, on)

        Turns the node's export flag to on or off.
        """

    def isUnloadFlagSet(self):
        """
        isUnloadFlagSet(self) -> bool

        Returns whether the node's unload flag is on.
        """
        return True

    def setUnloadFlag(self, on):
        """
        setUnloadFlag(self, on)

        Turns the node's unload flag to on or off.
        """

    def tracks(self):
        """
        tracks(self) -> tuple of Tracks

        Returns a tuple of all the tracks in this node.
        """
        return (Tracks(),)

    def track(self, track_name):
        """
        track(self, track_name) -> hou.Track or None

        Return the track of the given name, or None if it doesn't exist.
        """
        return Track()

    def sampleRate(self):
        """
        sampleRate(self) -> double

        Returns the sample rate used by this node in number of samples per
        second.
        """
        return 0.0

    def sampleRange(self):
        """
        sampleRange(self) -> (start, end)

        Return a 2-tuple containing the start and end values of the sample
        range. The number of samples for each track in this node is start-end+1.
        Note that samples start from 0, not 1.
        """
        return (0,0)

    def frameToSamples(self, frame):
        """
        frameToSamples(self, frame) -> double

        Converts a value expressed as frames to a value expressed in samples.
        """
        return 0

    def samplesToFrame(self, samples):
        """
        samplesToFrame(self, samples) -> double

        Converts a value expressed as samples to a value expressed in frames.
        """
        return 0.0

    def timeToSamples(self, time):
        """
        timeToSamples(self, time) -> double

        Converts a value expressed in seconds to a value expressed in samples.
        """
        return 0.0

    def samplesToTime(self, samples):
        """
        samplesToTime(self, samples) -> double

        Converts a value expressed as samples to a value expressed in seconds.
        """
        return 0.0

class Color(object):
    """
    hou.Color

    REPLACES
      * rgb
    """

    def __init__(self, *args):
        """
        __init__(self, rgb_tuple=(0.0, 0.0, 0.0)) -> Color
        """
    def rgb(self):
        """
        rgb(self) -> (float, float, float)
        """
        return (0.0,0.0,0.0)

    def hsv(self):
        """
        hsv(self) -> (float, float, float)
        """
        return (0.0,0.0,0.0)

    def hsl(self):
        """
        hsl(self) -> (float, float, float)
        """
        return (0.0,0.0,0.0)

    def xyz(self):
        """
        xyz(self) -> (float, float, float)
        """
        return (0.0,0.0,0.0)

    def lab(self):
        """
        lab(self) -> (float, float, float)
        """
        return (0.0,0.0,0.0)

    def tmi(self): pass
    def setRGB(self, values):
        """
        setRGB(self, tuple)
        """

    def setHSV(self, values):
        """
        setHSV(self, tuple)
        """

    def setHSL(self, values):
        """
        setHSL(self, tuple)
        """

    def setXYZ(self, values):
        """
        setXYZ(self, tuple)
        """

    def setLAB(self, values):
        """
        setLAB(self, tuple)
        """

    def setTMI(self): return
    def _asVoidPointer(self): return 

class CompositorViewer(PathBasedPaneTab):
    """
    hou.CompositorViewer
    """
    def __init__(self): raise AttributeError, "No constructor defined"
    def currentState(self):
        """
        currentState(self) -> str
        """
        return ''

    def enterViewState(self, wait_for_exit=False):
        """
        enterViewState(self, wait_for_exit=False)
        """

    def setCurrentState(self, state, wait_for_exit=False):
        """
        setCurrentState(self, state, wait_for_exit=False)
        """

class ConstructionPlane(object):
    """
    hou.ConstructionPlane

    The grid (a.k.a. construction plane) in the scene viewer pane tab.

    REPLACES
      * cplane
    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def sceneViewer(self):
        """
        sceneViewer(self) -> hou.SceneViewer

        Return the scene viewer containing this plane.
        """
        return SceneViewer()

    def isVisible(self):
        """
        isVisible(self) -> bool

        Return whether the grid is visible in the viewer.
        """
        return True

    def setIsVisible(self, on):
        """
        setIsVisible(self, on)

        Make this grid visible or invisible in the viewer.
        """

    def transform(self):
        """
        transform(self) -> hou.Matrix4

        Return the transformation matrix for this plane.

        When the transformation matrix is the identity matrix, the plane's
        bottom-left corner is at the origin and it sits in the XY plane.  In
        this orientation, increasing the number of cells in x or the size of a
        cell in x grows the plane outward from the origin along the x-axis.
        Similarly, increasing the number of cells or size of a cell in y grows
        the plane along the y-axis.

        Note that the transformation matrix does not contain any scale
        information. Use the cellSize and numberOfCells methods to get the size
        of the plane.

        The following function will return the position of the lower-left corner
        of the plane:
          def origin(construction_plane):
              return hou.Vector3(0, 0, 0) * construction_plane.transform()


        The following function will return the normal of the plane:
          def normal(construction_plane):
              return hou.Vector3(0, 0, 1) * construction_plane.transform().inverted().transposed()
        """
        return Matrix4()

    def setTransform(self, matrix):
        """
        setTransform(self, matrix)

        Set the transformation matrix for this plane to a hou.Matrix4.

        This matrix is used to translate and rotate the plane.  See the
        transform method for more information.

        Note that scale information inside the transformation matrix is ignored.
        Use the setCellSize and setNumberOfCells methods to adjust the size of
        the plane.

        The following function will change the position of the lower-left corner
        of the plane:
          def set_origin(construction_plane, new_origin):
              translation = hou.hmath.buildTranslate(hou.Vector3(new_origin) - origin(construction_plane))
              construction_plane.setTransform(construction_plane.transform() * translation)

          def origin(construction_plane):
              return hou.Vector3(0, 0, 0) * construction_plane.transform()


        The following function will change the normal of the plane:
          def set_normal(construction_plane, normal_vector):
              existing_rotation = hou.Matrix4(construction_plane.transform().extractRotationMatrix3())
              rotation = existing_rotation * normal(construction_plane).matrixToRotateTo(normal_vector)
              translation = hou.hmath.buildTranslate(origin(construction_plane))
              construction_plane.setTransform(rotation * translation)

          def normal(construction_plane):
              return hou.Vector3(0, 0, 1) * construction_plane.transform().inverted().transposed()

          def origin(construction_plane):
              return hou.Vector3(0, 0, 0) * construction_plane.transform()
        """

    def cellSize(self):
        """
        cellSize(self) -> tuple of float

        Return the x and y sizes (width and height) of one cell in the grid of
        cells.  The return value is a tuple of two floats.
        """
        return (0.0,)

    def setCellSize(self, size):
        """
        setCellSize(self, size)

        Change the x and y sizes (width and height) of each cell in the grid of
        cells.  size is a sequence of two floats.

        Changing the size of each cell will change the total size of the grid.
        """

    def numberOfCells(self):
        """
        numberOfCells(self) -> tuple of int

        Return the number of cells in the x and y directions of the grid. In
        other words, return the number of columns and rows.
        """
        return (0,)

    def setNumberOfCells(self, num): return 
    def numberOfCellsPerRulerLine(self):
        """
        numberOfCellsPerRulerLine(self) -> tuple of int

        Return the number of cells in the x and y directions between ruler
        lines. Ruler lines are darker than the normal lines drawn between grid
        cells.
        """
        return (0,)

    def setNumberOfCellsPerRulerLine(self, num): return 

class ContextViewer(PathBasedPaneTab):
    """
    hou.ContextViewer

    A class representing a context viewer pane tab.
    """
    def __init__(self): raise AttributeError, "No constructor defined"
    def sceneViewer(self):
        """
        sceneViewer(self) -> hou.SceneViewer

        Returns a SceneViewer if the ContextViewer is displaying a scene viewer.
        If not, returns None.
        """
        return SceneViewer()

    def compositorViewer(self):
        """
        compositorViewer(self) -> hou.CompositorViewer

        Returns a CompositorViewer if the ContextViewer is displaying a
        compositor viewer.  If not, returns None.
        """
        return CompositorViewer()

class CopNode(Node):
    """
    hou.CopNode

    Represents a compositing node.

    REPLACES
      * pic
      * picni
      * opflag
      * opget
      * opsave
      * opset
      * res
      * seqanim
      * seqend
      * seqlength
      * seqstart
    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def isBypassed(self):
        """
        isBypassed(self) -> bool

        Returns True if the node's bypass flag is turned on.  Returns False
        otherwise.

        REPLACES
            opflag function
            opget command        """
        return True

    def bypass(self, on):
        """
        bypass(self, on)

        Turns the node's bypass flag on or off.  When the bypass flag is on, the
        node will have no effect on the scene. The value of the  on argument
        must be True or False.

        Raises hou.PermissionError if the node is unwritable.

        REPLACES
            opset command        """

    def isDisplayFlagSet(self):
        """
        isDisplayFlagSet(self) -> bool

        Returns True if the node's display flag is turned on.  Returns False
        otherwise.

        REPLACES
            opflag function
            opget command        """
        return True

    def setDisplayFlag(self, on):
        """
        setDisplayFlag(self, on)

        Turns the node's display flag on or off.  When the display flag is on,
        the node's image will appear in the image viewport. The value of the on
        argument must be True or False.

        Raises hou.PermissionError if the node is unwritable.

        REPLACES
            opset command        """

    def isRenderFlagSet(self):
        """
        isRenderFlagSet(self) -> bool

        Returns True if the node's render flag is turned on.  Returns False
        otherwise.

        REPLACES
            opflag function
            opget command        """
        return True

    def setRenderFlag(self, on):
        """
        setRenderFlag(self, on)

        Turns the node's render flag on or off.  The render flag controls which
        node in a compositing network will be rendered to mplay  or to disk.
        The value of the on argument must be True or False.

        Raises hou.PermissionError if the node is unwritable.

        REPLACES
            opset command        """
    def planes(self):
        """
        planes(self) -> tuple of strings

        Returns a tuple of plane names in the node's image sequence.

        Raises hou.OperationFailed if the node could not be cooked or opened for
        processing.
        """
        return ('',)

    def components(self, plane):
        """
        components(self, plane) -> tuple of str

        Returns a tuple of component names for the specified plane in the node's
        image sequence.  The value of the plane argument must be a plane name.

        Raises ValueError if plane is None or empty. Raises hou.OperationFailed
        if the node could not be cooked or opened for processing. Raises
        hou.OperationFailed if the given plane does not exist.
        """
        return ('',)

    def depth(self, plane):
        """
        depth(self, plane) -> hou.imageDepth enum value

        Return the data format used to represent one component of one pixel in
        the given image plane.

        For example, if the depth of the "C" (color) plane is
        hou.imageDepth.Int8, each of the red, green, and blue components is
        stored as an (unsigned) 8-bit integer, occupying one byte. If, for
        example, it is instead hou.imageDepth.Float32, each of the red, green,
        and blue components is a 32-bit float and occupies 4 bytes (12 bytes
        total for all 3 components combined).
        """
        return imageDepth()

    def getPixelByUV(self, plane, u, v, component=None, interpolate=True):
        """
        getPixelByUV(self, plane, u, v, component=None, interpolate=True) ->
        tuple of float

        Returns plane values for a single pixel in the node's image.  The plane
        is defined by the plane argument which must be set to the plane's name.
        The pixel is defined by (u, v) coordinates where  u and v are values
        between 0.0 and 1.0.  If the optional  component argument is specified,
        then the value for that particular  component is returned.  Otherwise,
        all of the plane's component  values are returned.  The value of
        component should be the component's name (i.e. "r", "g", "b",
        etc.).

        If the (u, v) coordinates do not fall exactly on a pixel, then the
        return values are calculated by linear blending of the values for the
        surrounding pixels.  This can be disabled by setting the interpolate
        argument to False, in which case the values of the  pixel located
        immediately to the bottom-left of (u, v) are returned.

        Note that the returned values are for the node's image at the current
        frame.

        Raises ValueError if either u or v is outside of the 0.0-1.0 range.
        Raises ValueError if plane is None or empty. Raises hou.OperationFailed
        if the node could not be cooked or opened for processing. Raises
        hou.OperationFailed if the given plane does not exist. Raises
        hou.OperationFailed if the given component does not exist in the plane.

        REPLACES
            pic function
            picni function        """
        return (0.0,)

    def getPixelHSVByUV(self, u, v, interpolate=True):
        """
        getPixelHSVByUV(self, u, v, interpolate=True) -> tuple of float

        Returns a 3-tuple containing the hue, saturation and value for a single
        pixel in the node's image.  The pixel is defined by  (u, v) coordinates
        where u and v are values between 0.0 and 1.0.

        If the (u, v) coordinates do not fall exactly on a pixel, then the
        return values are calculated by linear blending of the values for the
        surrounding pixels.  This can be disabled by setting the interpolate
        argument to False, in which case the values of the  pixel located
        immediately to the bottom-left of (u, v) are returned.

        Note that the returned hue, saturation and value are for the node's
        image at the current frame.

        Raises ValueError if either u or v is outside of the 0.0-1.0 range.
        Raises hou.OperationFailed if the node could not be cooked or opened for
        processing.

        REPLACES
            pic function
            picni function        """
        return (0.0,)

    def getPixelLuminanceByUV(self, u, v, interpolate=True):
        """
        getPixelLuminanceByUV(self, u, v, interpolate=True) -> float

        Returns the luminance value for a single pixel in the node's image. The
        pixel is defined by (u, v) coordinates where u and v  are values between
        0.0 and 1.0.

        If the (u, v) coordinates do not fall exactly on a pixel, then the
        luminance is calculated by linear blending of the luminance values for
        the surrounding pixels.  This can be disabled by setting the interpolate
        argument to False, in which case the luminance of the  pixel located
        immediately to the bottom-left of (u, v) is returned.

        Note that the returned luminance value is for the node's image  at the
        current frame.

        Raises ValueError if either u or v is outside of the 0.0-1.0 range.
        Raises hou.OperationFailed if the node could not be cooked or opened for
        processing.

        REPLACES
            pic function
            picni function        """
        return 0.0

    def allPixels(self, plane="C", component=None, interleaved=True,
        time=-1.0):
        """
        allPixels(self, plane="C", component=None, interleaved=True,
        time=-1.0) -> tuple of float

        Return a tuple of floats containing all pixel values for a particular
        image plane.  The pixels in the bottom scanline of the image are first
        in the result, followed by the second-last scanline, etc.  Floating
        point values in the color plane ("C"), for example, are typically in
        the range 0.0 to 1.0.

        plane
            The name of the image plane to return.  All images have "C"
            (color) and "A" (alpha) planes.  Deep raster images may contain
            other planes, such as "Pz" (depth), "N" (normal), etc.

        component
            A particular subcomponent of the plane.  For example, for the "C"
            plane you could specify one of the "r", "g", or "b"
            subcomponents.  Specify None to indicate all components.

        interleaved
            Whether the different components of the plane are interleaved in the
            result.  For example, if the plane is "C", the interleaved result
            would be organized as rgbrgbrgb... while the uninterleaved result
            would be rrr...ggg...bbb....  This parameter has no effect when a
            particular component is specified.

        time
            The time at which to cook the COP node.  If this value is negative,
            Houdini uses the current time.

        This method does not accept a depth parameter like allPixelsAsString
        does.  The values are converted to floating point data, regardless of
        the actual depth of the image plane.
        """
        return (0.0,)

    def allPixelsAsString(self, plane="C", component=None, interleaved=True,
        time=-1.0, depth=None):
        """
        allPixelsAsString(self, plane="C", component=None, interleaved=True,
        time=-1.0, depth=None) -> str

        Return a binary string representation of the floats containing all the
        values of all voxels.  This method is faster than hou.CopNode.allPixels,
        and you can use the array module to convert the string into a Python
        sequence.  Note that this method returns binary float data, so there are
        4 bytes per R, G, and B component, not 1 byte.

        If depth is hou.imageDepth.Float32, this method provides a faster
        implementation of the following:
          import array
          def allPixelsAsString(self):
              return array.array("f", self.allPixels()).tostring()


        If depth is None and this method is called from the code implementing a
        Python COP to get an input plane, the depth will be the same as the
        plane's native depth.  If depth is None and this method is called from
        outside a Python COP, the depth will be hou.imageDepth.Float32.
        Otherwise, if depth is a hou.imageDepth enumerated value the result will
        be converted to the specified depth.

        See hou.CopNode.allPixels for more information.  See also
        hou.Volume.setVoxelSliceFromString.
        """
        return ''

    def setPixelsOfCookingPlane(self, values, component=None, interleaved=True,
        flip_vertically=False):
        """
        setPixelsOfCookingPlane(self, values, component=None, interleaved=True,
        flip_vertically=False)

        Set the pixels of the plane being cooked by the currently-running Python
        COP.

        values
            A sequence of floats, organized with the contents of the bottom
            scanline first.

            If component is None, the length of the sequence of floats must be
            the number of pixels in the image times the number of components.
            Otherwise, it must be the number of pixels in the image.

        component
            Either the name of one component in the plane being cooked, or None.
            If a component name is given, values will contain only the values
            for that component.  Otherwise, it will contain the values for all
            components of all pixels in the plane.

        interleaved
            If component is None and interleaved is True, values is contains the
            first component of the first pixel, followed by the second component
            of the first pixel, until the last component of the first pixel,
            then the first component of the second pixel, etc.  If it is False,
            values contains all the values of the first component for all
            pixels, followed by all the values of the second component, etc.

            For example, if the plane is "C" and interleaved is True, the
            values will be organized as rgbrgbrgb....  If it is not interleaved,
            it will be organized as rrr...ggg...bbb....

            If component is not None, this parameter is ignored.

        flip_vertically
            The default value for this parameter is False, so the first scanline
            in the values array is assumed to be the bottom scanline.  If
            flip_vertically is True, the input values are assumed to oriented
            starting at the top scanline.

        If you call this method from outside the cook function in a Python COP,
        raises hou.OperationFailed.

        See also hou.CopNode.allPixels and
        hou.CopNode.setPixelsOfCookingPlaneFromString.  Also see the HOM
        cookbook and the Python COP documentation for examples.
        """

    def imageBounds(self, plane="C"):
        """
        imageBounds(self, plane="C") -> tuple of int

        Returns the x and y boundaries of the given plane in the form of (xmin,
        ymin, xmax, ymax).  The value of the plane argument is the plane name.
        By default, the image bounds of the color plane is returned.

        Note that the image bounds is not the same as the image resolution. For
        example, the image bounds for a Font COP is the bounding rectangle
        around the displayed letters while the resolution is the size of the
        node's image.

        Note that the returned image bounds is for the current frame.

        Raises ValueError if plane is None or empty. Raises hou.OperationFailed
        if the node could not be cooked or opened for processing. Raises
        hou.OperationFailed if the given plane does not exist.

        REPLACES
            Expression functions        """
        return (0,)

    def xRes(self):
        """
        xRes(self)
        Returns the x-resolution of the node's image for the current frame.
        Raises hou.OperationFailed if the node could not be cooked or opened for
        processing.
        REPLACES        """

    def yRes(self):
        """
        yRes(self)

        Returns the y-resolution of the node's image for the current frame.

        Raises hou.OperationFailed if the node could not be cooked or opened for
        processing.

        REPLACES        """

    def sequenceStartFrame(self):
        """
        sequenceStartFrame(self) -> float

        Returns the start frame in the node's image sequence.

        Raises hou.OperationFailed if the node could not be cooked or opened for
        processing.

        REPLACES
            seqstart function        """
        return 0.0

    def sequenceEndFrame(self):
        """
        sequenceEndFrame(self) -> float

        Returns the last frame in the node's image sequence.

        Raises hou.OperationFailed if the node could not be cooked or opened for
        processing.

        REPLACES
            seqend function        """
        return 0.0

    def sequenceFrameLength(self):
        """
        sequenceFrameLength(self) -> float

        Returns the frame length of the node's image sequence.

        Raises hou.OperationFailed if the node could not be cooked or opened for
        processing.

        REPLACES
            seqlength function        """
        return 0.0

    def isSingleImage(self):
        """
        isSingleImage(self) -> bool

        Returns True if the node has a single image.  Returns False if the node
        has an image sequence.

        REPLACES
            seqanim function        """
        return True

    def saveImage(self, file_name, frame_range=()):
        """
        saveImage(self, file_name, frame_range=())

        Saves the node's cooked image sequence to disk.  For multiple images,
        make sure that the file_name argument contains $F so that the sequence
        is written to multiple files.

        The optional frame_range argument can be specified to write only a
        subset of frames in the image sequence.  frame_range must be a 2-tuple
        or a 3-tuple, where the first element is the start frame, the second
        element is the end frame and the third element is the frame increment.
        If frame_range is not given, then every frame in  the image sequence is
        saved to disk.

        Raises ValueError if the frame increment in frame_range is 0. Raises
        hou.InvalidSize if the size of frame_range is not 0, 2 or 3. Raises
        hou.OperationFailed if the node could not be cooked or opened for
        processing. Raises hou.OperationFailed if the image could not be saved
        to disk.

        REPLACES
            opsave command        """

    def setPixelsOfCookingPlaneFromString(self, values, component=None,
        interleaved=True, depth=None, flip_vertically=False):
        """
        setPixelsOfCookingPlaneFromString(self, values, component=None,
        interleaved=True, depth=None, flip_vertically=False)

        Set the pixels of the plane being cooked by the currently-running Python
        COP.  This method is like hou.CopNode.setPixelsOfCookingPlane except
        values contains a binary string representation of the data instead of a
        sequence of floats.  Consequently, this method is faster.

        The depth parameter specifies how to interpret the values in the binary
        string, and is a hou.imageDepth enumerated value.  If depth is None, the
        depth is assumed to be in the depth of the plane being cooked.  Note
        that, by specifying depth explicitly, you can provide data in any depth,
        regardless of the actual depth stored by the COP.

        Note that this method can accept more types that just a string: it can
        receive any Python object that supports the buffer interface.  In
        particular, arrays from the array and numpy Python modules are
        supported, so there is no need to first construct strings from those
        arrays.

        See hou.CopNode.setPixelsOfCookingPlane and
        hou.CopNode.allPixelsAsString for more information.
        """

class Desktop(object):
    """
    hou.Desktop

    Class representing a Houdini desktop (a pane layout).

    A desktop contains one or more panes.  Each pane contains one or more
    pane tabs of various types (scene viewer, parameters, network editor,
    etc.)  The main desktop window can be split horizontally or vertically
    into two panes, and each pane can itself be split horizontally or
    vertically.

    Note that a floating panel also contains one or more panes and a
    floating panel may optionally be attached to a desktop.

    The methods in this class that return pane tabs, panes, and floating
    panels only return those objects that are attached to (i.e. saved with)
    the desktop. To access all the visible pane tabs, panes, and floating
    panels, including those not attached to any desktop, use the functions
    in hou.ui.

    See also hou.ui.curDesktop, hou.ui.desktops, hou.Pane, hou.PaneTab, and
    hou.FloatingPanel.


    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def panes(self):
        """
        panes(self) -> tuple of hou.Pane

        Return the panes inside this desktop.  Note that the result includes
        panes in floating panels as long as they are attached to the desktop.

        The following function will return all visible panes, regardless of
        whether or not they are attached to a desktop:
          def allPanes():
              '''Return a tuple of all visible panes, regardless of whether or not
                 they are attached to a desktop.'''
              # Loop through all the pane tabs and add each tab's pane to the result
              # if it's not already there.  Note that the only way to uniquely
              # identify a pane is using its id.
              ids_to_panes = {}
              for pane_tab in hou.ui.paneTabs():
                  pane = pane_tab.pane()
                  if pane.id() not in ids_to_panes:
                      ids_to_panes[pane.id()] = pane
              return ids_to_panes.values()


        REPLACES
            pane command        """
        return (Pane(),)

    def paneTabs(self):
        """
        paneTabs(self) -> tuple of hou.PaneTab

        Return the pane tabs that are contained in this desktop or are in
        floating panels attached to this desktop.

        This method does not return floating pane tabs that are not attached to
        this desktop.  Use hou.ui.paneTabs to get all the visible pane tabs,
        regardless of whether they are attached to this desktop.

        REPLACES
            pane command        """
        return (PaneTab(),)

    def floatingPaneTabs(self):
        """
        floatingPaneTabs(self) -> tuple of hou.PaneTab

        Return all the pane tabs in floating panels that are attached to this
        desktop.
        """
        return (PaneTab(),)

    def paneTabOfType(self, type, index=0):
        """
        paneTabOfType(self, type, index=0) -> hou.PaneTab or None

        Find and return the pane tab with the desired type.  If no such tab
        exists, return None.  Like hou.Desktop.paneTabs, this method searches
        pane tabs in the desktop or in floating panels attached to the desktop.

        Use hou.ui.paneTabOfType to search all the visible pane tabs, regardless
        of whether they are attached to this desktop.

        type
            A hou.paneTabType enumerated variable.

        index
            If there are multiple tabs with the desired type, this parameter
            determines which one is returned.  Use index=0 to return the first
            found tab, index=1 to return the second found tab, etc.  By default,
            index is 0.

        This method can be approximately implemented as follows:
          def paneTabOfType(self, tab_type, index=0):
              pane_tabs = [t for t in self.paneTabs() if t.type() == tab_type]

              if max(index, 0) > len(pane_tabs):
                  return None
              return pane_tabs[max(index, 0)]
        """
        return PaneTab()

    def findPaneTab(self, name):
        """
        findPaneTab(self, name) -> hou.PaneTab or None

        Return the pane tab with the given name, or None if no such tab exists.
        Like hou.Desktop.paneTabs, this method searches pane tabs in the desktop
        or in floating panels attached to the desktop.

        The name may optionally be prefixed by the desktop name and a period.

        Use hou.ui.findPaneTab to search all the visible pane tabs, regardless
        of whether they are attached to this desktop.
        """
        return PaneTab()

    def createFloatingPaneTab(self, pane_tab_type, position=(), size=()):
        """
        createFloatingPaneTab(self, pane_tab_type, position=(), size=()) ->
        hou.PaneTab

        Create and return a new floating window containing a single pane tab.
        Note that this method creates a floating panel with a single pane tab,
        and the graphical interface to add more tabs or split the pane inside
        the panel is not exposed.

        pane_tab_type
            A hou.paneTabType enumerated variable.

        position
            A tuple of two floats specifying the X and Y positions of the new
            window, respectively.  The window will open near this position, not
            necessarily exactly at this position.  If this value is an empty
            tuple, Houdini will choose a default location.

        size
            A tuple of two floats specifying the width and height of the new
            window, respectively.  If this value is an empty tuple, Houdini will
            choose a default size.

        Also note that the floating panel containing the new pane tab does not
        contain any panes: calling hou.PaneTab.pane on the pane tab returns
        None, and calling hou.FloatingPanel.panes on its floating panel returns
        an empty tuple.  See hou.FloatingPanel for more information on these
        stripped down floating panels.

        See also hou.Desktop.createFloatingPanel.

        The following example function takes a hou.Node and opens a floating
        parameter pane pinned to that node.
          def openParmPane(node):
              '''Open a floating parameter pane for a particular node.'''
              pane_tab = hou.ui.curDesktop().createFloatingPaneTab(hou.paneTabType.Parm)
              pane_tab.setCurrentNode(node)
              pane_tab.setPin(True)
              return pane_tab


        REPLACES
            pane command        """
        return PaneTab()

    # def createFloatingPane(self, pane_tab_type, position=(), size=()): return
    def floatingPanels(self):
        """
        floatingPanels(self) -> tuple of hou.FloatingPanel

        Return all the floating panels attached to this desktop.

        Use hou.ui.floatingPanels to get all the visible floating panels,
        including those not attached to this desktop.

        See also hou.Desktop.floatingPaneTabs.
        """
        return FloatingPanel()

    def createFloatingPanel(self, pane_tab_type, position=(), size=()):
        """
        createFloatingPanel(self, pane_tab_type, position=(), size=()) ->
        hou.FloatingPanel

        Create a floating panel and return it.  The returned floating panel
        contains one pane which contains one pane tab of the desired type.

        See hou.Desktop.createFloatingPaneTab for a description of the
        parameters.  This method differs from createFloatingPaneTab in two ways:
        First, it returns the floating panel instead of the pane tab.  Second,
        the floating panel that is created from this method is not locked down,
        and the user can add more pane tabs and split the panes.

        The following example creates a floating panel with a parameters pane
        tab and a channel viewer (motion viewer) pane tab:
          panel = hou.ui.curDesktop().createFloatingPanel(hou.paneTabType.Parm)
          pane1 = panel.panes()[0]
          pane2 = pane1.splitVertically()
          pane2.tabs()[0].setType(hou.paneTabType.ChannelViewer)
        """
        return FloatingPanel()

    def name(self):
        """
        name(self) -> str

        Return the desktop's name.

        Each desktop has a unique  name. The desktop's name cannot be changed
        through either the scripting interface or through Houdini.

        REPLACES
            desk command        """
        return ''

    def shelfDock(self):
        """
        shelfDock(self) -> hou.ShelfDock

        Return the shelf dock for the current desktop.
        """
        return ShelfDock()

    def displaySideHelp(self, show=True):
        """
        displaySideHelp(self, show=True) -> hou.PaneTab

        Show or hide the side help pane.

        If show is set to True (default) this method displays the help pane and
        returns a help browser pane tab.  If set to False then this method hides
        the help browser pane at the side of the desktop and returns None.
        """
        return PaneTab()

    def setAsCurrent(self):
        """
        setAsCurrent(self)

        Make this desktop the currently selected one.  See also hou.ui.desktops.

        This example changes to the animate desktop:
          desktops_dict = dict((d.name(), d) for d in hou.ui.desktops())
          desktops_dict['Animate'].setAsCurrent()

        REPLACES
            desk command        """

class Dialog(object):
    """
    hou.Dialog

    Class representing a Houdini dialog.

    This class represents only dialogs created by hou..ui.createDialog.

    Custom dialogs can be created with Houdini's User Interface Script
    Language.  An overview of the language can be found in the Houdini
    Development Kit (HDK) documentation, specifically in the "Houdini User
    Interface -> The .ui Script Language" section.
    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def destroy(self):
        """
        destroy(self)

        Delete this dialog.

        If you call methods on a Dialog instance after it has been destroyed,
        Houdini will raise hou.ObjectWasDeleted.
        """

    def setValue(self, name, value):
        """
        setValue(self, name, value)

        Set the value of the specified UI variable.

        Raises hou.TypeError if either name or value is None. Raises
        hou.OperationFailed if no UI variable with the specified name exists.
        """

    def enableValue(self, name, onoff):
        """
        enableValue(self, name, onoff)

        Enable or disable the specified UI variable.

        Set onoff to True to enable the variable. Set onoff to False to disable
        the variable.

        Raises hou.TypeError if either name is None. Raises hou.OperationFailed
        if no UI variable with the specified name exists.
        """

    def waitForValueToChangeTo(self, name, new_value):
        """
        waitForValueToChangeTo(self, name, new_value)

        Wait for the specified UI variable to change its value to new_value.

        This is a blocking call.  The method will return execution when the
        variable has changed to the desired value.  Note that Houdini will
        remain responsive even when this method is blocked waiting.

        If the variable's current value is already set to new_value then this
        method will return immediately.

        Raises hou.TypeError if name is None. Raises hou.OperationFailed if no
        UI variable with the specified name exists.
        """

    def menuItems(self, name):
        """
        menuItems(self, name) -> tuple of str

        Return the menu entries for the specified UI variable.

        Raises hou.TypeError if name is None. Raises hou.OperationFailed if no
        UI variable with the specified name exists. Raises hou.OperationFailed
        if the UI variable does not point to a menu.
        """
        return ('',)

    def setMenuItems(self, name, items):
        """
        setMenuItems(self, name, items)

        Set the menu entries in the specified UI variable.

        Raises hou.TypeError if name is None. Raises hou.OperationFailed if no
        UI variable with the specified name exists. Raises hou.OperationFailed
        if the UI variable does not point to a menu.
        """

    def value(self, name):
        """
        value(self, name)

        Return the value of the given UI variable.

        Raises hou.TypeError if name is None. Raises hou.OperationFailed if no
        UI variable with the specified name exists.
        """

    def addCallback(self, name, callback):
        """
        addCallback(self, name, callback)

        Register a callback function for the specified UI variable.

        The function is invoked when the value of the UI variable changes and
        receives no arguments.

        Raises hou.TypeError if name is None. Raises hou.OperationFailed if no
        UI variable with the specified name exists.
        """

    def removeCallback(self, name, callback):
        """
        removeCallback(self, name, callback)

        Remove the specified callback function from the UI variable.

        Raises hou.TypeError if name is None. Raises hou.OperationFailed if no
        UI variable with the specified name exists. Raises hou.OperationFailed
        if the specified callback is not registered with the UI variable.
        """

    def callbacks(self, name):
        """
        callbacks(self, name) -> tuple of callbacks

        Return all callback functions registered with the given UI variable.

        Raises hou.TypeError if name is None. Raises hou.OperationFailed if no
        UI variable with the specified name exists.
        """
        return (None,)

class dop(object):
    """
    hou.dop

    DOP related functions.

    """
    def __init__(self): raise AttributeError, "No constructor defined"
    def isScriptSolverRunning(self):
        """
        isScriptSolverRunning() -> bool

        Return whether or not a Python script solver DOP is currently running.

        This function is called from the Python code that is automatically
        generated when you create a new Python solver DOP type.
        """
        return True

    def scriptSolverData(self):
        """
        scriptSolverData() -> hou.DopData

        Return the solver solver data corresponding to the currently running
        Python script solver DOP.

        A Python script solver DOP runs in two passes.  During the first pass,
        it evaluates its node parameters and stores them in the solver data.
        During this pass, hou.dop.isScriptSolverRunning returns False and you
        can access a writable version of the script solver data with
        hou.DopNode.pythonSolverData.  During the second pass the solver is
        invoked to actually solve the objects.  During this pass,
        hou.dop.isScriptSolverRunning returns True and you use this function to
        access a read-only version of the script solver data.  You can access
        the objects being solved in this pass with
        hou.dop.scriptSolverNewObjects and hou.dop.scriptSolverObjects.

        DOP nodes attach data named "Solver" to each of the DOP objects being
        solved.  If the only solver in use is the script solver, this data will
        be of type "SIM_SolverScript".  Otherwise, this data will be of type
        "SIM_SolverMulti", and the "SIM_SolverScript" will be subdata of the
        multisolver data.  This function provides an easy way of retrieving this
        data, regardless of where it exists.

        Typically, the solver data is shared between all the objects being
        solved. For this reason, the data returned by this function is read-
        only. Otherwise, if you modified this data, the DOP engine would copy it
        and the objects being solved would not share this data.
        """
        return DopData()

    def scriptSolverNetwork(self):
        """
        scriptSolverNetwork() -> hou.Node or None

        Return the DOP network node that contains the script solver DOP that is
        currently running, or None if not script solver is running.  You would
        call this function from a script solver DOP.

        REPLACES
            dopsolvedopnet function        """
        return Node()

    def scriptSolverSimulation(self): return 
    def scriptSolverObjects(self):
        """
        scriptSolverObjects() -> tuple of hou.DopObject

        Return a tuple of DOP objects being solved by the current script solver
        DOP.  If no script solver is running, returns an empty tuple.

        REPLACES
            dopsolveobject function
            dopsolvenumobjects function        """
        return (DopObject(),)

    def scriptSolverNewObjects(self):
        """
        scriptSolverNewObjects() -> tuple of hou.DopObject

        Return a tuple of newly-created DOP objects to later be solved by the
        current script solver DOP.  If no script solver is running, returns an
        empty tuple.

        REPLACES
            dopsolvenewobject function
            dopsolvenumnewobjects function        """
        return (DopObject(),)

    def scriptSolverTimestepSize(self):
        """
        scriptSolverTimestepSize() -> float

        Return the timestep size for the script solver that is currently
        running, or 0.0 if no script solver is running.

        REPLACES
            dopsolvetimestep function        """
        return 0.0

    def scriptSolverTime(self): return 

class DopNode(Node):
    """
    hou.DopNode

    Represents a dynamics node.
    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def dopNetNode(self):
        """
        dopNetNode(self) -> hou.Node

        Return the DOP network node that contains this DOP node.
        """
        return Node()

    def simulation(self):
        """
        simulation(self) -> hou.DopSimulation

        Return the simulation that this node contributes to.  This method is a
        shortcut for self.dopNetNode().simulation().
        """
        return DopSimulation()

    def processedObjects(self):
        """
        processedObjects(self) -> tuple of hou.DopObject

        Return a tuple of DOP objects that this DOP node processes.
        """
        return (DopObject(),)

    def createdObjects(self):
        """
        createdObjects(self) -> tuple of hou.DopObject

        Return a tuple of DOP objects that this DOP node creates.

        REPLACES
            dopobjscreatedby function        """
        return (DopObject(),)

    def isBypassed(self):
        """
        isBypassed(self) -> bool

        Returns whether the node's bypass flag is on.

        REPLACES
            opflag function        """
        return True

    def bypass(self, on):
        """
        bypass(self, on)

        Turn the node's bypass flag on or off, making this node have no effect.
        """

    def isDisplayFlagSet(self):
        """
        isDisplayFlagSet(self) -> bool

        Return whether this node's display flag is on.

        REPLACES
            opget command        """
        return True

    def setDisplayFlag(self, on):
        """
        setDisplayFlag(self, on)

        Turn the node's display flag on or off.

        REPLACES
            opset command        """

    def displayNode(self):
        """
        displayNode(self) -> hou.Node or None

        If this node is a subnet (i.e. it contains child nodes), return the
        child that has its display flag set, or None if there are no children.
        Otherwise, return None.
        """
        return Node()

    def renderNode(self): return Node()
    def objectsToProcess(self):
        """
        objectsToProcess(self) -> tuple of hou.DopObject

        Return a tuple of DOP objects that this node should process.  Raises
        hou.PermissionError if called from outside a DOP implemented in Python.
        """
        return (DopObject(),)

    def pythonSolverData(self):
        """
        pythonSolverData(self) -> hou.DopData

        If this node is a Python DOP solver, return the solver data added to the
        DOP network by this node.  Otherwise, raises hou.PermissionError.

        This method is called from Python DOP solvers when the solver is not
        running, to copy data from the DOP parameters into the solver data.

        See also hou.dop.scriptSolverData.
        """
        return DopData()

class DopObject(DopData):
    """
    hou.DopObject

    A type of DOP data that contains an object in the simulation.

    This object might be a rigid body, a fluid, cloth, etc.  The type and
    properties of the DOP object are determined by the subdata attached to
    the object.
    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def name(self):
        """
        name(self) -> str

        Return the name of this DOP object.

        REPLACES
            dopnodeobjs function        """
        return ''

    def objid(self):
        """
        objid(self) -> int

        Return the index of this object in the output from
        hou.DopSimulation.objects.  This method is a shortcut for
        self.options().field("objid").

        See hou.DopData.id for an example.

        Some fields in DOP records store an objid to refer to other objects. The
        following function looks up an object by objid:
          def findObjectByObjid(dopnet_node, objid):
              return dopnet_node.simulation().objects()[objid]
        """
        return 0

    def matches(self, pattern):
        """
        matches(self, pattern) -> bool

        Return whether or not this object's name matches a pattern.  * will
        match any number of characters and ? will match any single character.
        The pattern string contains only one pattern, so spaces in the pattern
        will be compared against the object name.

          >>> obj = hou.node("/obj/AutoDopNetwork").simulation().objects()[0]
          >>> obj.name()
          'box_object1'
          >>> obj.matches("box*")
          True
          >>> obj.matches("c*")
          False
          >>> obj.matches("box* b*")
          False
          >>> obj.matches("b?x_object1")
          True
        """
        return True

    def transform(self, include_geometry_transform=True):
        """
        transform(self, include_geometry_transform=True) -> hou.Matrix4

        Return the transformation matrix for this object.  If
        include_geometry_transform is False, the result is determined only by
        the object's Position data.  Otherwise, it is the transform in the
        object's Geometry data, followed by the position transform.

        For simple DopData types, this method can be approximately implemented
        as follows:
          def transform(self, include_geometry_transform=True):
              result = hou.hmath.identityTransform()

              geometry = self.findSubData("Geometry")
              if include_geometry_transform and geometry is not None:
                  result *= geometry.record("Transform").field("transform")

              # Retrieve the position.  If there is Geometry data, use its
              # positionpath field to get the SIM_Position subdata.  If not, look
              # for data named Position.
              position = None
              if geometry is not None:
                  position = geometry.findSubData(
                      geometry.options().field("positionpath"))
              if position is None:
                  position = self.findSubData("Position")

              # If we found position data, build a transformation from the pivot,
              # rotation quaternion, and translate.
              if position is not None:
                  options = position.options()
                  rotation = hou.Matrix4(options.field("orient").extractRotationMatrix3())
                  result *= (hou.hmath.buildTranslate(-options.field("p")) *
                      rotation *
                      hou.hmath.buildTranslate(options.field("p")) *
                      hou.hmath.buildTranslate(options.field("t")))

              return result


        REPLACES
            doptransform function        """
        return Matrix4()

    def geometry(self, name="Geometry"):
        """
        geometry(self, name="Geometry") -> hou.Geometry or None

        If this DOP object has SIM_Geometry subdata with the given name, return
        its corresponding read-only hou.Geometry object.  Otherwise, this method
        returns None.
        """
        return Geometry()

    def editableGeometry(self, name="Geometry"):
        """
        editableGeometry(self, name="Geometry") ->
        hou.EditableDopGeometryGuard or None

        If this method is called from a Python solver DOP and it has
        SIM_Geometry (or SIM_GeometryCopy) subdata with the given name, it
        returns a Python guard object that can be used with the "with"
        statement to access and modify the corresponding hou.Geometry object.

        In Python 2.5, the with statement is not enabled by default.  To enable
        it, you need to add the following line at the beginning of your
        script/module:
          from __future__ import with_statement


        For example, the following code in a Python solver DOP will add a point
        at the origin of the geometry:
          with dop_object.editableGeometry() as geo:
              geo.createPoint()


        Raises hou.PermissionError if not called from a Python solver DOP.
        """
        return EditableDopGeometryGuard()

class DopRecord(object):
    """
    hou.DopRecord

    A table of values stored inside a DopData.

    See hou.DopData for a description of DOP data, records, and fields.
    """
    def __init__(self): raise AttributeError, "No constructor defined"
    def recordType(self):
        """
        recordType(self) -> str

        Return the name of this record.  See hou.DopData.recordTypes for more
        information.
        """
        return ''

    def recordIndex(self):
        """
        recordIndex(self) -> int

        Return the index of this record.  See hou.DopData.record and
        hou.DopData.records for more information.
        """
        return 0

    def fieldNames(self):
        """
        fieldNames(self) -> tuple of str

        Return the names of all the fields inside this record.  See
        hou.DopRecord.field for an example.

        REPLACES
            dopallfields function
            dopfieldname function
            dophasfield function
            dopnumfields function        """
        return ('',)

    def fieldType(self, field_name):
        """
        fieldType(self, field_name) -> hou.fieldType enum value

        Return a hou.fieldType enumerated value that describes the type of data
        stored in a field.  Returns hou.fieldType.NoSuchField if no field exists
        with that name.

        See hou.DopRecord.field for an example.

        REPLACES
            dopfieldtype function
            dophasfield function        
        """
        return fieldType()

    def field(self):
        """
        field(self) -> int, bool, float, str, hou.Vector2, hou.Vector3,
        hou.Vector4, hou.Quaternion, hou.Matrix3, or hou.Matrix4

        Return the value of a field inside this record, or None if no such field
        exists.

        Note that you can add the suffixes "x", "y", and "z" to a vector
        field's name to access the individual float values.

          # The following code assumes you have created a box from the shelf and used
          # Rigid Bodies > RBD Object on the shelf to make it a rigid body.
          >>> record = hou.node("/obj/AutoDopNetwork").simulation().findData("box_object1/Forces/Gravity_gravity1").options()
          >>> record.fieldNames()
          ('force', 'handlepos')
          >>> record.field("force")
          <hou.Vector3 [0, -9.80665, 0]>
          >>> record.field("forcey")
          -9.8066501617431641
          >>> record.fieldType("force")
          fieldType.Vector3
          >>> record.fieldType("forcey")
          fieldType.Float

        This example function creates a dict out of a record:
          def recordAsDict(record):
              return dict((field_name, record.field(field_name))
                  for field_name in record.fieldNames())


        The following function returns the geometry transform of an object:
          def dopGeometryTransform(dopnet_node, object_name):
              subdata = dopnet_node.simulation().findObject(object_name).findSubData("Geometry")
              return subdata.record("Transform").field("transform")


        REPLACES
            dopfield function
            dopfields function        """

    def setFieldBool(self, field_name, value):
        """
        setFieldBool(self, field_name, value)

        Set a field to the specified boolean value.  You would call this method
        from a script solver DOP.

        To set a field to a different type, use hou.DopRecord.setField.

        Raises hou.PermissionError if called from outside a script solver DOP.

        REPLACES
            dopsolvesetoption command        """

    def setField(self, field_name, value):
        """
        setField(self, field_name, value)

        Set a field to the specified value.  You would call this method from a
        script solver DOP.  value may be an int, float, str, hou.Vector2,
        hou.Vector3, hou.Vector4, hou.Quaternion, hou.Matrix3, or hou.Matrix4.

        Unfortunately, this method cannot be used to set a field to a boolean
        (True or False) value.  If you pass a boolean to this method, it will
        set the field to the integer 1 or 0.  To properly set it to a boolean
        value, use hou.DopRecord.setFieldBool.

        Raises hou.PermissionError if called from outside a script solver DOP.

        REPLACES
            dopsolvesetoption command        """

class DopRelationship(DopData):
    """
    hou.DopRelationship

    A type of DOP data that stores which DOP objects affect one another.

    In addition to the "Basic" and "Options" records, a DopRelationship
    contains "ObjInAffectors" and "ObjInGroup" records.  The former
    contains the objects doing the affecting and the latter contains the
    objects being affected.

    See hou.DopSimulation.relationships for an example.
    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def name(self):
        """
        name(self) -> str

        Return the name of this DOP relationship.
        """
        return ''

    def matches(self, pattern):
        """
        matches(self, pattern) -> bool

        Return whether or not this relationship's name matches a pattern.  See
        hou.DopObject.matches for more information.
        """
        return True

    def setGroup(self, objects):
        """
        setGroup(self, objects)

        Sets the list of objects that are being affected. This corresponds to
        the "ObjInGroup" record.

        objects: A list of DOP objects.

        Raises hou.PermissionError if called from outside a Python DOP.
        """

    def setAffectorGroup(self, objects):
        """
        setAffectorGroup(self, objects)

        Sets the list of objects that are doing the affecting. This corresponds
        to the "ObjInAffectors" record.

        objects: A list of DOP objects.

        Raises hou.PermissionError if called from outside a Python DOP.
        """

class DopSimulation(object):
    """
    hou.DopSimulation

    A dynamics simulation contained inside a DOP network node.

    See hou.DopData for more information about the contents of a DOP
    simulation.  Note that methods of this class implicitly use the
    simulation data from the current frame.
    """
    def __init__(self): raise AttributeError, "No constructor defined"
    def createObject(self, name, solve_on_creation_frame):
        """
        createObject(self, name, solve_on_creation_frame) -> hou.DopObject

        Create and return a new DOP object, or return None if the object was not
        created successfully.

        name
            The name of the new object.

        solve_on_creation_frame
            If True, the object will be solved on its first frame of existance.

        Raises hou.PermissionError if called from outside a Python DOP.

        Use hou.DopData.copyContentsFrom to clone data from an existing object.
        """
        return DopObject()

    def removeObject(self, object):
        """
        removeObject(self, object)

        Remove the given DOP object from the simulation.

        object
            The hou.DopObject to remove.

        Raises hou.PermissionError if called from outside a Python DOP.
        """
    def createRelationship(self, name):
        """
        createRelationship(self, name) -> hou.DopRelationship

        Create and return a new DOP relationship, or return None if the
        relationship was not created successfully.

        name
            The name of the new relationship.

        Raises hou.PermissionError if called from outside a Python DOP.

        Use hou.DopData.copyContentsFrom to clone data from an existing
        relationship, and use hou.DopRelationship.setGroup and
        hou.DopRelationship.setAffectorGroup to update the "ObjInGroup" and
        "ObjInAffectors" records.
        """
        return DopRelationship()

    def removeRelationship(self, rel):
        """
        removeRelationship(self, rel)

        Remove the given DOP relationship from the simulation.

        rel
            The hou.DopRelationship to remove.

        Raises hou.PermissionError if called from outside a Python DOP.
        """

    def dopNetNode(self):
        """
        dopNetNode(self) -> hou.Node

        Return the DOP network node containing this simulation.
        """
        return Node()

    def objects(self):
        """
        objects(self) -> tuple of hou.DopData

        Return a tuple of all the DOP objects in the simulation.

        You cannot index into this list using the object ID (see
        hou.DopObject.objid). To create a dictionary mapping object IDs to
        hou.DopObjects, do this:

          id_dict = dict((obj.objid(), obj) for obj in simulation.objects())

        REPLACES
            dopnumobjects function
            dopnodeobjs function        """
        return DopData()

    def relationships(self):
        """
        relationships(self) -> tuple of hou.DopRelationship

        Return a tuple of hou.DopRelationship objects for all the DOP
        relationships in the simulation.

          # The following example assumes you have created two box objects and made
          # them rigid bodies.
          >>> simulation = hou.node("/obj/AutoDopNetwork").simulation()
          >>> relationship = simulation.relationships()[1]
          >>> affecting_objects = [
          ...     simulation.objects()[record.field("objid")]
          ...     for record in relationship.records("ObjInAffectors")]
          >>> [obj.name() for obj in affecting_objects]
          ['box_object1']
          >>> affected_objects = [
          ...     simulation.objects()[record.field("objid")]
          ...     for record in relationship.records("ObjInGroup")]
          >>> [obj.name() for obj in affected_objects]
          ['box_object2']
        """
        return (DopRelationship(),)

    def findObject(self, obj_spec):
        """
        findObject(self, obj_spec) -> hou.DopObject or None

        Return the DOP object with the given name, or None if no object exists
        with that name.  See also hou.DopSimulation.findData and
        hou.DopSimulation.objects.
        """
        return DopObject()

    def findRelationship(self, rel_spec):
        """
        findRelationship(self, rel_spec) -> hou.DopRelationship

        Find a DOP relationship by name.  Return None if no such relationship
        with that name exists.  See also hou.DopSimulation.relationships.
        """
        return DopRelationship()

    def findData(self, data_spec):
        """
        findData(self, data_spec) -> hou.DopData or None

        Return the DOP data with the given name.  Note that the name may also be
        a slash-separated path to nested subdata.

        If the data path refers to a DOP object, this method returns a
        hou.DopObject instance.  If it refers to a DOP relationship, it returns
        a hou.DopRelationship instance.  Otherwise, it returns a hou.DopData
        instance.

        Note this method implicitly uses the simulation data from the current
        frame.

        See also hou.DopData.findSubData.
        """
        return DopData()

    def findAllObjects(self, obj_spec):
        """
        findAllObjects(self, obj_spec) -> tuple of hou.DopObject

        Given a pattern, return a tuple of DOP objects whose names match the
        pattern.

          >>> simulation = hou.node("/obj/AutoDopNetwork").simulation()
          >>> [obj.name() for obj in simulation.findAllObjects("box_object?")]
          ['box_object1', 'box_object2']
          >>> [obj.name() for obj in simulation.findAllObjects("o* b*")]
          ['obj1', 'obj2', 'box_object1', 'box_object2']

        REPLACES
            dopobjectlist function        """
        return (DopObject(),)

    def findAllRelationships(self, rel_spec):
        """
        findAllRelationships(self, rel_spec) -> tuple of hou.DopRelationship

        Return a tuple of hou.DopRelationship objects whose names match a
        pattern.  See also hou.DopSimulation.relationships and
        hou.DopSimulation.findRelationship.
        """
        return (DopRelationship(),)

    def findAllData(self, data_spec):
        """
        findAllData(self, data_spec) -> tuple of hou.DopData

        Given a pattern, return a tuple of DOP data whose names match the
        pattern. See also hou.DopSimulation.findData.
        """
        return (DopData(),)

    def time(self):
        """
        time(self)

        Return the simulation's current time.  This value is often the same as
        hou.time, unless it is called from a Python solver DOP or the Time Scale
        or Offset Time parameters of the DOP network have been changed from
        their default values.

        REPLACES
            doptime function        """

    def memoryUsage(self):
        """
        memoryUsage(self)

        Return the simulation's total memory usage.
        """

class Edge(object):
    """
    hou.Edge

    Each Edge object resides inside a Geometry object and stores an edge.
    Edges are reprsented as pairs of points.


    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def geometry(self): return Geometry()
    def points(self):
        """
        points(self) -> tuple of hou.Point

        Return a tuple of the points that make up this edge.
        """
        return (Point(),)

    def edgeId(self):
        """
        edgeId(self) -> str

        Return a string such as p8-9 that identifies the edge
        """
        return ''

    def length(self):
        """
        length(self) -> float

        Returns the length of this edge
        """
        return 0.0

    def prims(self):
        """
        prims(self) -> tuple of hou.Prim

        Return a tuple of the prims that has this edge
        """
        return (Prim(),)

class EdgeGroup(object):
    """
    hou.EdgeGroup

    A named group of edges inside a Geometry object.

    Edge groups reside inside the geometry, and each edge group has a unique
    name.

    See hou.Edge for more information about edges.  See also hou.PrimGroup
    and hou.PointGroup.

    REPLACES

    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def geometry(self):
        """
        geometry(self) -> hou.Geometry

        Return the geometry object containing this group.
        """
        return Geometry()

    def name(self):
        """
        name(self)

        Return the name of the group.  Each edge group has a unique name.
        """

    def edges(self):
        """
        edges(self) -> tuple of hou.Edge

        Return the contents of this group.
        """
        return (Edge(),)

    def contains(self, edge):
        """
        contains(self, edge) -> bool

        Return whether or not an edge is in this group.

        Raises hou.OperationFailed if the edge belongs to a different geometry
        object than this group.
        """
        return True

    def add(self, edge_or_list_or_edge_group):
        """
        add(self, edge_or_list_or_edge_group)

        If given a hou.Edge or a list of hou.Edge's, add the edge(s) to the
        group.  If given a hou.EdgeGroup, merge the contents of the other edge
        group with this group (the other group is unaffected).  You would
        typically call this method from the code of a Python-defined SOP.

        It is ok to add edges to the group that were already in the group.

        Raises hou.GeometryPermissionError if this geometry is not modifiable.

        Raises hou.OperationFailed if the edge or edge group belong to a
        different geometry object than this group.
        """

    def remove(self, edge_or_list_or_edge_group):
        """
        remove(self, edge_or_list_or_edge_group)

        If given a hou.Edge or a list of hou.Edge's, remove the edge(s) from the
        group.  If given a hou.EdgeGroup, remove all edges in the other group
        from this group (the other group is unaffected).  You would typically
        call this method from the code of a Python-defined SOP.

        It is not an error to try to remove an edge from the group that wasn't
        already in the group.

        Raises hou.GeometryPermissionError if this geometry is not modifiable.

        Raises hou.OperationFailed if the edge belongs to a different geometry
        object than this group.
        """

    def clear(self): return
    def destroy(self):
        """
        destroy(self)

        Remove this group from the geometry.  You would typically call this
        method from the code of a Python-defined SOP.

        Raises hou.GeometryPermissionError if this geometry is not modifiable.
        """

class EditableDopGeometryGuard(object):

    def __init__(self): raise AttributeError, "No constructor defined"
    def __enter__(self): return
    def __exit__(self): return

class FloatingPanel(object):
    """
    hou.FloatingPanel

    A floating window that contains one or more panes.

    Much like a desktop, a floating panel contains panes.  A floating panel
    may be attached to a desktop, in which case it is saved with the
    desktop, hidden when the desktop is closed, and shown when the desktop
    is opened. You can use floating panels to create desktops that span
    multiple monitors.

    When you create a new floating panel, for example, it contains a single
    pane, which in turn contains a single pane tab showing the network
    editor.

    Note that a floating panel may be locked to one particular pane tab.
    These stripped down panels do not display the interface for adding new
    pane tabs or splitting panes.  In fact, these stripped down floating
    panels do not contain any panes at all, and hou.FloatingPanel.panes will
    return an empty tuple. You can create such a stripped down floating
    panel with hou.Desktop.createFloatingPaneTab.

    See hou.Desktop for more information about panes and pane tabs.
    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def panes(self):
        """
        panes(self) -> tuple of hou.Pane

        Return all the panes inside the panel.  As mentioned in the
        documentation for this class, a floating panel may be stripped down and
        locked to one particular pane tab, and these stripped down floating
        panels do not contain any panes.
        """
        return (Pane(),)

    def paneTabs(self):
        """
        paneTabs(self) -> tuple of hou.PaneTab

        Return all the pane tabs that are in this floating panel, regardless of
        which pane they are in.
        """
        return (PaneTab(),)

    def paneTabOfType(self, type, index=0):
        """
        paneTabOfType(self, type, index=0) -> hou.PaneTab or None

        Find and return the pane tab with the desired type or None if no such
        pane tab exists.

        type
            A hou.paneTabType enumerated variable.

        index
            If there are multiple tabs with the desired type, this parameter
            determines which one is returned.  Use index=0 to return the first
            found tab, index=1 to return the second found tab, etc.  By default,
            index is 0.
        """
        return PaneTab()

    def findPaneTab(self, name):
        """
        findPaneTab(self, name) -> hou.PaneTab or None

        Return the pane tab with the given name, or None if no such tab exists.
        """
        return PaneTab()

    def name(self):
        """
        name(self) -> str

        Return the name of the floating panel.  The panel's name is displayed in
        its window's title.
        """
        return ''

    def setName(self, name):
        """
        setName(self, name)

        Set this panel's name.  Any characters in the name that are not letters,
        numbers, or underscores are replaced with underscores.

        Raises hou.OperationFailed if the name is an empty string.
        """

    def containsPlaybar(self):
        """
        containsPlaybar(self) -> bool

        Return whether or not this panel contains Houdini's playbar.

        See also hou.FloatingPanel.setContainsPlaybar.
        """
        return True

    def setContainsPlaybar(self, on):
        """
        setContainsPlaybar(self, on)

        If on is True, move Houdini's playbar to this panel.  Otherwise, move it
        back to the main desktop window.

        See also hou.FloatingPanel.containsPlaybar.
        """

    def containsShelf(self):
        """
        containsShelf(self) -> bool

        Return whether or not this panel contains Houdini's shelf.

        See also hou.FloatingPanel.setContainsShelf.
        """
        return True

    def setContainsShelf(self, on):
        """
        setContainsShelf(self, on)

        If on is True, move Houdini's shelf to this panel.  Otherwise, move it
        back to the main desktop window.

        See also hou.FloatingPanel.containsShelf.
        """

    def containsStatusBar(self):
        """
        containsStatusBar(self) -> bool

        Return whether or not this panel contains Houdini's status bar (the bar
        at the bottom of the desktop for status messages).

        See also hou.FloatingPanel.setContainsStatusBar.
        """
        return True

    def setContainsStatusBar(self, on):
        """
        setContainsStatusBar(self, on)

        If on is True, move Houdini's status bar to this panel.  Otherwise, move
        it back to the main desktop window.

        See also hou.FloatingPanel.containsStatusBar.
        """

    def containsMenuBar(self):
        """
        containsMenuBar(self) -> bool

        Return whether or not this panel contains Houdini's main menu bar.

        See also hou.FloatingPanel.setContainsMenuBar.
        """
        return True

    def setContainsMenuBar(self, on):
        """
        setContainsMenuBar(self, on)

        If on is True, move Houdini's main menu bar to this panel.  Otherwise,
        move it back to the main desktop window.

        See also hou.FloatingPanel.containsMenuBar.
        """

    def isAttachedToDesktop(self):
        """
        isAttachedToDesktop(self) -> bool

        Return whether or not this panel is attached to the desktop.  Panels
        attached to the desktop are saved with the desktop and are opened when
        the desktop is opened and closed when the desktop is closed.

        See also hou.FloatingPanel.attachToDesktop.
        """
        return True

    def attachToDesktop(self, on):
        """
        attachToDesktop(self, on)

        Attach this panel to the desktop.  See
        hou.FloatingPanel.isAttachedToDesktop for more information.
        """

    def isFullscreen(self):
        """
        isFullscreen(self) -> bool

        Return whether or not this panel is in full screen mode.

        See also hou.FloatingPanel.setIsFullscreen.
        """
        return True

    def setIsFullscreen(self, on):
        """
        setIsFullscreen(self, on)

        Set whether or not this panel is in full screen mode.

        See also hou.FloatingPanel.isFullscreen.
        """

    def close(self):
        """
        close(self)

        Close the floating panel's window, closing all the pane tabs inside it.
        """
    def position(*args):
        """
        Return the desktop position (in pixels) of the floating panel window.
        """
        return Vector2()

    def setPosition(self, pos):
        """
        Move the floating panel window to the specified desktop position (in
        pixels).
        Raise if position does not contain exactly two values.
        """
        pass

    def size(*args):
        """
        Return the floating panel window's size (in pixels).
        """
        return Vector2()

    def setSize(self, size):
        """
        Resize the floating panel window (in pixels).
        Raise if size does not contain exactly two values. Raise if size
        contains a value that is less than or equal to zero.
        """
        pass

class FloatParmTemplate(ParmTemplate):
    """
    hou.FloatParmTemplate

    Describes a parameter tuple containing floating point values.
    """
    def __init__(self, name, label, num_components, default_value=(), min=0.0,
        max=10.0, min_is_strict=False, max_is_strict=False,
        look=hou.parmLook.Regular, naming_scheme=hou.parmNamingScheme.XYZW,
        disable_when=None, is_hidden=False, is_label_hidden=False,
        join_with_next=False, help=None, script_callback=None,
        script_callback_language=hou.scriptLanguage.Hscript, tags={},
        default_expression=(), default_expression_language=()):
        """
        __init__(self, name, label, num_components, default_value=(), min=0.0,
        max=10.0, min_is_strict=False, max_is_strict=False,
        look=hou.parmLook.Regular, naming_scheme=hou.parmNamingScheme.XYZW,
        disable_when=None, is_hidden=False, is_label_hidden=False,
        join_with_next=False, help=None, script_callback=None,
        script_callback_language=hou.scriptLanguage.Hscript, tags={},
        default_expression=(), default_expression_language=())

        Construct a new FloatParmTemplate.

        name
            See hou.ParmTemplate.name for more information.

        label
            See hou.ParmTemplate.label for more information.

        num_components
            See hou.ParmTemplate.numComponents for more information.

        default_value
            See the defaultValue method for more information.

        min
            See the minValue method for more information.

        max
            See the maxValue method for more information.

        min_is_strict
            See the minIsStrict method for more information.

        max_is_strict
            See the maxIsStrict method for more information.

        look
            See hou.ParmTemplate.look for more information.

        naming_scheme
            See hou.ParmTemplate.namingScheme for more information.

        disable_when
            See hou.ParmTemplate.disableWhen for more information.

        is_hidden
            See hou.ParmTemplate.isHidden for more information.

        is_label_hidden
            See hou.ParmTemplate.isLabelHidden for more information.

        join_with_next
            See hou.ParmTemplate.joinsWithNext for more information.

        help
            See hou.ParmTemplate.help for more information.

        script_callback
            See hou.ParmTemplate.scriptCallback for more information.

        script_callback_language
            See hou.ParmTemplate.scriptCallbackLanguage for more information.

        tags
            See hou.ParmTemplate.tags for more information.

        default_expression
            See the defaultExpression method for more information.

        default_expression_language
            See the defaultExpressionLanguage method for more information.
        """
    def minValue(self):
        """
        minValue(self) -> float

        Return the minimum value of the parameter.

        See also the minIsStrict method.
        """
        return 0.0

    def setMinValue(self, min_value):
        """
        setMinValue(self, min_value)

        Set the minimum value of the parameter.

        See the minValue method for more information.
        """

    def maxValue(self):
        """
        maxValue(self) -> float

        Return the minimum value of the parameter.

        See also the minIsStrict method.
        """
        return 0.0

    def setMaxValue(self, max_value):
        """
        setMaxValue(self, max_value)

        Set the maximum value of the parameter.

        See the maxValue method for more information.
        """

    def minIsStrict(self):
        """
        minIsStrict(self) -> bool

        Return whether the minimum value is strictly enforced.

        If a minimum value is not strictly enforced, the slider will not let you
        change the value below the minimum, but you can set the value to be
        lower than the minimum by typing it in, changing it via
        hou.Parm.setValue, or using the ladder handle.

        If it is strictly enforced and you try to change it below the minimum
        value using any mechanism, Houdini will set it to the minimum value.

        See also the minValue method.
        """
        return True

    def setMinIsStrict(self, on):
        """
        setMinIsStrict(self, on)

        Set whether the minimum value is strictly enforced.

        See the minIsStrict method for more information.
        """

    def maxIsStrict(self):
        """
        maxIsStrict(self) -> bool

        Return whether the maximum value is strictly enforced.

        See the minIsStrict method for more information.
        """
        return True

    def setMaxIsStrict(self, on):
        """
        setMaxIsStrict(self, on)

        Set whether the maximum value is strictly enforced.

        See the maxIsStrict method for more information.
        """

    def defaultValue(self):
        """
        defaultValue(self) -> tuple of float

        Return the default value for new parameter instances.

        For example, suppose this parm template is named "t", the naming
        scheme is XYZW, it has 3 components, and the default value is (1.0, 2.0,
        3.0). The corresponding parm tuple instance on a node would be named
        "t" and would contain parameters "tx", "ty", and "tz".  When the
        node is created, "tx" would be 1.0, "ty" would be 2.0, and "tz"
        would be 3.0.
        """
        return (0.0,)

    def setDefaultValue(self, default_value):
        """
        setDefaultValue(self, default_value)

        Set the default value for new parameter instances to a sequence of
        floats.

        See the defaultValue method for more information.  Note that if the
        number of floats in the sequence is different from the number of
        components in the parm template, any extra values will be discarded and
        any missing values will become zeros.
        """

    def defaultExpression(self):
        """
        defaultExpression(self) -> tuple of strings

        Return the default expression for new parameter instances.

        The default expression takes precendence over the default value. If a
        component has no default expression (i.e. an empty string), then the
        default value is used for new parameter instances.

        Note that the default expression language is needed to interpret the
        meaning of the default expression.

        For example, suppose this parm template is named "t", the naming
        scheme is XYZW, it has 3 components, the default value is (1.0, 2.0,
        3.0), the default expression is ("$F", "hou.frame()", "") and the
        default expression language is (hou.scriptLanguage.Hscript,
        hou.scriptLanguage.Python, hou.scriptLanguage.Hscript). Then the
        corresponding parm tuple instance on a node would be named "t" and
        would contain parameters "tx", "ty", "tz".  When the node is
        created, "tx" would have a default Hscript expression of "$F",
        "ty" would have a default Python expression of "hou.frame()", and
        "tz" would have a default value of 3.0.
        """
        return ('',)

    def setDefaultExpression(self, default_expression):
        """
        setDefaultExpression(self, default_expression)

        Set the default expression for new parameter instances to a sequence  of
        strings.

        See the hou.FloatParmTemplate.defaultExpression method  for more
        information.  Note that if the number of strings in the sequence  is
        different from the number of components in the parm template,  any extra
        values will be discarded and any missing expressions will become the
        empty string.
        """

    def defaultExpressionLanguage(self):
        """
        defaultExpressionLanguage(self) -> tuple of hou.scriptLanguage

        Return the default expression language for new parameter instances.

        The default expression language only applies if the default expression
        is set.  If the default expression of a component is not set, then the
        expression language is set to hou.scriptLanguage.Hscript.
        """
        return (scriptLanguage(),)

    def setDefaultExpressionLanguage(self, default_expression_language):
        """
        setDefaultExpressionLanguage(self, default_expression_language)

        Set the default expression language for new parameter instances  to a
        sequence of hou.scriptLanguage values.

        See the defaultExpressionLanguage method for more information.   Note
        that if the number of hou.scriptLanguage values in the sequence  is
        different from the number of components in the parm template,  any extra
        values will be discarded and any missing expression languages  will
        become hou.scriptLanguage.Hscript.
        """

class FolderParmTemplate(ParmTemplate):
    """
    hou.FolderParmTemplate

    Describes a folder in a parameter dialog.

    Unlike all other hou.ParmTemplate subclasses, a folder does not
    correspond to an individual hou.ParmTuple.  Instead, the set of adjacent
    folders form a folder set, and there is one parameter for this set that
    controls which folder is currently visible.  These folder sets
    correspond to hou.FolderSetParmTemplate objects.

    Folder parm template objects are useful when manipulating the parameter
    interface of a node or a digital asset definition.  Unlike folder set
    parm templates, they contain the parm templates inside the folder.  They
    also let you add, remove, or hide an individual folder or move it from
    set one to another using hou.ParmTemplateGroup objects.  Doing these
    individual folder-level operations is not possible with folder set parm
    templates.

    Note that folder parm templates are also used to represent multiparm
    blocks, much like the <Type Properties> dialog does.  The folder parm
    template's hou.folderType determines whether it is a folder or a
    multiparm block.   Unlike folder parm templates, which do not correspond
    directly to parameter instances, a multiparm parm template does
    correspond to an integer parameter that controls the number of instances
    of the multiparm.
    """
    def __init__(name, label, parm_templates=(),
        folder_type=hou.folderType.Tabs, is_hidden=False, ends_tab_group=False,
        tags={}):
        """
        __init__(name, label, parm_templates=(),
        folder_type=hou.folderType.Tabs, is_hidden=False, ends_tab_group=False,
        tags={})

        Create a new folder parm template.

        name
            The internal name of the parm template.  Normally, parm template
            names correspond directly to parm tuples on nodes.  However, because
            folder sets, not folders, correspond directly to parm tuples, the
            name used for the folder set parm tuple is the name of the first
            folder parm template in the set of adjacent folder parm templates.

        label
            The name of the folder that is displayed in the parameter dialog.

        parm_templates
            A sequence of hou.ParmTemplate subclass objects for the parameters
            inside the folder.  Folders may be nested in other folders by
            putting FolderParmTemplates in this sequence.

        folder_type
            A hou.folderType enumerated value controlling whether the parameter
            is a folder or a multiparm block.  This value controls the look of
            the folder/multiparm instance.

        is_hidden
            Whether or not this folder is hidden.

        ends_tab_group
            If True, this folder will be the last in the folder set, even if the
            next parameter is also a folder.  In that case, the next parameter
            will begin a new folder set.

        tags
            A dictionary of extra information attached to the parm template.
        """
    def folderStyle(self): return 
    def folderType(self):
        """
        folderType(self) -> hou.folderType enum value

        Return the type of folder.  Note that the folder may actually be a
        multiparm block.
        """
        return folderType()

    def setFolderType(self, folder_type):
        """
        setFolderType(self, folder_type)

        Set the type of folder to a hou.folderType enum value.
        """

    def isActualFolder(self):
        """
        isActualFolder(self) -> bool

        Return whether or not this parm template corresponds to an actual
        folder, as opposed to a multiparm or import block.

        This method can be implemented as follows:
          def isActualFolder(self):
              return self.folderType() in (
                  hou.folderType.Tabs, hou.folderType.RadioButtons)
        """
        return True

    def defaultValue(self):
        """
        defaultValue(self) -> int

        Return the integer default value.

        The default value is only used for folders that are multiparm blocks,
        and controls the default number of multiparm instances in newly created
        nodes.
        """
        return 0

    def setDefaultValue(self, default_value):
        """
        setDefaultValue(self, default_value)

        Set the default value to an integer.

        The default value is only used for folders that are multiparm blocks.
        See the defaultValue method for more information.
        """

    def endsTabGroup(self):
        """
        endsTabGroup(self) -> bool

        Return whether this folder will be the last in the folder set, even if
        the next parameter is also a folder.  In that case, the next parameter
        will begin a new folder set.

        This parameter only has meaning if the parm template is for an actual
        folder and not for a multiparm block.
        """
        return True

    def setEndsTabGroup(self): return
    def parmTemplates(self):
        """
        parmTemplates(self) -> tuple of hou.ParmTemplate

        Return a tuple of copies of the parm templates stored inside this
        folder.

        Because copies are returned, you cannot change the contents of the parm
        templates inside this folder by modifying the parm templates returned.
        Instead, use methods in hou.ParmTemplateGroup to modify parm templates
        in this folder.
        """
        return (ParmTemplate(),)

    def setParmTemplates(self, parm_templates):
        """
        setParmTemplates(self, parm_templates)

        Replace the parm templates inside this folder with a new sequence of
        parm templates.
        """

    def addParmTemplate(self, parm_template):
        """
        addParmTemplate(self, parm_template)

        Append a parm template to the end of the list of parm templates inside
        the folder.

        Note that hou.ParmTemplateGroup provides a number of methods to insert
        parm templates inside folders, including
        hou.ParmTemplateGroup.appendToFolder.
        """

class FolderSetParmTemplate(ParmTemplate):
    """
    hou.FolderSetParmTemplate

    Describes a set of folders.

    A folder set is a group of adjacent folders, and only one of those
    folders can be displayed at a time.  A folder set corresponds to one
    parameter, and the value of that parameter determines which folder is
    displayed.

    Note that there is also a hou.FolderParmTemplate class.  Folder sets are
    used when there is a mapping to a parameter; for example, asking a
    hou.ParmTuple for its parm template may return a folder set, but it will
    never return a folder.  Folder parm templates are used by
    hou.ParmTemplateGroup because they easily let you add, remove, and move
    individual folders, and they let you easily place parameters inside
    folders.  Attempting to place folder set parm templates in
    hou.ParmTemplateGroup objects will raise hou.OperationFailed.
    """
    def __init__(self, *args, **kwargs):
        """
        hou.FolderSetParmTemplate

        Describes a set of folders.

        A folder set is a group of adjacent folders, and only one of those
        folders can be displayed at a time.  A folder set corresponds to one
        parameter, and the value of that parameter determines which folder is
        displayed.

        Note that there is also a hou.FolderParmTemplate class.  Folder sets are
        used when there is a mapping to a parameter; for example, asking a
        hou.ParmTuple for its parm template may return a folder set, but it will
        never return a folder.  Folder parm templates are used by
        hou.ParmTemplateGroup because they easily let you add, remove, and move
        individual folders, and they let you easily place parameters inside
        folders.  Attempting to place folder set parm templates in
        hou.ParmTemplateGroup objects will raise hou.OperationFailed.
        """
    def folderNames(self, folder_names):
        """
        setFolderNames(self, folder_names)

        Set the names of the folders in this set to the given sequence of
        strings.

        See the folderNames method for more information.

        Raises hou.OperationFailed if folder_names is an empty sequence.
        """

    def setFolderNames(self): return 
    def folderType(self):
        """
        folderType(self) -> hou.folderType enum value

        Return the type of folder.
        """
        return folderType()

    def setFolderType(self, folder_type):
        """
        setFolderType(self, folder_type)

        Set the type of folder to a hou.folderType enum value.

        Raises TypeError if the folder type is for a multiparm or import block.
        """
        return folderType()

    def folderStyle(self):
        """
        folderStyle(self) -> hou.folderType enum value

        This method is deprecated.  It is an alias for the folderType method.
        """
        return folderType()

class galleries(object):
    """
    hou.galleries

    A module for managing galleries and their entries.

    This module provides a few basic functions for accessing and managing
    hou.Gallery and hou.GalleryEntry.


    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def galleries(self):
        """
        galleries() -> tuple of hou.Gallery

        Return a tuple containing all the galleries currently installed in the
        Houdini session.
        """
        return (Gallery(),)

    def galleryEntries(name_pattern=None, label_pattern=None,
        keyword_pattern=None, category=None, node_type=None):
        """
        galleryEntries(name_pattern=None, label_pattern=None,
        keyword_pattern=None, category=None, node_type=None) -> tuple of
        hou.GalleryEntry

        Return a tuple of hou.GalleryEntry objects matching the search criteria.
        The result is the intersection of the matches against all the
        parameters.  If you call this function with no parameters, it returns
        all the gallery entries. See also hou.Gallery.galleryEntries.

        Unless a parameter is None, the results are filtered by the following:

        name_pattern
            gallery entry names matching this pattern

        label_pattern
            gallery entry label names matching this pattern

        keyword_pattern
            gallery entries that have a keyword matching this pattern

        category
            gallery entries in a category matching this pattern

        node_type
            gallery entries that can be applied to this node type

        This example prints all the gallery entries starting with a "b" that
        have the Material keyword.
          >>> hou.galleries.galleryEntries("b*", keyword_pattern="Material")
          (<hou.GalleryEntry "basic_surface">, <hou.GalleryEntry "bumpy_glass">, ...)


        This example prints the name and description of all the entries in the
        Metals category:
          >>> for entry in hou.galleries.galleryEntries(category="Metals"):
          ...     print "%s: %s" % (entry.name(), entry.description())
          chrome: Very bright metal with mirror reflections
          aged_metal: Aged metal material with ray traced or environment mapped reflections
          ...


        This example prints the gallery entry names for the Lsystem SOP.
          >>> node_type = hou.nodeType(hou.sopNodeTypeCategory(), "lsystem")
          >>> for entry in hou.galleries.galleryEntries(node_type=node_type):
          ...     print entry.name()
          planta
          plantb
          plantc
          ...
          sympodial_tree
          ternary_tree
          wheel


        REPLACES
            oppresetls command        """
    def installGallery(self,gallery_path):
        """
        installGallery(gallery_path) -> hou.Gallery or None

        Load a gallery into the current Houdini session.

        gallery_path
            The file path of the gallery to be installed.
        """
        return Gallery()

    def removeGallery(self, gallery_path):
        """
        removeGallery(gallery_path) -> bool

        Remove a gallery from the current Houdini session. Returns False if the
        specified gallery file was not installed.

        gallery_path
            The file path of the gallery to be removed.
        """
        return True

    def createGalleryEntry(self, gallery_path, entry_name, node):
        """
        createGalleryEntry(gallery_path, entry_name, node) -> hou.GalleryEntry
        or None

        Create and return a new gallery entry.

        gallery_path
            The path of the gallery file in which the new element should be
            stored.

        entry_name
            The name of the new gallery entry.

        node
            The operator node from which the new gallery entry should copy the
            settings. The settings include parameter values, channels, spare
            parameters etc, and also the children nodes if the node is a
            subnetwork.
        """
        return GalleryEntry()

class Gallery(object):
    """
    hou.Gallery

    A collection of gallery entries that can be applied to operator nodes
    to set their parameters to predefined values.

    In Houdini, a gallery is a collection of node templates and their
    parameter  presets, which are represented by a hou.GalleryEntry. A
    gallery corresponds to a file where such templates are saved. Galleries
    can be managed with a hou.galleries module.


    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def galleryEntries(self, name_pattern=None, label_pattern=None,
        keyword_pattern=None, category=None, node_type=None):
        """
        galleryEntries(self, name_pattern=None, label_pattern=None,
        keyword_pattern=None, category=None, node_type=None) -> tuple of
        hou.GalleryEntry

        Return a tuple of entries that are stored in the gallery. See also
        hou.galleries.galleryEntries.

        name_pattern
            A pattern that the gallery entry name must match to be included in
            the returned tuple. The pattern can contain '?' to match a single
            character, '*' to match any number of characters, and '[char_set]'
            to match any character in the set.  If None, all gallery entries are
            considered to match it.

        label_pattern
            A pattern that the gallery entry label must match to be included in
            the returned tuple. See the name_pattern above for special
            characters in the pattern. If None, all gallery entries are
            considered to match it.

        keyword_pattern
            A pattern that any of the the gallery entry keywords needs to match
            for the entry to be included in the returned tuple.  See the
            name_pattern above for special characters in the pattern. If None,
            all gallery entries are considered to match it.

        category
            If not None, only gallery entries in the specified category will be
            included in the returned tuple.

        node_type
            If not None, only gallery entries for a given node type will be
            included in the returned tuple.
        """
        return (GalleryEntry(),)

    def createEntry(self): return GalleryEntry()
    def deleteEntry(self): return

class GalleryEntry(object):
    """
    hou.GalleryEntry

    A gallery entry that can be applied to operator nodes to set their
    parameters to predefined values.

    A gallery entry is an entity containing data about an operator node
    setup.  It has information about the node's parameter values, any
    additional spare parameters, channels, and for subnet nodes the
    information about the children, etc. Thus, a gallery entry is like a
    node template or  a parameter preset. Such templates can be created from
    and applied to existing nodes.

    A gallery entry is identified by a unique, and has a non-unique label,
    and is usually associated with a specific hou.NodeType (or several node
    types) of the nodes to which it applies. In addition to the node
    information,  gallery entries can have own categories that organize them
    into manageable sets and also can have keywords that identify their
    purpose. For more information about gallery entries, please see  a
    gallery entry editor.

    In order for your gallery entries to appear in the Material Palette
    pane, they must satisfy two conditions. First, the node category must be
    set to indicate the gallery entry creates a SHOP node. Use code like:

      hou.galleries.galleryEntries("entry_name")[0].setNodeTypeCategory(hou.shopNodeTypeCategory())

    The second condition is that the entry must contain one or more keywords
    that indicate what renderer the SHOP works with. This affects whether
    the gallery entry appears when a specific renderer is chosen in the
    Material Palette renderer menu. Even if "All" is chosen in that menu,
    the gallery entry must contain a keyword that matches one of the
    renderers that appears in that menu. To associate a gallery entry with
    the Mantra renderer, do the following:

      hou.galleries.galleryEntries("entry_name")[0].setKeywords(('Mantra',))

    In HOM the gallery entries can be managed using hou.Gallery.
    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def canApplyToNode(self, node):
        """
        canApplyToNode(self, node) -> bool

        Return True if this gallery entry can be safely applied to the given
        node. See hou.GalleryEntry.applyToNode for more info.

        node
            A node to test whether the gallery entry can be applied to.
        """
        return True

    def applyToNode(self, node):
        """
        applyToNode(self, node)

        Apply the gallery entry to a given node. This method sets the node's
        parameter values to match the ones stored by the entry. It may also add
        spare parameters and channels to the node and for the subnets,  it may
        create new child nodes.

        node
            A node to which to apply the gallery entry.
        """

    def canCreateChildNode(self, parent):
        """
        canCreateChildNode(self, parent) -> bool

        Return True if hou.GalleryEntry.createChildNode can succeed.
        """
        return True

    def createChildNode(self, parent):
        """
        createChildNode(self, parent) -> Node

        Create a new node in the parent network and then apply this gallery
        entry to that newly created node.

        parent
            A subnetwork within which the new node should be created. If None,
            an implicit natural parent is chosen using a node type this gallery
            entry is associated with.
        """
        return Node()

    def setEqual(self, entry):
        """
        setEqual(self, entry)

        Set this gallery entry to be exactly the same as the given entry, except
        for the name, which is left unchanged.

        entry
            The gallery entry to copy the information from.
        """

    def name(self):
        """
        name(self) -> string

        Return the gallery entry name.
        """
        return ''

    def setName(self, name):
        """
        setName(self, name)

        Set the gallery entry name.

        name
            The name string.
        """

    def label(self):
        """
        label(self) -> str

        Return the gallery entry label.
        """
        return ''
    def setLabel(self, label):
        """
        setLabel(self, label)

        Set the gallery entry label.

        label
            The label string.
        """

    def description(self):
        """
        description(self) -> string

        Return a description of the gallery entry. A description is a short
        string that states the gallery entry purpose. It is used for tool-tip
        pop-ups.
        """
        return ''

    def setDescription(self, description):
        """
        setDescription(self, description)

        Set the description of the gallery entry.

        description
            The text briefly describing the gallery entry purpose.
        """

    def helpURL(self):
        """
        helpURL(self) -> string

        Return the URL of the help document for this gallery entry.
        """
        return ''

    def setHelpURL(self, helpurl):
        """
        setHelpURL(self, helpurl)

        Set the URL of the help document for this gallery entry.
        """

    def requiredHDAFile(self):
        """
        requiredHDAFile(self) -> string

        Return a file path to an HDA library that should be loaded before trying
        to apply this gallery entry. It is often used for gallery entries
        associated with a non-native operator type.
        """
        return ''

    def setRequiredHDAFile(self, hda_file):
        """
        setRequiredHDAFile(self, hda_file)

        Set a file path to an HDA library on which this gallery entry depends.

        hda_file
            A path of the HDA library file (OTL).
        """

    def icon(self):
        """
        icon(self) -> string

        Return the icon name or a icon file path that should be used for this
        gallery entry.
        """
        return ''

    def setIcon(self, icon):
        """
        setIcon(self, icon)

        Set the icon name or an icon file path that should be used for this
        gallery entry.
        """

    def allowIconRegeneration(self):
        """
        allowIconRegeneration(self) -> bool

        Return True if this gallery entry wants to let Houdini regenerate the
        icon for it automatically using an appropriate renderer. Only applies to
        material gallery entries.
        """
        return True

    def setAllowIconRegeneration(self, allow):
        """
        setAllowIconRegeneration(self, allow)

        Sets the allow icon regneration flag on this gallery entry.
        """

    def bestNodeType(self):
        """
        bestNodeType(self) -> NodeType or None

        Return a best node type which this gallery entry is associated with and
        whose nodes it can be applied to.
        """
        return NodeType()

    def nodeTypeNames(self):
        """
        nodeTypeNames(self) -> tuple of strings

        Return the names of the node type this gallery is associated with.  The
        gallery can be safely applied to the nodes of these types.
        """
        return ('',)

    def setNodeTypeNames(self, nodetypes):
        """
        setNodeTypeNames(self, nodetypes)

        Set the names of the node types this gallery should be associated with.

        nodetypes
            A string containing white-space separated list of node type names.
        """

    def categories(self):
        """
        categories(self) -> tuple of strings

        Return the categories this gallery entry subscribes to.
        """
        return ('',)

    def setCategories(self, categories):
        """
        setCategories(self, categories)

        Set the categories this gallery entry subscribes to.

        categories
            A string with comma separated categories to set the gallery entry
            to.
        """

    def keywords(self):
        """
        keywords(self) -> tuple of strings

        Return the keywords that describe this gallery entry.
        """
        return ('',)

    def setKeywords(self, keywords):
        """
        setKeywords(self, keywords)

        Set the keywords that describe this gallery entry.

        keywords
            A string containing a white-space separated list of keywords.
        """

    def nodeTypeCategory(self):
        """
        nodeTypeCategory(self) -> NodeTypeCategory

        Return the category of the node types this gallery entry is associated
        with.
        """
        return NodeTypeCategory()

    def setNodeTypeCategory(self, category):
        """
        setNodeTypeCategory(self, category)

        Set the category of the node types this gallery entry should be
        associated with.

        category
            A hou.NodeTypeCategory to associate this gallery entry with.
        """

    def script(self):
        """
        script(self) -> string

        Return a script that modifies the node parameters to match the
        information stored in the gallery entry.
        """
        return ''

    def setScript(self, script):
        """
        setScript(self, script)

        Set a script that modifies the parameters when the gallery entry is
        applied to a node.

        script
            A string that contains the commands setting the node's parameters.
        """

    def setScriptFromNode(self, node):
        """
        setScriptFromNode(self, node)

        Set a script that modifies node parameters. Later on, when applying this
        gallery entry to a node, the script will reconstruct that node's
        parameters  to match exactly the parameters of a node passed to this
        method.

        node
            A node object from which to build the script.
        """

    def setContentsFromNode(self, node):
        """
        setContentsFromNode(self, node)

        Save the information about the node contents (i.e., child nodes). When
        applying the node entry later on, these nodes will be reconstructed  in
        a new parent to match the contents of the current parent.

        node
            The parent of the nodes whose data should be saved.
        """

class Geometry(object):
    """
    hou.Geometry

    A Geometry object contains the points and primitives that define a 3D
    geometric shape.  For example, each SOP node in Houdini generates a
    single Geometry object.

    If you ask a SOP for its geometry via hou.SopNode.geometry, you'll get a
    read-only reference to it.  If the SOP recooks, the corresponding
    Geometry object will update to the SOP's new geometry.  If the SOP is
    deleted, accessing the Geometry object will raise a hou.ObjectWasDeleted
    exception.  If you call methods that try to modify the geometry, they
    will raise a hou.GeometryPermissionError exception.

    If you do not want the geometry to update when the SOP recooks, you can
    call hou.Geometry.freeze.  freeze returns another Geometry object that
    will not change when the SOP recooks.  Accessing frozen Geometry is
    slightly faster, since Houdini does not need to look up the SOP node for
    each access, so you may want to use frozen geometry for speed-crucial
    operations.

    If you're writing a SOP using Python, you will have read-write access to
    the geometry, and it will be frozen.  To create a Python-defined SOP,
    select File > New Operator Type... and place the Python code in the Code
    tab.

    Finally, you can allocate a new frozen geometry with read-write access
    by creating an instance of hou.Geometry.


    """

    def __init__(self, *args):
        """
        hou.Geometry

        A Geometry object contains the points and primitives that define a 3D
        geometric shape.  For example, each SOP node in Houdini generates a
        single Geometry object.

        If you ask a SOP for its geometry via hou.SopNode.geometry, you'll get a
        read-only reference to it.  If the SOP recooks, the corresponding
        Geometry object will update to the SOP's new geometry.  If the SOP is
        deleted, accessing the Geometry object will raise a hou.ObjectWasDeleted
        exception.  If you call methods that try to modify the geometry, they
        will raise a hou.GeometryPermissionError exception.

        If you do not want the geometry to update when the SOP recooks, you can
        call hou.Geometry.freeze.  freeze returns another Geometry object that
        will not change when the SOP recooks.  Accessing frozen Geometry is
        slightly faster, since Houdini does not need to look up the SOP node for
        each access, so you may want to use frozen geometry for speed-crucial
        operations.

        If you're writing a SOP using Python, you will have read-write access to
        the geometry, and it will be frozen.  To create a Python-defined SOP,
        select File > New Operator Type... and place the Python code in the Code
        tab.

        Finally, you can allocate a new frozen geometry with read-write access
        by creating an instance of hou.Geometry.
        """
    def sopNode(self):
        """
        sopNode(self) -> hou.SopNode

        If the Geometry is not frozen, return the hou.SopNode object
        corresponding to this Geometry.  Otherwise, return None.

        See hou.Geometry.freeze for more information on frozen geometry.
        """
        return SopNode()

    def freeze(self):
        """
        freeze(self) -> hou.Geometry

        Return another Geometry object that is not linked to a particular SOP.

        Normally, when you call hou.SopNode.geometry, the resultant Geometry
        object retains a reference to that SOP, and is said to be unfrozen.
        Each time you access points, primitives, attributes, etc. in an unfrozen
        Geometry object, Houdini uses the SOP's latest cooked geometry.  So, if
        you change parameters or change the time for an animated SOP, the
        Geometry object will update to the SOP's new geometry.

        Unless Python SOPs are involved, a frozen Geometry object does not have
        a similar live association with a particular SOP.  If you ask a SOP for
        its geometry and then store a frozen copy of that geometry, when the SOP
        recooks the frozen Geometry object will not update.  Instead, the frozen
        geometry saves its own copy of the point and primitive data, and is
        unaffected by subsequent changes to the SOP.  When a frozen Geometry
        object is destroyed, any geometry copy it created is also destroyed.

        Note that accessing a Geometry object's points, primitives, attributes,
        etc. may be faster when dealing with frozen objects.  You may want to
        work with frozen Geometry in speed-sensitive operations.

        Calling this method on an unfrozen Geometry object returns a frozen one.
        Calling it on a frozen object has no effect, and it returns a frozen
        object.

        When a Python-defined SOP cooks and runs Python code that asks for the
        SOP's geometry, the returned Geometry object is writable.  Modifying
        this Geometry object affects the output of this SOP.  For efficiency,
        this geometry object is already frozen, so calling freeze on it has no
        effect.
        """
        return Geometry()

    def iterPoints(self):
        """
        iterPoints(self) -> generator of hou.Point

        Return a generator that iterates through all the points in the geometry.

        Whereas hou.Geometry.points allocates and returns a tuple of all the
        points in the geometry, this method returns a generator object that will
        allocate hou.Point objects on demand.  This object is very fast at
        random access into the sequence.

        If you're accessing a specific point by index and the geometry contains
        many points, it is faster to use iterPoints() than points().  If,
        however, you are iterating over all the points in the geometry, it is
        generally faster to use points() than iterPoints().

          # This is preferred:
          geo.iterPoints()[23]

          # over this:
          geo.points()[23]

          # But this is preferred:
          for point in geo.points():
              ...process point...

          # over this:
          for point in geo.iterPoints():
              ...process point...

        REPLACES
            haspoint function
            point function
            points function
            pointlist function
            poppoint function        """
        return (Point(),)

    def points(self):
        """
        points(self) -> tuple of hou.Point

        Return a tuple of all the points in the geometry.

        See also the hou.Geometry.iterPoints method.
        """
        return (Point(),)

    def iterPrims(self):
        """
        iterPrims(self) -> generator of hou.Prim

        Return a generator that iterates through all the primitives in the
        geometry.

        Whereas hou.Geometry.prims allocates and returns a tuple of all the
        primitives in the geometry, this method returns a generator object that
        will yield hou.Prim objects on demand.  This object is very fast at
        random access into the sequence.

        If you're accessing a specific primitive by index and the geometry
        contains many primitives, it is faster to use iterPrims() than prims().
        If, however, you are iterating over all the primitives in the geometry,
        it is generally faster to use prims() than iterPrims().

          # This is preferred:
          geo.iterPrims()[23]

          # over this:
          geo.prims()[23]

          # But this is preferred:
          for prim in geo.prims():
              ...process prim...

          # over this:
          for prim in geo.iterPrims():
              ...process prim...

        See also the hou.Geometry.prims method.
        """
        return (Prim(),)

    def prims(self):
        """
        prims(self) -> tuple of hou.Prim

        Return a tuple of all the primitives in the geometry.  The primitives
        returned will be subclasses of hou.Prim (e.g.polygons, volumes, etc.).

        See also:

        * hou.Geometry.iterPrims
        * hou.Face
        * hou.Polygon
        * hou.Surface
        * hou.Volume
        REPLACES
            hasprim function
            prim function
            prims function
            primlist function        """
        return (Prim(),)

    def averageMinDistance(self):
        """
        averageMinDistance(self, local_transform, geometry, geometry_transform)
        -> float

        Return the average over all points in <geometry> of the minimum distance
        to the point set of <self>

        local_transform
            A transform to be applied to all points in this geometry.

        geometry
            The geometry to find distances from.

        geometry_transform
            A transform to be applied to all points in <geometry>.

        Raises hou.OperationFailed if <geometry> has no vertices.

          query_geometry = query_node.geometry()
          queried_geometry = queried_node.geometry()

          # Return the average over all points in <queried_geometry> of the minimum
          # distance to the point set of <query_geometry>
          query_geometry.averageMinDistance(
              query_node.worldTransform(),
              queried_geometry,
              queried_node.worldTransform())
        """

    def averageEdgeLength(self):
        """
        averageEdgeLength(self) -> float

        Return the average edge length of the mesh.

        Raises hou.OperationFailed if mesh does not contain any edges.

          # Return the average edge length.
          geo.averageEdgeLength()
        """
        return 0.0

    def globPoints(self, pattern):
        """
        globPoints(self, pattern) -> tuple of hou.Point

        Return a tuple of points corresponding to a pattern of point numbers.

        The pattern format is the same one used by the group fields on SOP nodes
        that take point selections.  Elements in the pattern are separated by
        spaces, and elements can be point numbers, point number ranges, or group
        names.

        This method can be useful when writing a Python SOP that works on only a
        selected set of points.

        Raises hou.OperationFailed if the pattern is not valid or if it refers
        to a group that does not exist.  Note that an empty pattern is
        considered to be invalid.  Numbers that do not refer to valid points are
        not errors, and simply do not match points.

          # Return a tuple containing points 5 and 7.
          geo.globPoints("5 7")

          # Return a tuple containing points 5 to 10.
          geo.globPoints("5-10")

          # Return a tuple containing all the points in the pointgroup called group1.
          geo.globPoints("group1")

          # Return all the points except those from 0 to 98.
          geo.globPoints("!0-98")

          # Return points 5, 10 to 20, and those in group1.
          geo.globPoints("5 group1 10-20")

        The following Python SOP example is behaves similarly to the Point sop.
          # This code will work from inside a Python SOP, but not from the Python
          # shell.  It assumes the Python sop has the following parm tuples:
          #     group: A string containing which points to affect
          #     t:     A set of 3 floats that behaves like the point sop's position
          #            parameter.  Set these parameters to the expressions ($TX, $TY, $TZ).
          geo = hou.pwd().geometry()

          # Use the group field to determine which points to affect.  If it's blank,
          # operate on all points.
          pattern = hou.ch("group")
          if pattern == "":
              points = geo.points()
          else:
              points = geo.globPoints(pattern)

          # Loop through the points, setting the SOP's current point as we go.
          # Then evaluate the t parm tuple, so it can use the current point (e.g.
          # with hscript's $TX or Python's pwd().curPoint()).
          for point in points:
              hou.pwd().setCurPoint(point)
              new_position = hou.pwd().evalParmTuple("t")
              point.setPosition(new_position)


        REPLACES
            pointpattern function        """
        return (Point(),)

    def globPrims(self, pattern):
        """
        globEdges(self, pattern) -> tuple of hou.Edge

        Return a tuple of edges corresponding to an edge pattern.

        The pattern format is the same one used by the group fields on SOP nodes
        that take edge selections.  See hou.Geometry.globPoints for more
        information.
        """
        return (Polygon(),)

    def globVertices(self, pattern): return (Vertex(),)
    def globEdges(self, pattern): return (Edge(),)
    def pointAttribs(self):
        """
        pointAttribs(self) -> tuple of hou.Attrib

        Return a tuple of all the point attributes.

        Note that the point position attribute is named P and is 3 floats in
        size.  Also, the point weight attribute is named Pw and is 1 float in
        size.  These attributes always exist in HOM, even though they are not
        listed by Houdini's UI.
        """
        return (Attrib(),)

    def primAttribs(self):
        """
        primAttribs(self) -> tuple of hou.Attrib

        Return a tuple of all the primitive attributes.
        """
        return (Attrib(),)

    def vertexAttribs(self):
        """
        vertexAttribs(self) -> tuple of hou.Attrib

        Return a tuple of all the vertex attributes.
        """
        return (Attrib(),)

    def globalAttribs(self):
        """
        globalAttribs(self) -> tuple of hou.Attrib

        Return a tuple of all the global (a.k.a. detail) attributes.
        """
        return (Attrib(),)

    def findPointAttrib(self):
        """
        findPointAttrib(self, name) -> hou.Attrib or None

        Look up a point attribute by name.  Returns the corresponding hou.Attrib
        object, or None if no attribute exists with that name.

        Note that the point position attribute is named P and is 3 floats in
        size.  Also, the point weight attribute is named Pw and is 1 float in
        size.  These attributes always exist in HOM, even though they are not
        listed by Houdini's UI.

        See hou.Point.attribValue for an example.

        REPLACES
            haspointattrib function        """
        return Attrib()

    def findPrimAttrib(self):
        """
        findPrimAttrib(self, name) -> hou.Attrib or None

        Look up a primitive attribute by name.  Returns the corresponding
        hou.Attrib object, or None if no attribute exists with that name.

        REPLACES
            hasprimattrib function        """
        return Attrib()

    def findVertexAttrib(self):
        """
        findVertexAttrib(self, name) -> hou.Attrib or None

        Look up a vertex attribute by name.  Returns the corresponding
        hou.Attrib object, or None if no attribute exists with that name.

        REPLACES
            hasvertexattrib function        """
        return Attrib()

    def findGlobalAttrib(self):
        """
        findGlobalAttrib(self, name) -> hou.Attrib or None

        Look up a global (a.k.a. detail) attribute by name.  Returns the
        corresponding hou.Attrib object, or None if no attribute exists with
        that name.

        REPLACES
            hasdetailattrib function        """
        return Attrib()

    def attribType(self):
        """
        attribType(self) -> hou.attribType enum value

        Return the enumerated value hou.attribType.Global.  Points, primitives,
        vertices, and geometry support the same set of methods for querying
        their attributes, and this method is one of them.

        See also:

        * hou.Prim.attribType
        * hou.Point.attribType
        * hou.Vertex.attribType        """
        return attribType()

    def floatAttribValue(self, name_or_attrib):
        """
        floatAttribValue(self, name_or_attrib) -> float

        Return the global (a.k.a. detail) attribute value for a particular
        floating point attribute.  The attribute may be specified by name or by
        hou.Attrib object.

        Raises hou.OperationFailed if no attribute exists with this name or the
        attribute is not a float of size 1.

        In most cases, you'll just use hou.Geometry.attribValue to access
        attribute values.  Houdini uses this method internally to implement
        attribValue.
        """
        return 0.0

    def floatListAttribValue(self, name_or_attrib):
        """
        floatListAttribValue(self, name_or_attrib) -> tuple of float

        Return the global (a.k.a. detail) attribute value for a particular
        floating point attribute.  The attribute may be specified by name or by
        hou.Attrib object.  The return value is a list of floats.

        It is valid to call this method when the attribute's size is 1.  In this
        case, a list with one element is returned.

        See also:

        * hou.Geometry.attribValue        """
        return (0.0,)

    def intAttribValue(self, name_or_attrib):
        """
        intAttribValue(self, name_or_attrib) -> int

        Return the global (a.k.a. detail) attribute value for a particular
        integer attribute of size 1.  The attribute may be specified by name or
        by hou.Attrib object.  See hou.Geometry.floatAttribValue for more
        information.
        """
        return 0

    def intListAttribValue(self, name_or_attrib):
        """
        intListAttribValue(self, name_or_attrib) -> tuple of int

        Return the global (a.k.a. detail) attribute value for a particular
        integer attribute.  The attribute may be specified by name or by
        hou.Attrib object.  The return value is a list of ints.  See
        hou.Geometry.floatListAttribValue for more information.
        """
        return (0,)

    def stringAttribValue(self, name_or_attrib):
        """
        stringAttribValue(self, name_or_attrib) -> str

        Return the global (a.k.a. detail) attribute value for a particular
        string attribute.  The attribute may be specified by name or by
        hou.Attrib object.  See hou.Geometry.floatAttribValue for more
        information.
        """
        return ''

    def stringListAttribValue(self, name_or_attrib):
        """
        stringListAttribValue(self, name_or_attrib) -> tuple of int

        Return the global (a.k.a. detail) attribute value for a particular
        string attribute.  The attribute may be specified by name or by
        hou.Attrib object.  The return value is a list of strings.  See
        hou.Geometry.floatListAttribValue for more information.
        """
        return (0,)

    def pointFloatAttribValues(self, name):
        """
        pointFloatAttribValues(self, name) -> tuple of float

        Return a tuple of floats containing one attribute's values for all the
        points.

        This method only works on int or float attributes.  If the attribute
        contains more than one element, each point will correspond to multiple
        values in the result.  For example, if "Cd" is a float attribute of
        size 3 and there are 3 points with values (0.1, 0.2, 0.3), (0.5, 0.5,
        0.5), and (0.8, 0.7, 0.6) then the result will be (0.1, 0.2, 0.3, 0.5,
        0.5, 0.5, 0.8, 0.7, 0.6).

        Calling this method is faster than looping over all the points and
        calling hou.Point.attribValue.

        If the attribute name is invalid or the attribute is not an int or float
        (e.g. it's a string attribute), this method raises hou.OperationFailed.

        Note that you cannot pass a hou.Attrib object to this method like you
        can with many methods dealing with attributes.  However, you can use
        hou.Attrib.name to easily get the name from an Attrib object.
        """
        return (0.0,)

    def pointFloatAttribValuesAsString(self, name,
        float_type=hou.numericType.Float32):
        """
        pointFloatAttribValuesAsString(self, name,
        float_type=hou.numericType.Float32) -> str

        Return a string representation of the floats of one attribute's value
        for all the points.  This method is faster than
        hou.Geometry.pointFloatAttribValues, and you can use the array module to
        convert the string into a Python sequence.

        float_type
            A Hom.hou.numericType value to specify the float data type (either
            Float16, Float32 or Float64).

        This method provides a faster implementation of the following:
          import array
          def pointFloatAttribValuesAsString(self, name):
              return array.array("f", self.pointFloatAttribValues(name)).tostring()


        You can convert the return value from this method to an array using the
        following method:
          import array
          def pointFloatAttribValuesAsArray(geometry, name):
              a = array.array("f")
              a.fromstring(geometry.pointFloatAttribValuesAsString(name))
              return a


        See hou.Geometry.pointFloatAttribValues for more information.
        """
        return ''

    def primFloatAttribValues(self, name):
        """
        primFloatAttribValues(self, name) -> tuple of float

        Return a tuple of floats containing one attribute's values for all the
        primitives.

        This method only works on int or float attributes.  If the attribute
        contains more than one element, each primitive will correspond to
        multiple values in the result.  For example, if Cd is a float attribute
        of size 3 and there are 3 primitives with values (0.1, 0.2, 0.3), (0.5,
        0.5, 0.5), and (0.8, 0.7, 0.6) then the result will be (0.1, 0.2, 0.3,
        0.5, 0.5, 0.5, 0.8, 0.7, 0.6).

        Calling this method is faster than looping over all the primitives and
        calling hou.Prim.attribValue.

        If the attribute name is invalid or the attribute is not an int or float
        (e.g. it's a string attribute), this method raises hou.OperationFailed.

        Note that you cannot pass a hou.Attrib object to this method like you
        can with many methods dealing with attributes.  However, you can use
        hou.Attrib.name to easily get the name from an Attrib object.
        """
        return (0.0,)

    def primFloatAttribValuesAsString(self, name):
        """
        primFloatAttribValuesAsString(self, name) -> str

        Return a string representation of the floats of one attribute's value
        for all the primitives.  This method is faster than
        hou.Geometry.primFloatAttribValues, and you can use the array module to
        convert the string into a Python sequence.

        This method provides a faster implementation of the following:
          import array
          def primFloatAttribValuesAsString(self, name):
              return array.array("f", self.primFloatAttribValues(name)).tostring()


        You can convert the return value from this method to an array using the
        following method:
          import array
          def primFloatAttribValuesAsArray(geometry, name):
              a = array.array("f")
              a.fromstring(geometry.primFloatAttribValuesAsString(name))
              return a


        See hou.Geometry.primFloatAttribValues for more information.
        """
        return ''

    def pointIntAttribValues(self, name):
        """
        pointIntAttribValues(self, name) -> tuple of int

        Return a tuple of integers containing one attribute's values for all the
        points.

        This method only works on int or float attributes.  If the attribute
        contains more than one element, each point will correspond to multiple
        values in the result.  For example, if "idmap" is an integer attribute
        of size 2 and there are 3 points with values (1, 2), (2, 3), and (3, 4)
        then the result will be (1, 2, 2, 3, 3, 4).

        Calling this method is faster than looping over all the points and
        calling hou.Point.attribValue.

        If the attribute name is invalid or the attribute is not an int or float
        (e.g. it's a string attribute), this method raises hou.OperationFailed.

        Note that you cannot pass a hou.Attrib object to this method like you
        can with many methods dealing with attributes.  However, you can use
        hou.Attrib.name to easily get the name from an Attrib object.
        """
        return (0,)

    def pointIntAttribValuesAsString(self, name, int_type=hou.numericType.Int32):
        """
        pointIntAttribValuesAsString(self, name, int_type=hou.numericType.Int32)
        -> str

        Return a string representation of the integers of one attribute's value
        for all the points.  This method is faster than
        hou.Geometry.pointIntAttribValues, and you can use the array module to
        convert the string into a Python sequence.

        int_type
            A Hom.hou.numericType value to specify the integer data type (either
            Int8, Int16, Int32 or Int64).

        This method provides a faster implementation of the following:
          import array
          def pointIntAttribValuesAsString(self, name):
              return array.array("i", self.pointIntAttribValues(name)).tostring()


        You can convert the return value from this method to an array using the
        following method:
          import array
          def pointIntAttribValuesAsArray(geometry, name):
              a = array.array("i")
              a.fromstring(geometry.pointIntAttribValuesAsString(name))
              return a


        See hou.Geometry.pointIntAttribValues for more information.
        """

    def primIntAttribValues(self, name):
        """
        primIntAttribValues(self, name) -> tuple of int

        Return a tuple of integers containing one attribute's values for all the
        primitives.

        This method only works on int or float attributes.  If the attribute
        contains more than one element, each primitive will correspond to
        multiple values in the result.  For example, if idmap is an integer
        attribute of size 2 and there are 3 primitives with values (1, 2), (2,
        3), and (3,4) then the result will be (1, 2, 2, 3, 3, 4).

        Calling this method is faster than looping over all the primitives and
        calling hou.Prim.attribValue.

        If the attribute name is invalid or the attribute is not an int or float
        (e.g. it's a string attribute), this method raises hou.OperationFailed.

        Note that you cannot pass a hou.Attrib object to this method like you
        can with many methods dealing with attributes.  However, you can use
        hou.Attrib.name to easily get the name from an Attrib object.
        """
        return (0,)

    def primIntAttribValuesAsString(self, name, int_type=hou.numericType.Int32):
        """
        primIntAttribValuesAsString(self, name, int_type=hou.numericType.Int32)
        -> str

        Return a string representation of the integers of one attribute's value
        for all the primitives.  This method is faster than
        hou.Geometry.primFloatAttribValues, and you can use the array module to
        convert the string into a Python sequence.

        int_type
            A Hom.hou.numericType value to specify the integer data type (either
            Int8, Int16, Int32 or Int64).

        This method provides a faster implementation of the following:
          import array
          def primIntAttribValuesAsString(self, name):
              return array.array("i", self.primIntAttribValues(name)).tostring()


        You can convert the return value from this method to an array using the
        following method:
          import array
          def primIntAttribValuesAsArray(geometry, name):
              a = array.array("i")
              a.fromstring(geometry.primIntAttribValuesAsString(name))
              return a


        See hou.Geometry.primIntAttribValues for more information.
        """
        return ''

    def setPointFloatAttribValues(self, name, values):
        """
        setPointFloatAttribValues(self, name, values)

        For a particular attribute, set the attribute values for all points. You
        would typically call this method from the code of a Python-defined SOP.

        name
            The name of the point attribute.

        values
            A sequence of int or float values in the same format as that
            returned by hou.Geometry.pointFloatAttribValues.  See that method
            for more information.

        Raises hou.OperationFailed if the attribute name is not valid, the
        attribute is not an int or float (i.e. it's a string), or the array of
        values is not the correct size.

        Raises hou.GeometryPermissionError if this geometry is not modifiable.

        Also see hou.Geometry.pointFloatAttribValues.
        """

    def setPrimFloatAttribValues(self, name, values):
        """
        setPrimFloatAttribValues(self, name, values)

        For a particular attribute, set the attribute values for all primitives.
        You would typically call this method from the code of a Python-defined
        SOP.

        name
            The name of the primitive attribute.

        values
            A sequence of int or float values in the same format as that
            returned by hou.Geometry.primFloatAttribValues.  See that method for
            more information.

        Raises hou.OperationFailed if the attribute name is not valid, the
        attribute is not an int or float (i.e. it's a string), or the array of
        values is not the correct size.

        Raises hou.GeometryPermissionError if this geometry is not modifiable.

        Also see hou.Geometry.primFloatAttribValues.
        """

    def setPointFloatAttribValuesFromString(*args, **kwargs): return
    def setPrimFloatAttribValuesFromString(*args, **kwargs): return
    def setPointIntAttribValues(self, name, values):
        """
        setPointIntAttribValues(self, name, values)

        For a particular attribute, set the attribute values for all points. You
        would typically call this method from the code of a Python-defined SOP.

        name
            The name of the point attribute.

        values
            A sequence of int or float values in the same format as that
            returned by hou.Geometry.pointIntAttribValues.  See that method for
            more information.

        Raises hou.OperationFailed if the attribute name is not valid, the
        attribute is not an int or float (i.e. it's a string), or the array of
        values is not the correct size.

        Raises hou.GeometryPermissionError if this geometry is not modifiable.

        Also see hou.Geometry.pointIntAttribValues.
        """

    def setPrimIntAttribValues(self, name, values):
        """
        setPrimIntAttribValues(self, name, values)

        For a particular attribute, set the attribute values for all primitives.
        You would typically call this method from the code of a Python-defined
        SOP.

        name
            The name of the primitive attribute.

        values
            A sequence of int or float values in the same format as that
            returned by hou.Geometry.primFloatAttribValues.  See that method for
            more information.

        Raises hou.OperationFailed if the attribute name is not valid, the
        attribute is not an int or float (i.e. it's a string), or the array of
        values is not the correct size.

        Raises hou.GeometryPermissionError if this geometry is not modifiable.

        Also see hou.Geometry.primIntAttribValues.
        """

    def setPointIntAttribValuesFromString(*args, **kwargs): return
    def setPrimIntAttribValuesFromString(*args, **kwargs): return
    def createPoint(self):
        """
        createPoint(self) -> hou.Point

        Create a new point located and (0, 0, 0) and return the corresponding
        hou.Point object.  You would typically call this method from the code of
        a Python-defined SOP.

        If the geometry contains point attributes, the new point receives the
        default values for those attributes.

        Raises hou.GeometryPermissionError if this geometry is not modifiable.

        See hou.Geometry.addAttrib, hou.Geometry.createPolygon, and
        hou.Face.addVertex for examples.
        """
        return Point()

    def createPolygon(self):
        """
        createPolygon(self) -> hou.Polygon

        Create a new polygon and return the corresponding hou.Polygon object.
        You would typically call this method from the code of a Python-defined
        SOP.

        The newly created polygon has no vertices.  Use hou.Face.addVertex to
        add them.  The polygon is also closed (see hou.Face.isClosed for more
        information).

        If the geometry contains primitive attributes, the new polygon receives
        the default values for those attributes.

        Raises hou.GeometryPermissionError if this geometry is not modifiable.

          geo = hou.pwd().geometry()
          poly = geo.createPolygon()
          for position in (0,0,0), (1,0,0), (0,1,0):
              point = geo.createPoint()
              point.setPosition(position)
              poly.addVertex(point)

        See hou.Face.addVertex for a slightly more complicated example.
        """
        return Polygon()

    def createPacked(self, typename):
        """
        createPacked(self, typename) -> hou.PackedPrim

        typename
            A string containing the name of a type of packed primitive. Typical
            examples are "PackedDisk" (on-disk geometry file) or
            "AlembicRef" (Alembic file).

            To see a complete list of possible typename values, run ginfo -P on
            a Houdini tools command line.

        See hou.PackedPrim for more information.
        """
        return PackedPrim()

    def createTetrahedron(self):
        """
        createTetrahedron(self) -> hou.Prim

        Create a new tetrahedron and return the corresponding hou.Prim object.
        You would typically call this method from the code of a Python-defined
        SOP.

        The newly created tetrahedron has four vertices and new points have been
        allocated for them.  To build a tetrahedron out of existin points, use
        Hom.hou.Geometry#createTetrahedronInPlace

        Raises hou.GeometryPermissionError if this geometry is not modifiable.
        """
        return Prim()

    def createTetrahedronInPlace(self):
        """
        createTetrahedronInPlace(self, p0, p1, p2, p3) -> hou.Prim

        Create a new tetrahedron and return the corresponding hou.Prim object.
        You would typically call this method from the code of a Python-defined
        SOP.

        The newly created tetrahedron has four vertices and uses the points that
        have been passed into it.

        Raises hou.GeometryPermissionError if this geometry is not modifiable.
        """
        return Prim()

    def createNURBSCurve(self, num_vertices=4, is_closed=False, order=4):
        """
        createNURBSCurve(self, num_vertices=4, is_closed=False, order=4) ->
        hou.Face

        Create a new NURBS with the specified number of vertices and return it.
        You would typically call this method from the code of a Python-defined
        SOP.

        num_vertices
            The number of verticies in the curve.  A new point is added to the
            geometry for each vertex, and this point is located at the origin
            until you change its position.  You can also add more vertices with
            hou.Face.addVertex.

            The minimum number of vertices for a NURBS curve is identical to its
            order. So for the default order of 4, the curve must have a minimum
            of 4 vertices. If you specify too few vertices, this method raises
            hou.OperationFailed.

        is_closed
            Controls if the curve is open or closed; see hou.Face.isClosed for
            more information.  If not specified, the resulting curve is open.
            This behavior is different from hou.Geometry.createPolygon, where
            the new polygon is closed.  You can also open or close it with
            hou.Face.setIsClosed.

        order
            Specifies the curve's order. The default order is 4, corresponding
            to a cubic NURBS curve. An order of 2, the lowest order, will give a
            curve with linear segments.

        If the geometry contains primitive attributes, the new curve receives
        the default values for those attributes.

          # This code will work from inside a Python SOP, but not from the Python
          # shell.
          geo = hou.pwd().geometry()
          curve = geo.createNURBSCurve(10)
          i = 0
          for vertex in curve.vertices():
              vertex.point().setPosition((i, i % 3, 0))
              i = i + 1

        Raises hou.GeometryPermissionError if this geometry is not modifiable.

        See also:

        * hou.Prim.vertices
        * hou.Point.setPosition        """
        return Face()

    def createBezierCurve(self, num_vertices=4, is_closed=False, order=4):
        """
        createBezierCurve(self, num_vertices=4, is_closed=False, order=4) ->
        hou.Face

        Create a new Bezier curve with the specified number of vertices and
        return it.  You would typically call this method from the code of a
        Python-defined SOP.

        num_vertices
            The number of verticies in the curve.  A new point is added to the
            geometry for each vertex, and this point is located at the origin
            until you change its position.  You can also add more vertices with
            hou.Face.addVertex.

        is_closed
            Controls if the curve is open or closed; see hou.Face.isClosed for
            more information.  If not specified, the resulting curve is open.
            This behavior is different from hou.Geometry.createPolygon, where
            the new polygon is closed.

        order
            Specifies the curve's order. The default order is 4, corresponding
            to a cubic Bezier curve. An order of 2, the lowest order, will give
            a curve with linear segments.

        An open Bezier curve must have (order - 1) * n + 1 vertices for some
        integer n>=1 (so valid values for order 4 curves are 4, 7, 10, etc.).
        A closed Bezier curve must have (order - 1) * n vertices (e.g. 3, 6, 9,
        etc.  for order 4 curve). This restriction does not apply to curves of
        order 2, however.

        As a consequence, you cannot use hou.Face.setIsClosed on non-linear
        Bezier curves, since the number of vertices would need to change.

        See hou.Geometry.createNURBSCurve for more information.
        """
        return Face()

    def createNURBSSurface(self, rows, cols, is_closed_in_u=False,
        is_closed_in_v=False):
        """
        createNURBSSurface(self, rows, cols, is_closed_in_u=False,
        is_closed_in_v=False) -> hou.Surface

        Create a NURBS surface in the XY plane centered at the origin with size
        (1, 1) and return it.  You would typically call this method from the
        code of a Python-defined SOP.

        rows, cols
            Determines the size of the 2D array of vertices defining the control
            points of the surface. The number of cols and rows in each
            direction, must be equal to or larger than the U and V orders,
            respectively.

        is_closed_in_u, is_closed_in_v
            Controls if the surface is open or closed in each of the U and V
            directionss; see hou.Surface.isClosedInU for more information.   If
            not specified, the default behavior is to build an open surface.

        order_u, order_v
            Specifies the surface's order in each of the U and V directionss.
            The default order for both is 4, corresponding to a cubic NURBS
            surface.  An order of 2, the lowest order, will give a surface with
            linear segments, essentially a mesh.

        If the geometry contains primitive attributes, the new surface receives
        the default values for those attributes.

        You can move or resize the surface using hou.Geometry.transformPrims.

        Raises hou.GeometryPermissionError if this geometry is not modifiable.

        Raises hou.OperationFailed if the number of rows and/or columns is
        invalid.

          # This code will work from inside a Python SOP, but not from the Python
          # shell.
          geo = hou.pwd().geometry()

          # Create a surface with a 10x10 grid of vertices.
          surf = geo.createNURBSSurface(10, 10)

          # Initially, the center is at (0, 0, 0), size is (1, 1, 1), on the XY
          # plane.  Scale to (20, 10) and rotate into the XZ plane.
          geo.transformPrims((surf,),
              hou.hmath.buildScale((20, 10, 1)) *
              hou.hmath.buildRotateAboutAxis((1, 0, 0), 90))

        See also:

        * hou.Geometry.transformPrims
        * hou.Matrix4
        * hou.hmath        """
        return Surface()

    def createBezierSurface(self, rows, cols, is_closed_in_u=False,
        is_closed_in_v=False):
        """
        createBezierSurface(self, rows, cols, is_closed_in_u=False,
        is_closed_in_v=False) -> hou.Surface

        Create a Bezier surface in the XY plane centered at the origin with size
        (1, 1) and return it.  You would typically call this method from the
        code of a Python-defined SOP.

        rows, cols
            Determines the size of the 2D array of vertices defining the control
            points of the surface.

            Note that the number of rows corresponds to v and the number or
            columns corresponds to u, which can be slightly confusing.  For
            example, geo.createBezierSurface(9, 7, is_closed_in_u=False,
            is_closed_in_v=True) is valid, but geo.createBezierSurface(9, 7,
            is_closed_in_u=True, is_closed_in_v=False) raises
            hou.OperationFailed.

        is_closed_in_u, is_closed_in_v
            Determines if it is open or closed in each of the u and v
            directions; see hou.Surface.isClosedInU for more information.

        order_u, order_v
            Specifies the surface's order in of the U and V directions.  The
            default order for both is 4, corresponding to a cubic NURBS surface.
            An order of 2, the lowest order, will give a surface with linear
            segments, essentially a mesh.

        As with Bezier curves, a Bezier surface has some restrictions on the
        point count in each of the U and V directions. For a given direction; if
        it's  open the number of points in the direction must be (order - 1) * n
        + 1 for some integer n >= 1 (e.g. 4, 7, 10, ...). If it's open, the
        number of points must be (order - 1) * n where n >= 1 in that direction
        (e.g.  2, 4, 6, .. for order 3).

        You can move or resize the surface using hou.Geometry.transformPrims.

        If the geometry contains primitive attributes, the new surface receives
        the default values for those attributes.

        Raises hou.GeometryPermissionError if this geometry is not modifiable.

          import math

          # This code will work from inside a Python SOP, but not from the Python
          # shell.
          geo = hou.pwd().geometry()

          # Build a tube-like object about the y axis.
          num_rows, num_cols = (10, 9)
          surf = geo.createBezierSurface(num_rows, num_cols, is_closed_in_u=True)
          for v_index in range(num_rows):
              for u_index in range(num_cols):
                  angle = u_index * (2.0 * math.pi) / num_cols
                  surf.vertex(u_index, v_index).point().setPosition(
                      (math.cos(angle), v_index / float(num_cols-1), math.sin(angle)))
        """
        return Surface()

    def createMeshSurface(self, rows, cols, is_closed_in_u=False,
        is_closed_in_v=False):
        """
        createMeshSurface(self, rows, cols, is_closed_in_u=False,
        is_closed_in_v=False) -> hou.Surface

        Create a quadrilateral mesh surface in the XY plane centered at the
        origin with size (1, 1) and return it.  You would typically call this
        method from the code of a Python-defined SOP.

        Note that a mesh object is not the same as a set of polygons defining
        the same shape.  A mesh object is a single primitive.

        See hou.Geometry.createNURBSSurface for more information.
        """
        return Surface()

    def createVolume(self, xres, yres, zres, bounding_box=None):
        """
        createVolume(self, xres, yres, zres, bounding_box=None) -> hou.Volume

        Given the x, y, and z resolution (or size) of a voxel array, add a new
        volume primitive to the geometry and return it.  The values in the new
        volume's voxels are all zero.

        xres, yres, zres
            Integers greater than zero that specify the size of the voxel array
            in one dimension.  Raises hou.OperationFailed if any of these values
            are not positive.

        bounding_box
            A hou.BoundingBox that specifies the volume's 3D size.  Note that
            this size is independent of the volume's voxel resolution.  If this
            parameter is None, Houdini uses a bounding box going from (-1,-1,-1)
            to (1,1,1).
        """
        return Volume()

    def transform(self, matrix):
        """
        transform(self, matrix)

        Transforms (e.g. rotates, scales, translates, etc.) the geometry by a
        transformation matrix.  You would typically call this method from the
        code of a Python-defined SOP.

        See hou.hmath for functions that build transformation matrices.

        Raises hou.GeometryPermissionError if this geometry is not modifiable.
        """

    def transformPrims(self, prims, matrix):
        """
        transformPrims(self, prims, matrix)

        Transforms a set of primitives (e.g. rotates, scales, translates, etc.)
        by a transformation matrix.  You would typically call this method from
        the code of a Python-defined SOP.

          import math

          # This code will work from inside a Python SOP, but not from the Python
          # shell.

          def createCircle(geo, num_vertices=10):
              # Create a closed curve with the specified number of vertices.
              curve = geo.createNURBSCurve(num_vertices)
              curve.setIsClosed(True)

              # Arrange the points into a unit circle on the XZ plane,
              # centered about the origin.
              for i, vertex in enumerate(curve.vertices()):
                  angle = i * (2.0 * math.pi) / num_vertices
                  position = (math.cos(angle), 0, math.sin(angle))
                  vertex.point().setPosition(position)
              return curve

          # Create a bunch of circles on the XZ plane, tilt them slightly
          # about X, translate them away from the origin, and rotate each
          # one about the y axis by a different amount.
          geo = hou.pwd().geometry()
          num_copies = 20
          for i in range(num_copies):
              curve = createCircle(geo)
              geo.transformPrims([curve],
                  hou.hmath.buildRotateAboutAxis((1, 0, 0), 30) *
                  hou.hmath.buildTranslate((2, 0, 0)) *
                  hou.hmath.buildRotateAboutAxis((0, 1, 0), i * 360.0 / num_copies))

        See hou.hmath functions that build transformation matrices.

        Raises hou.GeometryPermissionError if this geometry is not modifiable.
        """

    def deletePrims(self, prims, keep_points=False):
        """
        deletePrims(self, prims, keep_points=False)

        Delete a sequence of primitives.  You would typically call this method
        from the code of a Python-defined SOP.

        keep_points
            if True, the primitive will be deleted but its points will remain.

        To delete a single primitive, pass in a sequence with one primitive.

        Raises hou.GeometryPermissionError if this geometry is not modifiable.

          # Delete every other primitive:
          prims = [p for p in geo.prims() if p.number() % 2 == 0]
          geo.deletePrims(prims)

          # Delete the first primitive:
          geo.deletePrims([geo.iterPrims()[0]])
        """

    def deletePoints(self, points):
        """
        deletePoints(self, points)

        Delete a sequence of points.  You would typically call this method from
        the code of a Python-defined SOP.

        Note that Houdini will delete any vertices that reference the point. For
        example, suppose you have a box with 6 polygons, each with 4 vertices.
        Also suppose that each point on the box is shared by 3 vertices on 3
        separate polygons.  If you delete one of those points, Houdini will
        remove each of those vertices from their corresponding polygons, leaving
        3 polygons with 4 vertices and 3 polygons with 3 vertices.

        To delete a single primitive, pass in a sequence with one point.

        Raises hou.GeometryPermissionError if this geometry is not modifiable.
        """

    def addAttrib(self, type, name, default_value, transform_as_normal=False,
        create_local_variable=True):
        """
        addAttrib(self, type, name, default_value, transform_as_normal=False,
        create_local_variable=True) -> hou.Attrib

        Create a new point, primitive, vertex, or global (a.k.a. detail)
        attribute. Returns a hou.Attrib object describing the newly created
        attribute. You would typically call this method from the code of a
        Python-defined SOP.

        type
            A hou.attribType value to specify if the new attribute should be a
            point, primitive, vertex, or global attribute.

        name
            The new attribute's name.  Each attribute in the geometry must have
            a unique name.

        default_value
            The default value for this attribute.  When an attribute is created,
            all existing elements (e.g. primitives or points) will store this
            value.  As well, elements that you add later will also use this
            value.

            This value also determines the attribute's data type, and may be one
            of the following:

          * an integer
          * a float
          * a string
          * an integer sequence
          * a float sequence
            If the default value is a sequence of integers or floats, the
            sequence size will determine the attribute's size.  Otherwise, the
            attribute's size is 1.

            String attributes do not support a default value and use this value
            solely for type determination.

        transform_as_normal
            This parameter may only be set to True when the default value is a
            sequence of 3 floats.  For such attributes, Houdini will not modify
            the attribute values when it transforms (translates, rotates, etc.)
            the geometry.  If you want to the attribute to be transformed as a
            vector (such as a normal vector) when Houdini transforms the
            geometry, set this parameter to True.

        create_local_variable
            If True, Houdini will create a local variable for this attribute
            that may be used in parameter expressions.  The name of the local
            variable is the attribute's name, all in upper case.  The mapping
            from attribute names to local variables is stored in a special
            global attribute named "varmap".

        Raises hou.GeometryPermissionError if this geometry is not modifiable.

        Raises hou.OperationFailed if an attribute with this name already
        exists.  If you are familiar with the C++ Houdini Development Kit (HDK),
        you know that Houdini can support attributes with the same name but with
        different types.  However, many SOPs do not let you distinguish between
        attributes that have the same name, and multiple attributes with the
        same name are discouraged.  For this reason, you cannot create them with
        this method.

        Raises hou.OperationFailed if transform_as_normal is True and the
        default value is not a sequence of 3 floats.

          # Create an integer point attribute of size 1 named "population", and
          # create 5 points with attribute values 0, 5, 10, 15, and 20.  This code
          # will work from inside a Python SOP, but not from the Python shell.
          geo = hou.pwd().geometry()
          population_attrib = geo.addAttrib(hou.attribType.Point, "population", 0)
          for i in range(5):
              point = geo.createPoint()
              point.setPosition((i, 0, 0))
              point.setAttribValue(population_attrib, i * 5)

        The following example shows how to copy an existing attribute:
          def copyAttrib(attrib, new_name):
              return attrib.geometry().addAttrib(
                  attrib.type(), new_name, attrib.defaultValue(), attrib.isTransformedAsNormal())


        If create_local_variable is True, this function performs the equivalent
        of the following code:
          def addLocalVariable(geo, attrib_name):
              '''Create a geometry attribute and add a local variable for it.'''
              # The variable mappings are stored in the varmap attribute's string
              # table.  This table is different than varmap's current value, which
              # simply refers to an entry in that table.  So, to ensure an entry
              # exists in the table, we simply set varmap's value.
              map_value = "%s -> %s" % (attrib_name, attrib_name.upper())
              if geo.findGlobalAttrib("varmap") is None:
                  geo.addAttrib(hou.attribType.Global, "varmap", "")
              geo.setGlobalAttribValue("varmap", map_value)


        See also:

        * hou.Prim.setAttribValue
        * hou.Point.setAttribValue
        * hou.Prim.setAttribValue
        * hou.Geometry.setGlobalAttribValue        """
        return Attrib()

    def setGlobalAttribValue(self, name_or_attrib, attrib_value):
        """
        setGlobalAttribValue(self, name_or_attrib, attrib_value)

        Set a global (a.k.a. detail) attribute value.  The attribute may be
        specified by name or by hou.Attrib object.  You would typically call
        this method from the code of a Python-defined SOP.

        Raises hou.OperationFailed if no attribute exists with this name or if
        the attribute's data type does not match the value passed in. If the
        attribute's size is more than 1, the attribute value must be a sequence
        of integers/floats, and the size of the sequence must match the
        attribute's size.

        Raises hou.GeometryPermissionError if this geometry is not modifiable.

          # This code will work from inside a Python SOP, but not from the Python
          # shell.
          geo = hou.pwd().geometry()
          geo.addAttrib(hou.attribType.Global, "author", "")
          geo.addAttrib(hou.attribType.Global, "version", (0, 0, 0))
          geo.setGlobalAttribValue("author", "Joe")
          geo.setGlobalAttribValue("version", (1, 0, 7))

        See also:

        * hou.Geometry.attribValue
        * hou.Point.setAttribValue
        * hou.Prim.setAttribValue
        * hou.Vertex.setAttribValue        """

    def attribValue(self, name_or_attrib):
        """
        attribValue(self, name_or_attrib) -> int, float, str, or tuple

        Return the global (a.k.a. detail) attribute value for a particular
        attribute.  The attribute may be specified by name or by hou.Attrib
        object.

        Raises hou.OperationFailed if no attribute exists with this name.

        REPLACES
            detail function
            detailattribsize function
            details function        """

    def intrinsicNames(self):
        """
        intrinsicNames(self) -> tuple of str

        Returns a tuple of strings representing the intrinsic values available
        for this geometry. Different geometry types will have different
        intrinsic values available. You can then get or set the value using
        intrinsicValue and/or setIntrinsicValue.

        See the intrinsicValue method for more information.
        """
        return ('',)

    def intrinsicValue(self, intrinsic_name):
        """
        intrinsicValue(self, intrinsic_name) -> int, float, str, or tuple

        Gets the value of an "intrinsic", often computed, value of the
        geometry, such as memoryusage, pointcount, pointattributes, and so on.
        Raises OperationFailed if the given intrinsic name does not exist.

        You can also view these values in the user interface using the geometry
        spreadsheet.

        In Houdini, some primitives have "intrinsic" values which can't be
        accessed directly through the attribute interface. Most intrinsic values
        are computed, such as measuredarea, however a few are writeable with the
        setIntrinsicValue method. For example, sphere primitives have a
        transform matrix as part of their definition.

        You can get a list of the available intrinsic value names with the
        intrinsicNames method. Different geometry types will have different
        intrinsic values available.
        """

    def intrinsicSize(self): return
    def intrinsicReadOnly(self): return
    def setIntrinsicValue(self, intrinsic_name, value):
        """
        setIntrinsicValue(self, intrinsic_name, value)

        Some "intrinsic" values can be modified. For example, you change the
        internal size and rotation (transform) of a sphere primitive by passing
        a 16 float tuple representing the transform to setIntrinsicValue. Raises
        Error if the intrinsic is not writeable or does not accept the passed
        value, or if the given intrinsic name does not exist.


        Modifying the geometry directly will lock the geometry's parent node.

        See the intrinsicValue method for more information.
        """

    def saveToFile(self, file_name):
        """
        loadFromFile(self, file_name)

        Replace the contents of this geometry object with the data stored in a
        file.  You would typically call this method from the code of a Python-
        defined SOP.

        You may specify any type of file supported by Houdini's File SOP.  See
        hou.Geometry.saveToFile for more information.

        Raises hou.OperationFailed if the file does not exist or otherwise
        cannot be loaded.

        Raises hou.GeometryPermissionError if this geometry is not modifiable.

        See also hou.Geometry.merge.
        """

    def loadFromFile(self, path): return
    def merge(self, geometry):
        """
        merge(self, geometry)

        Merge the points and primitives from another hou.Geometry object into
        this one.  The new points and primitives are appended to this geometry's
        points and primitives.  You would typically call this method from the
        code of a Python-defined SOP.

        Raises hou.GeometryPermissionError if this geometry is not modifiable.

        See also hou.Geometry.loadFromFile.
        """

    def clear(self):
        """
        clear(self)

        Remove everything from this geometry object.  The geometry will have no
        points or primitives after calling this method.

        Raises hou.GeometryPermissionError if this geometry is not modifiable.
        """

    def pointGroups(self):
        """
        pointGroups(self) -> tuple of hou.PointGroup

        Return a tuple of all the point groups in the geometry.

        The following function returns the names of all the groups in the
        geometry:
          def pointGroupNames(geometry):
              return [group.name() for group in geometry.pointGroups()]


        REPLACES
            pointgrouplist function        """
        return (PointGroup(),)

    def findPointGroup(self, name):
        """
        findPointGroup(self, name) -> hou.PointGroup or None

        Return the point group with the given name, or None if no such group
        exists.
        """
        return PointGroup()

    def createPointGroup(self, name, is_ordered=False):
        """
        createPointGroup(self, name, is_ordered=False) -> hou.PointGroup

        Create a new point group in this geometry.

        name
            The name of the new group.  Raises hou.OperationFailed if a group
            with this name already exists.

        is_ordered
            Whether or not the new group should be ordered.  See hou.PointGroup
            for more information about ordered groups.

        Use hou.PointGroup.destroy to remove a primitive group from the
        geometry.
        """
        return PointGroup()

    def primGroups(self):
        """
        primGroups(self) -> tuple of hou.PrimGroup

        Return a tuple of all the primitive groups in the geometry.

        REPLACES
            primgrouplist function        """
        return (PrimGroup(),)

    def findPrimGroup(self, name):
        """
        findPrimGroup(self, name) -> hou.PrimGroup or None

        Return the primitive group with the given name, or None if no such group
        exists.
        """
        return PrimGroup()

    def createPrimGroup(self, name, is_ordered=False):
        """
        createPrimGroup(self, name, is_ordered=False) -> hou.PrimGroup

        Create a new primitive group in this geometry.

        name
            The name of the new group.  Raises hou.OperationFailed if a group
            with this name already exists.

        is_ordered
            Whether or not the new group should be ordered.  See hou.PrimGroup
            for more information about ordered groups.

        Use hou.PrimGroup.destroy to remove a primitive group from the geometry.
        """
        return PrimGroup()

    def edgeGroups(self):
        """
        edgeGroups(self) -> tuple of hou.EdgeGroup

        Return a tuple of all the edge groups in the geometry.
        """
        return (EdgeGroup(),)

    def findEdgeGroup(self, name):
        """
        findEdgeGroup(self, name) -> hou.EdgeGroup or None

        name
            The name of the edge group.

        Return the edge group with the given name, or None if no such group
        exists.
        """
        return EdgeGroup()

    def createEdgeGroup(self, name):
        """
        createEdgeGroup(self, name) -> hou.EdgeGroup

        Create a new edge group in this geometry.

        name
            The name of the new group.  Raises hou.OperationFailed if a group
            with this name already exists.

        Use hou.EdgeGroup.destroy to remove an edge group from the geometry.
        """
        return EdgeGroup()

    def findEdge(self, p0, p1):
        """
        findEdge(self, p0, p1) -> hou.Edge

        p0
            The first point that makes up the edge.  See hou.Point for more
            information.

        p1
            The second point that makes up the edge.  See hou.Point for more
            information.

        finds an edge given two points, or None if no such edge exists
        """
        return Edge()

    def boundingBox(self):
        """
        boundingBox(self) -> hou.BoundingBox

        Return an axis-aligned 3D bounding box that is sized and positioned to
        be large enough to hold this geometry.

        REPLACES
            bbox function        """
        return BoundingBox()

    def nearestPrim(self, position):
        """
        nearestPrim(self, position) -> (hou.Prim or None, float, float, float)

        Given a sequence of three floats containing a position, find the
        location on the primitive closest to that position and return a tuple
        containing that primitive, the u value on the primitive, the v value on
        the primitive, and the distance to the primitive.

        Note that the first value in the return tuple can be None if there are
        no primitives in the geometry.

        REPLACES
            xyzdist function        """
        return (Prim(), 0.0,0.0,0.0)

    def _guDetailHandle(self): return

class GeometrySelection(object):
    """
    hou.GeometrySelection

    Represents a component selection performed by the user in a viewport.

    Calling hou.SceneViewer.selectGeometry waits for the user to perform a
    selection in the viewport, and returns an object of this type
    representing the elected components. The returned selection can be
    manipulated by converting it to a specific component type, grown, or
    shrunk. Then the selection can be converted to a string that can be used
    in a SOP node group parameter.

    If the selection contains components from more than one SOP, you can use
    the hou.GeometrySelection.mergedNode function to create a Merge SOP
    and/or Object Merge SOPs that brings all the referenced geometry into a
    single node.
    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def ordered(self):
        """
        ordered(self) -> bool

        Returns true if this is an ordered selection. This means that the order
        in which the user selected the components is preserved. To have an
        ordered selection, the ordered parameter needs to have been set to True
        when calling hou.SceneViewer.geometrySelection.
        """
        return True

    def geometryType(self):
        """
        geometryType(self) -> hou.geometryType enum value

        Returns the type of component that was selected.
        """
        return geometryType()

    def setGeometryType(self, type):
        """
        setGeometryType(self, type)

        Changes the type of component contained in the selection, converting the
        existing selection to the new comonent type.
        """

    def connectivity(self):
        """
        connectivity(self) -> hou.connectivityType enum value

        Returns the hou.connectivityType that has been set on this geometry
        selection. Unlesss you call hou.GeometrySelection.setConnectivity, this
        function will return the no connectivity value.
        """
        return connectivityType()

    def setConnectivity(self, connectivity):
        """
        setConnectivity(self, connectivity)

        Sets the type of connectivity to enforce when modifying the selection.
        The current selection is also expanded so that all connected components
        (using the supplied style of connectivity) become part of the selection.
        """

    def primitiveTypes(self):
        """
        primitiveTypes(self) -> tuple of hou.primitiveType enum values

        Returns a tuple containing all primitive types that are contained in the
        selection.
        """
        return (primitiveType(),)

    def setPrimitiveTypes(self, primitive_types):
        """
        setPrimitiveTypes(self, primitive_types)

        Sets the tuple of primitive types allowed in the selection. Any
        primtives that are not of an allowed type are removed from the
        selection. Only has an effect if this is a primitive selection.
        """

    def nodes(self):
        """
        nodes(self) -> tuple of Nodes

        Returns a tuple of all nodes referenced by the selection.
        """
        return (Node(),)

    def selectionStrings(self, empty_string_selects_all=True, bool=True,
        force_numeric=False):
        """
        selectionStrings(self, empty_string_selects_all=True, bool
        force_numeric=False) -> tuple of strings

        Returns a tuple of strings that can be used to refer to the selected
        components in each individual SOP node referenced by the selection.
        """
        return ('',)

    def needsMergedNode(self, parent):
        """
        needsMergedNode(self, parent) -> bool

        Returns true if a Merge SOP needs to be created in order to access all
        components in the selection.
        """
        return True

    def mergedNode(self, parent, creator_name,
        force_keep_original_objects=False, display_original_objects=False):
        """
        mergedNode(self, parent, creator_name,
        force_keep_original_objects=False, display_original_objects=False) ->
        Node

        Creates a Merge SOP that combines all the SOPs referenced by the
        selection. Most selections will only reference a single SOP in which
        case no Merge SOP is required, and the selected SOP will be returned.
        """
        return Node()

    def mergedSelectionString(self, empty_string_selects_all=True,
        force_numeric=False):
        """
        mergedSelectionString(self, empty_string_selects_all=True,
        force_numeric=False) -> string

        Returns a single string that can be used in group parameters of the
        merged node returned by hou.GeometrySelection.mergedNode. If all
        components are selected from a single node this is equivalent to the
        first string in the tuple returned by
        hou.GeometrySelection.selectionStrings.
        """
        return ''

    def shrinkSelection(checkuv = True):
        """
        shrinkSelection(checkuv = true)

        Removes components that are on the boundary of the selection.
        """

    def growSelection(self):
        """
        growSelection()

        Expands the selection by adding all components that are connected to
        components currently in the selection.
        """

class GeometryViewport(object):
    """
    hou.GeometryViewport

    REPLACES
      * viewcamera
      * viewhome
      * viewwrite
    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def type(self):
        """
        type(self) -> hou.geometryViewportType enum value
        """
        return geometryViewportType()

    def settings(self):
        """
        settings(self) -> hou.GeometryViewportSettings
        """
        return GeometryViewportSettings()

    def name(self):
        """
        name(self) -> str
        """
        return ''

    def home(self):
        """
        home(self)
        """

    def homeAll(self):
        """
        homeAll(self)

        Homes the viewport on all geometry objects.
        """

    def homeSelected(self):
        """
        homeSelected(self)
        Homes the viewport on the selected geometry.
        """

    def homeGrid(self):
        """
        homeGrid(self)
        Homes the viewport on the grid.
        """

    def homeNonTemplated(self):
        """
        homeNonTemplated(self)
        Homes the viewport on all non-templated geometry.
        """

    def frameAll(self):
        """
        frameAll(self)

        Frames the viewport on all geometry objects.
        """

    def frameSelected(self):
        """
        frameSelected(self)

        Frames the viewport on the selected geometry.
        """

    def frameGrid(self):
        """
        frameGrid(self)

        Frames the viewport on the grid.
        """

    def frameNonTemplated(self):
        """
        frameNonTemplated(self)

        Frames the viewport on all non-templated geometry.
        """

    def viewTransform(self):
        """
        viewTransform(self)

        Returns the transform matrix of the viewport.
        """
        return Matrix4()

    def camera(self): return ObjNode ()
    def setCamera(self, camera_node):
        """
        setCamera(self, camera_node)

        Makes the viewport look through the given camera node.
        """

    def saveViewToCamera(self, camera_node):
        """
        saveViewToCamera(self, camera_node)

        Saves the viewport's current view into the given camera node.  It does
        this by setting the camera's transform parameters to match the
        viewport's view transform matrix.
        """

    def queryNodeAtPixel(self, x, y):
        """
        queryNodeAtPixel(self, x, y) -> hou.ObjNode, hou.SopNode, or None

        Return the node draw at the specified pixel in the viewport, or None if
        there is nothing there.  The type of node returned depends on the level
        of the viewer.
        """
        return Node()

    def queryPrimAtPixel(self, node, x, y):
        """
        queryPrimAtPixel(self, node, x, y) -> hou.Prim or None

        Return the primitive drawn at the specified pixel in the viewport, or
        None if there is nothing there.  The primitive returned will be a
        subclass of hou.Prim.

        The parameter node is used to restrict the query to geometry within a
        particular node. If node is None, then the query is unrestricted.
        """
        return Prim()

    def queryInspectedGeometry(self):
        """
        queryInspectedGeometry(self) -> hou.Geometry or None

        Return the geometry currently being inspected in the viewport, or None
        when nothing is being inspected or when called outside of an inspect
        script.
        """
        return Geometry()

    def queryInspectedPrim(self):
        """
        queryInspectedPrim(self) -> hou.Prim or None

        Return the primitive currently being inspected in the viewport, or None
        when nothing is being inspected or when called outside of an inspect
        script.  The primitive returned will be a subclass of hou.Prim.
        """
        return Prim()

    def mapToWorld(self, x, y):
        """
        mapToWorld(self, x, y) -> tuple of (hou.Vector3, hou.Vector3)

        Convert viewport coordinates to world coordinates. Returns a ray
        (direction vector and an origin point).
        """
        return (Vector3(), Vector3())

    def mapFromMouseChop(self, x, y):
        """
        mapFromMouseChop(self, x, y) -> tuple of (hou.Vector3, hou.Vector3)

        Convert from the Mouse CHOP's X and Y screen values (which range from -1
        to 1) to viewport coordinates, where (0,0) is the bottom left corner of
        the viewport.
        """
        return (Vector3(), Vector3())

class GeometryViewportSettings(object):
    """
    hou.GeometryViewportSettings

    REPLACES
      * cplane
      * viewbackground
      * viewcamera
      * viewcopy
      * viewdisplay
      * viewls
      * viewname
      * vieworthogrid
      * viewprojection
      * viewsnapshot
      * viewtransform
      * viewtype
      * viewuvgrid
    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def viewportType(self):
        """
        viewportType(self) -> hou.geometryViewportType enum value
        """
        return geometryViewportType()

    def normalScale(self):
        """
        normalScale(self) -> float
        """
        return 0.0

    def setNormalScale(self, normal_scale):
        """
        setNormalScale(self, normal_scale)
        """

    def camera(self):
        """
        camera(self) -> ObjNode or None

        Return the camera or light node that the viewport is looking through.
        Return None if the viewport is not looking through a camera or light
        node.
        """
        return ObjNode()

    def setCamera(self, camera_node):
        """
        setCamera(self, camera_node)
        Makes the viewport look through the given camera node.
        """

    def saveViewToCamera(self):
        """
        saveViewToCamera(self, camera_node)
        Saves the viewport's current view into the given camera node.  It does
        this by setting the camera's transform parameters to match the
        viewport's view transform matrix.
        """

    def setSceneAntialias(self, aalevel):
        """
        setSceneAntialias(self, aalevel)
        Sets the viewports full-scene antialiasing level to one of 1, 2, 4 or 8.
        This represents the number of samples rendered to produce a  higher
        quality image. Higher numbers produce better antialiasing, but this can
        affect the viewport's rendering performance.
        """

    def sceneAntialias(self):
        """
        sceneAntialias(self)
        Returns the number of samples used to antialias the viewport. Possible
        values are 1 (no antialiasing, default), 2, 4 or 8.
        """

class _GUDetailHandle(object):

    def __init__(self): raise AttributeError, "No constructor defined"
    def isReadOnly(self): return True
    def destroy(self): return

class hda(object):
    """
    hou.hda
    Module containing functions related to Houdini Digital Assets.
    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def installFile(file_path, oplibraries_file=None,
        change_oplibraries_file=True, force_use_assets=False):
        """
        installFile(file_path, oplibraries_file=None,
        change_oplibraries_file=True, force_use_assets=False)

        Install all the node types defined in an otl file into the current
        Houdini session.  This function is equivalent to File > Install Digital
        Asset Library... in Houdini.

        file_path
            The otl file to load.

        oplibraries_file
            The path to an OPlibraries file or None.  OPlibraries files are text
            files containing lists of otl files to load on startup.  When
            Houdini starts up it reads all the OPlibraries files it finds in the
            Houdini path and loads all the otl files listed in them.  By
            creating OPlibraries files in $HOME/houdiniX.Y, $HSITE/houdiniX.Y,
            $JOB, etc. you can create libraries that are specific to a
            particular user, studio, job, etc.

            This parameter is only meaningful when change_oplibraries_file is
            True.

            Note that OPlibraries are only used when the Use OPlibraries files
            to find OTLS checkbox in the Configuration tab of the Operator Type
            Manager is checked.

            If None or "Current HIP File", the otl file is loaded only into
            the current Houdini session.  The file name will also be saved in
            the Hip file so that when the same Hip file is loaded, the otl file
            will also be loaded automatically.

            If "Scanned OTL Directories", this is equivalent to the
            installation menu entry in the Install Digital Asset Library dialog.

        change_oplibraries_file
            When oplibraries_file is not None and this parameter is True,
            Houdini will modify the OPlibraries file, adding the otl file to it.

        force_use_assets
            When True, ensure that the definitions inside the otl file are
            current.  If they would not otherwise provide the current
            definition, they are marked as preferred to ensure they are current.
            See hou.HDADefinition.isPreferred for more information.

        Note that, if you do not store the path to the otl file in an
        OPlibraries file, Houdini will store it in the current Houdini session.
        So, when you load a hip file, it will try to load the otl files that it
        references.

        REPLACES
            otload command        """

    def uninstallFile(file_path, oplibraries_file=None,
        change_oplibraries_file=True):
        """
        uninstallFile(file_path, oplibraries_file=None,
        change_oplibraries_file=True)

        Uninstall an otl file and all the node type definitions it provides from
        the current Houdini session.  The otl file and its contents on disk are
        unchanged.

        You can set file_path to the special name "Embedded" to refer to the
        digital assets embedded in the current hip file.  The following example
        removes any embedded digital asset definitions from the current Houdini
        session:
          hou.hda.uninstallFile("Embedded")


        If oplibraries_file is not None and change_oplibraries_file is True,
        Houdini will remove the path to the otl from the specified OPlibraries
        file.  See hou.hda.installFile for more information about these
        parameters.

        If all the definitions of a node type are uninstalled, any instances of
        that node type will warn that they are using an incomplete asset
        definition.  They will, however, retain their parameter values as spare
        parameters.  Installing an otl file with the missing node type will
        restore those node instances and remove the warnings.

        See also hou.HDADefinition.destroy.

        REPLACES
            otunload command        """

    def reloadFile(file_path):
        """
        reloadFile(file_path)

        Reload the contents of an otl file, loading any updated digital asset
        definitions inside it.

        You only need to call this function if an otl file was modified from
        outside the current Houdini session.

        REPLACES
            otrefresh command        """

    def expandToDirectory(file_path, directory_path):
        """
        expandToDirectory(file_path, directory_path)

        Expand the contents of the otl file in file_path into the directory
        directory_path.  If the directory does not already exist it is created.

        When expanding an otl file, Houdini puts each digital asset definition
        in the file into its own directory.  As well, it puts each section
        inside a definition into its own file.  Each directory inside the
        expanded file tree contains a Sections.List file that maps the actual
        file or directory names into the section names, since section names may
        contain characters that cannot occur in directory or file names.  See
        hou.HDASection for more information about sections.

        This function provides an easy way to inspect and modify the contents of
        an otl file.  See also hou.hda.collapseFromDirectory.

        REPLACES
            otexpand command        """

    def collapseFromDirectory(file_path, directory_path):
        """
        collapseFromDirectory(file_path, directory_path)

        Given a directory that contains a previously expanded otl file, collapse
        it into the otl file specified by file_path.

        This function provides the inverse of hou.hda.expandToDirectory.

        REPLACES
            otcollapse command        """

    def loadedFiles(self):
        """
        loadedFiles() -> tuple of str

        Return a tuple of paths to the otl files that are loaded into the
        current Houdini session.

        This method is can be approximately implemented as follows:
          def loadedFiles():
              '''Return a list of otl files loaded into this Houdini session.'''
              # Look through all the node types, and for those that have digital
              # asset definitions, remember the otl file containing the definition.
              result = []
              for category in hou.nodeTypeCategories().values():
                  for node_type in category.nodeTypes().values():
                      definition = node_type.definition()
                      if definition is None:
                          continue
                      if definition.libraryFilePath() not in result:
                          result.append(definition.libraryFilePath())
              return result


        See hou.HDADefinition.isCurrent for an example.

        REPLACES
            otrefresh command
            otls command        """
        return ('',)

    def renameSource(oplibraries_file, source_name=None):
        """
        renameSource(oplibraries_file, source_name=None)

        Give a name to an OPlibraries file.  This name appears in the Operator
        Type Manager's list of OPlibraries file.  If source_name is None, the
        name is removed from the OPlibraries file.

        If the oplibraries_file does not already exist, it is created.

        See hou.hda.installFile for more information about OPlibraries files.

        REPLACES
            otrenamesource command        """

    def definitionsInFile(file_path):
        """
        definitionsInFile(file_path) -> tuple of hou.HDADefinition

        Return all the digital asset definitions inside an otl file.  See
        hou.HDADefinition for more information.

        Raises hou.OperationFailed if file_path does not refer to a valid otl
        file.

          # Print the node types defined by digital assets in $HOME/houdiniX.Y/otls/OPcustom.otl:
          >>> import os
          >>> my_otl_file = "%s/otls/OPcustom.otl" % hou.homeHoudiniDirectory()
          >>> for definition in hou.hda.definitionsInFile(my_otl_file):
          ...     print definition.nodeTypeCategory().name() + "/" + definition.nodeTypeName()
          Sop/gcoggeo
          Sop/gCogFlatGeo
          Sop/gDivideAtCentroid
          Object/gAxle
          Object/gCog

        REPLACES
            otglob command
            otls command        """
        return (HDADefinition(),)

    def componentsFromFullNodeTypeName(node_type_name):
        """
        componentsFromFullNodeTypeName(node_type_name) -> tuple of str

        Returns a tuple of operator type name components that constitute the
        full node type name. The components in the tuple appear in the following
        order: scope network type, node type namespace, node type core name, and
        version.

          >>> # Parse the full name into components
          >>> hou.hda.componentsFromFullNodeTypeName('MyUserNamespace::MyHDA::2.5')
          ('', 'MyUserNamespace', 'MyHDA', '2.5')
          >>> hou.hda.componentsFromFullNodeTypeName('Sop/foreach::MyCounterHDA')
          ('Sop/foreach', '', 'MyCounterHDA', '')
        """
        return ('',)

    def fullNodeTypeNameFromComponents(scope_node_type, name_space, name,
        version):
        """
        fullNodeTypeNameFromComponents(scope_node_type, name_space, name,
        version) -> str

        Returns a full node type name build out of the given components. The
        arguments represent the following components: scope network type, node
        type namespace, node type core name, and version.

          >>> # Compose the node type full name from components
          >>> hou.hda.fullNodeTypeNameFromComponents('', 'userA', 'sphere', '')
          'userA::sphere'
          >>> hou.hda.fullNodeTypeNameFromComponents('', 'userB', 'myHda', '2.6')
          'userB::myHda::2.6'
          >>> hou.hda.fullNodeTypeNameFromComponents('Sop/foreach', '', 'MyCounterHDA', '')
          'Sop/foreach::MyCounterHDA'
        """
        return ''

    def changeCurrentStoreUser(self): return

class HDADefinition(object):
    """
    hou.HDADefinition

    Represents the definition of a houdini digital asset (HDA).

    A digital asset definition defines a node type and exists inside an otl
    file. The node type is implemented in terms of other nodes wired
    together inside a subnet.  These nodes inside the subnet are called the
    definition's contents.

    An otl file contains one or more digital asset definitions, and
    installing an otl file installs all the definitions in the file.  When a
    digital asset definition is installed, the node type it defines is added
    to Houdini.  Note that you can access an HDADefinition without
    installing it.

    A digital asset's algorithm is determined by the nodes inside it.  To
    edit those nodes you create an instance of the digital asset, unlock it,
    modify the contents, and save the definition.  New digital asset
    instances are normally locked, meaning that they are read-only, and they
    automatically update when the asset's definition changes.  An unlocked
    instance is editable, does not update when the definition changes, and
    you can save its contents to change the definition.

    To unlock a node, select Allow Editing of Contents or call
    hou.Node.allowEditingOfContents.  To save the contents of an unlocked
    node to the definition, select Save Operator Type or call
    hou.HDADefinition.updateFromNode.  To revert an unlocked instance back
    to the last saved definition and change it back into a locked instance,
    select Match Current Definition or call hou.Node.matchCurrentDefinition.

    See also hou.hda and hou.HDAOptions.


    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def nodeType(self):
        """
        nodeType(self) -> hou.NodeType

        Return the node type defined by this digital asset.  Raises
        hou.OperationFailed if the digital asset is not installed.

        REPLACES
            otinuse command        """
        return NodeType()

    def nodeTypeCategory(self):
        """
        nodeTypeCategory(self) -> hou.NodeTypeCategory

        Return the node type category (e.g. Objects, SOPs, DOPs, etc.) for the
        node type defined by this digital asset.  See hou.NodeTypeCategory for
        more information.

        It is safe to call this method if the digital asset is not installed.
        If the digital asset is installed, this method is equivalent to
        self.nodeType().category().

        REPLACES
            otls command        """
        return NodeTypeCategory()

    def nodeTypeName(self):
        """
        nodeTypeName(self) -> str

        Return the name of the node type defined by this digital asset.  Raises
        hou.OperationFailed if the digital asset is not installed.

        If the digital asset is installed, this method is a shortcut for
        self.nodeType().name().

        REPLACES
            otinuse command
            otls command        """
        return ''

    def libraryFilePath(self):
        """
        libraryFilePath(self) -> str

        Return the path to the otl file containing the digital asset's
        definition.

        Note that it is possible to save an asset with a hip file, without
        storing it in an otl file.  In this case, this method returns
        "Embedded".

        REPLACES
            dsoinfo command
            otgetotl command
            otls command        """
        return ''

    def embeddedHelp(self):
        """
        embeddedHelp(self) -> str

        Return the help text embedded in the digital asset.  Return an empty
        string if no embedded help exists.

        Embedded help typically comes from the Help tab of the operator type
        properties window, but it may also come from a dialog script.
        """
        return ''

    def isInstalled(self):
        """
        isInstalled(self) -> bool

        Return whether this definition is installed in Houdini.

        It is possible to access HDADefinition objects in otl files that are not
        installed with hou.hda.definitionsInFile.

        See also hou.hda.installFile.

        REPLACES
            otinuse command        """
        return True

    def installed(self): return True
    def isCurrent(self):
        """
        isCurrent(self) -> bool

        Return whether this definition is the one currently in use by Houdini.

        This example shows how you can access other definitions for the same
        node type:
          def otherDefinitions(definition):
              '''Given an HDADefinition object, return the other loaded definitions
                 for the same node type.'''
              # Look through all the loaded otl files for definitions providing
              # the same node type.
              result = []
              for otl_file in hou.hda.loadedFiles():
                  # Skip the otl file containing the definition that was passed in.
                  if otl_file == definition.libraryFilePath():
                      continue

                  for other_definition in hou.hda.definitionsInFile(otl_file):
                      if other_definition.nodeType() == definition.nodeType():
                          result.append(other_definition)
              return result


          # Print the paths to otl files providing other definitions for a digital asset instance.
          >>> for other_definition in otherDefinitions(hou.node("/obj/my_hda1").type().definition()):
          ...     print other_definition.libraryFilePath()
          /path/to/file1.otl
          /path/to/file2.otl
        """
        return True

    def current(self): return True
    def isPreferred(self):
        """
        isPreferred(self) -> bool

        Return whether this definition is preferred.

        After loading otl files, Houdini uses a set of rules to resolve
        conflicts when it encounters multiple definitions for the same node type
        (e.g. preferring the most recent otl file, preferring definitions
        embedded in the hip file, etc.).  When these rules do not use the
        definition you want, you can override them by explicitly marking a
        definition as preferred.  Houdini saves this list of preferred
        definitions with the hip file.  Marking a definition as not preferred
        will remove it from this list, and the normal rules will apply again.

        REPLACES
            otprefer command        """
        return True

    def preferred(self): return True
    def setIsPreferred(self, preferred):
        """
        setIsPreferred(self, preferred)

        Set whether this definition is preferred.  See
        hou.HDADefinition.isPreferred for more information.

        REPLACES
            otprefer command        """

    def setPreferred(self): return
    def sections(self):
        """
        sections(self) -> dict of str to hou.HDASection

        Return a dictionary mapping section names to hou.HDASection objects. See
        hou.HDASection for more information on sections.

        REPLACES
            otcontentls command        """
        return {'':HDASection()}
    def addParmFolder(self):
        """
        Adds a folder to this node types parameters.
        :return:
        """

    def addParmTuple(self):
        """Add a parameter tuple to this node types parameters. Houdini places the new parameter at the bottom of the parameters in a particular folder.
         """
    def addSection(name, contents=""):
        """
        addSection(self, name, contents="") -> hou.HDASection

        Create a new section with the specified contents.  If a section already
        exists with this name, changes the existing contents to the new
        contents. Note that the contents may contain binary data.  Also note
        that section names may contain '/'.

        See hou.HDASection for more information on sections.  To remove a
        section, use hou.HDASection.destroy.

        Sections can have associated properties stored in the
        hou.HDADefinition.extraFileOptions.

          def addSectionFromFile(hda_definition, section_name, file_name):
              '''Add a section whose contents come from a file.  If the section
                 already exists, replace its contents.'''
              section_file = open(file_name, "r")
              hda_definition.addSection(section_name, section_file.read())
              section_file.close()

        REPLACES
            otcontentadd command        """
        return HDASection()

    def removeSection(name):
        """
        removeSection(self, name)

        Remove an existing section.  Only remove sections that you explicitly
        added.  Do not remove the special sections that Houdini uses to store
        the contents of the digital asset definition, or Houdini will generate
        errors or strange side effects.

        See hou.HDASection for more information on sections.  Note that
        hou.HDASection.destroy will also remove a section.

        Raises hou.OperationFailed if no such section exists in the definition.
        """

    def description(self):
        """
        description(self) -> str

        Return the description for this definition's node type.  Houdini uses
        this description for user interface elements such as the TAB menu. This
        description is also called the operator label in Houdini.

        See also hou.NodeType.description.
        """
        return ''

    def setDescription(self, description):
        """
        setDescription(self, description)

        Set the description for this definition's node type. Houdini uses this
        description for user interface elements such as the TAB menu. This
        description is also called the operator label in Houdini.

        See also hou.HDADefinition.description and hou.NodeType.description.
        """
        pass

    def icon(self):
        """
        icon(self) -> str

        Return the name or path of the icon for this definition's node type.
        Note that Houdini uses its search path to locate icons, so you do not
        need to pass in a full path.

        See also hou.NodeType.icon.

        REPLACES
            otls command        """
        return ''

    def setIcon(self, icon):
        """
        setIcon(self, icon)

        Set the icon for this definition's node type.  See
        hou.HDADefinition.icon for more information.
        """
        pass

    def minNumInputs(self):
        """
        minNumInputs(self) -> int

        Return the minimum number of connected inputs that node instances of
        this digital asset can have.  If these inputs are not connected, the
        node will generate an error.

        See also hou.NodeType.minNumInputs.

        REPLACES
            otls command        """
        return 0

    def setMinNumInputs(self, min_num_inputs):
        """
        setMinNumInputs(self, min_num_inputs)

        Set the minimum number of connected inputs that node instances of this
        digital asset must have.  min_num_inputs must be between 0 and 4,
        inclusive.  If a node does not have the minimum number of inputs, it
        will generate an error.
        """

    def maxNumInputs(self):
        """
        maxNumInputs(self) -> int

        Return the maximum number of inputs that node instances of this digital
        asset can have.  Return a number greater than 4 if this node type can
        accept an unlimited number of inputs.

        See also hou.NodeType.maxNumInputs.

        REPLACES
            otls command        """
        return 0

    def setMaxNumInputs(self, max_num_inputs):
        """
        setMaxNumInputs(self, max_num_inputs)

        Set the maximum number of inputs that node instances of this digital
        asset may have.  This number must be greater than or equal to the
        minimum number of inputs.  If it is 5 or greater, Houdini will use a
        merge SOP-style input connector that allows an unlimited number of
        inputs. Otherwise, the node will have between 0 and 4 input connectors,
        each of which may or may not be connected, that correspond to the subnet
        indirect inputs inside the digital asset.

        See hou.Node.inputConnectors and hou.SubnetIndirectInput for more
        information on input connectors and subnet indirect inputs.
        """

    def extraInfo(self):
        """
        extraInfo(self) -> str

        Return a string storing extra information about the asset definition
        that isn't stored elsewhere, like the representative node, guide
        geometry, whether default parameters are hidden, etc.

        See also hou.HDADefinition.representativeNodePath and
        hou.HDADefinition.hideDefaultParameters to more easily retrieve some
        portions of the extra info.

        REPLACES
            otls command        """
        return ''

    def setExtraInfo(self, extra_info):
        """
        setExtraInfo(self, extra_info)

        Set extra information about the asset definition that isn't stored
        elsewhere, like the representative node, guide geometry, etc.  This
        string is encoded in a specific format, so it is recommended that you
        only call this method with values returned from
        hou.HDADefinition.extraInfo.
        """

    def hideDefaultParameters(self):
        """
        hideDefaultParameters(self) -> bool

        Return whether the parameters that are common to nodes types in this
        node type category are hidden or not.  For example, nearly all objects
        have common translation, rotation, scale, etc. parameters, and object
        level digital assets have these parameters by default.  If hidden,
        though, these parameters are still there but are not displayed to the
        user.

        Note that this value is also stored in the string returned by
        hou.HDADefinition.extraInfo.
        """
        return True

    def representativeNodePath(self):
        """
        representativeNodePath(self) -> str

        Return the contents of the Representative Node field on the Basic tab of
        the Type Properties dialog.

        For object-level digital assets that contain other object nodes, it is
        possible to make Houdini treat your digital asset like a camera or light
        by choosing a node inside the asset to represent it.  For example, if
        you choose a camera inside the asset as the representative node,
        instances of the digital asset will appear in the viewport's list of
        camera objects.

        Note that this value is also stored in the string returned by
        hou.HDADefinition.extraInfo.
        """
        return ''

    def comment(self): return ''
    def setComment(self, comment): return
    def version(self): return ''
    def setVersion(self): return
    def modificationTime(self):
        """
        modificationTime(self) -> int

        Return the time when the definition was last modified.  This time is
        returned as a POSIX timestamp, such as is returned by time.time().

          >>> import time
          >>> time.ctime(hou.nodeType(hou.objNodeTypeCategory(), "toon_character").
          ...     definition().modificationTime())
          'Thu Nov  6 18:22:38 2008'

        REPLACES
            otls command        """
        return 0

    def setModificationTime(self, time=-1):
        """
        setModificationTime(self, time=-1)

        Set the modification time for the definition to the given POSIX
        timestamp. If the time parameter is negative, uses the current time.

        See also hou.HDADefinition.modificationTime.

        REPLACES
            ottouch command        """

    def options(self):
        """
        options(self) -> hou.HDAOptions

        Return a hou.HDAOptions object for the options stored in this digital
        asset.  See hou.HDAOptions for more information.
        """
        return HDAOptions()

    def setOptions(self, options):
        """
        setOptions(self, options)

        Set this digital asset definition's options to the data in a
        hou.HDAOptions object.  See hou.HDAOptions for more information.
        """

    def updateFromNode(self, node):
        """
        updateFromNode(self, node)

        Update and save the definition to match the contents of a given unlocked
        instance of the asset.  Calling this method is the same as selecting
        Save Operator Type on the node's menu.

          def saveUnlockedNodes():
              '''Look through all the nodes in the file for unlocked digital asset
                 instances and save and lock them.'''
              for node in hou.node("/").allSubChildren():
                  if node.type().definition() is None or node.isLocked():
                      continue

                  node.type().definition().updateFromNode(node)
                  node.matchCurrentDefinition()
        """

    def save(self, file_name, template_node=None, options=None):
        """
        save(self, file_name, template_node=None, options=None)

        Save the definition into an otl file.

        file_name
            Where to save the definition.  To save to the current otl file, use
            the return value from hou.HDADefinition.libraryFilePath.

        template_node
            Either None or a hou.Node object containing an unlocked instance of
            the digital asset that defines the definition's new contents. If
            None, this method does not update the definition's contents.

        options
            Either None or a hou.HDAOptions object that specifies extra
            behaviors of the definition.  If template_node is not None, the
            compressContents, lockContents, saveSpareParms, and
            makeInitialParmsDefaults values of the hou.HDAOptions object are
            used.  Otherwise, only the compressContents value is used.

        See also hou.HDADefinition.updateFromNode for a way to save an unlocked
        node's definition to the current otl file.  See also
        hou.HDADefinition.copyToHDAFile.

        REPLACES
            otwrite command        """

    def copyToHDAFile(self, file_name, new_name=None, new_menu_name=None):
        """
        copyToHDAFile(self, file_name, new_name=None, new_menu_name=None)

        Copy this definition into an otl file.

        file_name
            The otl file where the definition will be saved.  If the file does
            not already exist, it will be created.  If it already contains a
            definition for this node type, it will be overwritten.

        new_name
            The new name of the node type.  If None, the definition will be
            saved as the existing node type name.  See also hou.NodeType.name.

        new_menu_name
            The new description of the node type that appears in the tab menu.
            If None, Houdini will use the existing description.  Note that the
            node type name must be unique within the otl file, so saving the
            definition with a new description to an otl file containing a
            definition with the old node name will still overwrite the existing
            definition.  See also hou.NodeType.description.

        REPLACES
            otcopy command
            otmerge command        """

    def destroy(self):
        """
        destroy(self)

        Uninstall this definition and _delete it from the otl file_.  Any node
        instances of this asset will warn that they are using an incomplete
        asset definition.

        See also hou.hda.uninstallFile.

        REPLACES
            otdelete command        """

    def parmTemplateGroup(self):
        """
        parmTemplateGroup(self) -> hou.ParmTemplateGroup

        Return the group of parm templates corresponding to the current
        parameter layout for this node.

        You can edit the parameter layout for this node (add or remove spare
        parameters, reorder or hide built-in parameters, etc.) by getting the
        current parameter group, modifying it, and calling
        hou.Node.setParmTemplateGroup with it.

        The following example creates a geometry object, adds a My Parms folder
        to it, and adds a My Parm float parameter to it in that folder.  The
        parameters are added only to the geometry object created; other geometry
        objects are unaffected.

          >>> node = hou.node("/obj").createNode("geo")
          >>> group = node.parmTemplateGroup()
          >>> folder = hou.FolderParmTemplate("folder", "My Parms")
          >>> folder.addParmTemplate(hou.FloatParmTemplate("myparm", "My Parm", 1))
          >>> group.append(folder)
          >>> node.setParmTemplateGroup(group)

        See hou.ParmTemplateGroup and the setParmTemplateGroup method for more
        information and examples.

        REPLACES
            opspare command        """
        return ParmTemplateGroup()

    def setParmTemplateGroup(self, parm_template_group,
        rename_conflicting_parms=False):
        """
        setParmTemplateGroup(self, parm_template_group,
        rename_conflicting_parms=False)

        Change the spare parameters for this node.

        parm_template_group
            A hou.ParmTemplateGroup object containing the new parameter layout.

        rename_conflicting_parms
            If True, parameters in the group with the same parm tuple names will
            be automatically renamed.  If False and there are parms with the
            same name, this method raises hou.OperationFailed.

        Note that each node type has a set of parameters which must exist and
        must be of certain types.  If your parm template group does not contain
        the required parameters for the node type the will be added at the
        bottom and will be made invisible.  Similarly, if your parm template
        group attempts to modify the type, range, label, or other property of a
        required parameter, all changes to that parameter other than visibility
        settings will be ignored.

        This method is preferred over the other parameter-related methods in
        this class (addSpareParmTuple, removeSpareParmTuple,
        replaceSpareParmTuple, addSpareParmFolder, removeSpareParmFolder)
        because it lets you more easily make manipulate parameters.

        See hou.HDADefinition.setParmTemplateGroup to change the parameter
        interface of a digital asset.

        REPLACES
            opspare command        """

    def setExtraFileOption(self, name, value, type_hint =
        hou.fieldType.NoSuchField):
        """
        setExtraFileOption(self, name, value, type_hint =
        hou.fieldType::NoSuchField)

        Set an entry in the dictionary of extra file options.  See
        hou.HDADefinition.extraFileOptions for more information.

        name
            The name of the option to set.

        value
            An integer, float, string, hou.Vector2, hou.Vector3, hou.Vector4,
            hou.Quaternion, hou.Matrix3, hou.matrix4, or sequence of numbers.

        type_hint
            Used to determine the exact hou.fieldType desired when the specified
            value type is not enough to unambiguously determine it.

        The following example function marks an section, such as OnCreated, as
        containing Python code:
          def markSectionAsPython(definition, section_name):
              definition.setExtraFileOption(section_name + "/IsPython", True)
        """

    def removeExtraFileOption(self, name):
        """
        removeExtraFileOption(self, name)

        Remove an entry in the dictionary of extra file options.  See
        hou.HDADefinition.extraFileOptions for more information.

        Raises hou.OperationFailed if there is no entry in the dictionary with
        this name.
        """

    def compileCodeSection(self, source_section, destination_section):
        """
        compileCodeSection(self, source_section, destination_section)

        This function is deprecated. Compiled VEX code should no longer be
        stored inside of an HDA.
        """

    def extraFileOptions(self):
        """
        extraFileOptions(self) -> dict of str to bool, int, float, str

        Return a dictionary containing the extra options attached to sections in
        the asset's definition.  For example, event handler scripts such as
        OnCreated are stored as sections inside the asset, and extra metadata in
        this dictionary determines whether Houdini runs these scripts as Python
        as as Hscript.

        These is one dictionary for the entire asset, and keys in this
        dictionary are usually of the form section_name/option_name.  For
        example, if the OnCreated section is marked as containing Python code,
        this dictionary will contain "OnCreated/IsPython" set to True.

        Note that the contents of this dictionary are saved in the
        ExtraFileOptions section and are encoded in a binary format.

        See also hou.HDADefinition.setExtraFileOption and
        hou.HDADefinition.removeExtraFileOption.
        """

class HDAModule(object):
    """
    hou.HDAModule

    User-defined Python module containing functions, classes, and constants
    that are stored with and accessed from a digital asset.

    In Python, a module lets you organize functions, classes, and constants
    into a common namespace.  For example, os is a module and os.getcwd is a
    function inside that module, and you access the contents of a module by
    looking up Python attributes on it.

    An HDAModule is a Python module that is associated with a particular
    digital asset type.  It lets you store a library of Python code in one
    location in your asset, and you can invoke that code from parameters,
    event handlers, and callbacks inside that asset.

    The module's source code is stored in the Python Module section of the
    Scripts tab in the Type Properties dialog.  For example, suppose the
    digit asset is an object named gear and the Python Module section
    contains the following:

      def position():
          return (hou.frame() * 1.2, 0.0, 3.2)

      def onButtonPress():
          print "you pressed the button"

      def onLoaded():
          print "onLoaded section running"

    Unlike regular Python modules, which you access by name, you access a
    digital asset's Python module by calling hou.NodeType.hdaModule on its
    node type. For example, suppose you created an object-level digital
    asset named gear and put the above code in its Python Module section.
    You could then access the contents of the Python module as follows:

      >>> node_type = hou.nodeType(hou.objNodeTypeCategory(), "gear")
      >>> node_type.hdaModule().position()
      (1.2, 0.0, 3.2)
      >>> node_type.hdaModule().onButtonPress()
      you pressed the button

    One use for the Python module is drive parameter expressions on nodes
    inside the digital asset.  For example, suppose /obj/gear1 is an
    instance of the digital asset and /obj/gear1/geo1 is a node inside the
    asset.  You could put the following inside geo1's tx parameter
    expression:

      hou.node("..").type().hdaModule().position()[0]

    For convenience, you can also access the module from a node instance of
    the digital asset using hou.Node.hdaModule.  So, you could simplify the
    above expression to:

      hou.node("..").hdaModule().position()[0]

    And since you don't need to use the hou. prefix inside expressions, you
    could further simplify it to:

      node("..").hdaModule().position()[0]

    The following example shows how you might run code in the module from
    the Callback Script field of a button parameter:
      hou.pwd().hdaModule().onButtonPress()


    In an event handler script, such as On Loaded, you can use the kwargs
    dict to access the node type:
      kwargs["type"].hdaModule().onLoaded()


    Note that Houdini creates a local kwargs dict that's accessible from the
    Python Module, too.  It contains one entry with the key "type", to
    give you access to the hou.NodeType defined by the digital asset.

    If you find that a digital asset has too much Python code to store in
    one module, it's possible to create submodules.  For example, if you
    want to create a submodule named bar, put its source code in a new
    digital asset section (say, "bar_PythonModule").  Then, from the
    Python Module section, you can write the following:

      import toolutils
      bar = toolutils.createModuleFromSection("bar", kwargs["type"], "bar_PythonModule")

    bar now appears as a submodule of the main module.  If, for example, the
    bar_PythonModule section contains:

      def foo():
          return 3.2

    then you could write the following from a parameter on the digital asset
    node:

      pwd().hdaModule().bar.foo()

    Note that the Python Module code is stored in a section of the digital
    asset named "PythonModule".  For example, you can get a string
    containing that source code using
    node_type.definition().sections()["PythonModule"].contents().
    """

    def __init__(self): raise AttributeError, "No constructor defined"

class HDAOptions(object):
    """
    hou.HDAOptions

    Stores miscellaneous options about a houdini digital asset (HDA).

    The contents of this object correspond to some of the checkboxes on the
    Basic tab of the Type Properties dialog.  These values are stored in the
    TypePropertiesOptions section of a digital asset definition.

    Call hou.HDADefinition.options to get an HDAOptions instance.  Note that
    an instance of this class is simply a data structure, and is not
    associated with an particular digital asset instance.  In other words,
    changing the values inside this object will not change the digital
    asset. To save these values to the digital asset definition, call
    hou.HDADefinition.setOptions.

      >>> node = hou.node("/obj/my_digital_asset1")
      >>> definition = node.type().definition()
      >>> print definition.sections()['TypePropertiesOptions'].contents()
      ParmsFromVfl := 0;
      PrefixDroppedParmName := 1;
      UseDSParms := 1;
      ForbidOutsideParms := 1;
      LockContents := 1;
      SaveSpareParms := 0; # <-- Currently 0
      CheckExternal := 1;
      GzipContents := 1;
      MakeDefault := 1;
      PrefixDroppedParmLabel := 1;
      UnlockOnCreate := 0;

      >>> options = definition.options()
      >>> options.saveSpareParms()
      False
      >>> options.setSaveSpareParms(True)
      >>> definition.setOptions(options)
      >>> print definition.sections()['TypePropertiesOptions'].contents()
      ParmsFromVfl := 0;
      PrefixDroppedParmName := 1;
      UseDSParms := 1;
      ForbidOutsideParms := 1;
      LockContents := 1;
      SaveSpareParms := 1; # <-- Now 1
      CheckExternal := 1;
      GzipContents := 1;
      MakeDefault := 1;
      PrefixDroppedParmLabel := 1;
      UnlockOnCreate := 0;


    """

    def __init__(self, *args):
        """
        __init__(self)

        Create an HDAOptions object with default settings.

        See the class documentation for more information.
        """
    def checkForExternalLinks(self):
        """
        checkForExternalLinks(self) -> bool

        Return whether the Check for External Node References option is set.

        If set, this option changes all absolute node references inside the
        digital asset into relative references.
        """
        return True

    def setCheckForExternalLinks(self,check_for_external_links):
        """
        setCheckForExternalLinks(self, check_for_external_links)

        Sets the Check for External Node References option.  See
        hou.HDAOptions.checkForExternalLinks for more information.
        """

    def compressContents(self):
        """
        compressContents(self) -> bool

        Return whether the Compress Contents option is on.

        When this option is set, Houdini compresses the contents of the asset
        definition to reduce the size of the .otl file.  Note that this option
        only as effect when the result of hou.HDAOptions.lockContents is True.
        """
        return True

    def setCompressContents(self, compress_contents):
        """
        setCompressContents(self, compress_contents)

        Sets the Compress Contents option.  See hou.HDAOptions.compressContents
        for more information.
        """

    def compressionType(self): return
    def setCompressionType(self): return
    def forbidOutsideParms(self):
        """
        forbidOutsideParms(self) -> bool

        Return whether the Forbid Linking Parameters from Outside this Subnet
        option is set.

        When set, this option does not allow you to drag parameters from nodes
        outside the contents of the digital asset.
        """
        return True

    def setForbidOutsideParms(self, forbid_outside_parms):
        """
        setForbidOutsideParms(self, forbid_outside_parms)

        Sets the Forbid Linking Parameters from Outside this Subnet option.  See
        hou.HDAOptions.forbidOutsideParms for more information.
        """

    def lockContents(self):
        """
        lockContents(self) -> bool

        Return whether the Save Contents as Locked option is on.

        When this option is not set, Houdini will use a creation script to store
        the contents of the digital asset instead of storing the node data. A
        creation script cannot store extra data like locked SOPs, edit SOP
        information, paint SOP information, etc.

        If this option is not set, new instances of the digital asset will be
        locked, so the user can edit the contents.  However, you probably do not
        ever want to turn this option off.  Instead, if you want to lock new
        instances of the digital asset, see hou.HDAOptions.unlockNewInstances.
        """
        return True

    def setLockContents(self, lock_contents):
        """
        setLockContents(self, lock_contents)

        Sets the Save Contents as Locked option.  See
        hou.HDAOptions.lockContents for more information.
        """

    def makeInitialParmsDefaults(self):
        """
        makeInitialParmsDefaults(self) -> bool

        Return whether the Save Defaults as Initial Parameters option is on.

        When set, this option uses the default values of the original parameters
        as the initial values for new nodes, instead of their current values.
        """
        return True

    def setMakeInitialParmsDefaults(self, make_initial_parms_defaults):
        """
        setMakeInitialParmsDefaults(self, make_initial_parms_defaults)

        Sets the Save Defaults as Initial Parameters option.  See
        hou.HDAOptions.makeInitialParmsDefaults for more information.
        """

    def parametersFromVexCode(self):
        """
        parametersFromVexCode(self) -> bool

        Return whether the Get Properties from VEX Code option is on.

        When this option is set, most properties and parameters of the operator
        come from pragma statements in the VEX source code.
        """
        return True

    def setParametersFromVexCode(self, parameters_from_vex_code):
        """
        setParametersFromVexCode(self, parameters_from_vex_code)

        Sets the Get Properties from VEX Code option.  See
        hou.HDAOptions.parametersFromVexCode for more information.
        """

    def prefixDroppedParmLabels(self): return
    def setPrefixDroppedParmLabels(self, prefix_dropped_parm_labels):
        """
        setPrefixDroppedParmLabels(self, prefix_dropped_parm_labels)

        Sets the Prefix Dropped Parameter Labels option.  See
        hou.HDAOptions.prefixDroppedParmLabels for more information.
        """

    def prefixDroppedParmNames(self):
        """
        prefixDroppedParmNames(self) -> bool

        Return whether the Prefix Dropped Parameter Names option is on.

        When this option is set, Houdini will not include a prefix on parameter
        names when you drag and drop parameters into the Existing Parameters
        areas of the Parameters tab of the Type Properties dialog.

        See also hou.HDAOptions.prefixDroppedParmLabels.
        """
        return True

    def setPrefixDroppedParmNames(self, prefix_dropped_parm_names):
        """
        setPrefixDroppedParmNames(self, prefix_dropped_parm_names)

        Sets the Prefix Dropped Parameter Names option.  See
        hou.HDAOptions.prefixDroppedParmNames for more information.
        """

    def saveInitialParmsAndContents(self):
        """
        saveInitialParmsAndContents(self) -> bool

        Return whether the Save Initial Contents and Parameters option is on.

        When this option is set, Houdini saves any parameter values and node
        contents referenced by the digital asset to be saved as part of the
        asset's definition.
        """
        return True

    def setSaveInitialParmsAndContents(self, save_initial_parms_and_contents):
        """
        setSaveInitialParmsAndContents(self, save_initial_parms_and_contents)

        Set the Save Initial Contents and Parameters option.  See
        hou.HDAOptions.saveInitialParmsAndContents for more information.
        """

    def unlockNewInstances(self):
        """
        unlockNewInstances(self) -> bool

        Return whether the Unlock New Nodes on Creation option is set.

        When this option is set, Houdini will unlock new instances of the
        digital asset when they are created.  Note that this option only has
        effect when the result of hou.HDAOptions.lockContents is True.
        """
        return True

    def setUnlockNewInstances(self,unlock_new_instances):
        """
        setUnlockNewInstances(self, unlock_new_instances):

        Sets the Unlock New Nodes on Creation option.  See
        hou.HDAOptions.unlockNewInstances for more information.
        """

    def saveSpareParms(self):
        """
        saveSpareParms(self) -> bool

        Return the Save Spare Parameters option.

        When set, this option will add code into the asset creation script to
        recreate the node's current spare parameters.  New node instances of the
        digital asset will contain the same spare parameters as those on the
        representative node.
        """
        return True

    def setSaveSpareParms(self, save_spare_parms):
        """
        setSaveSpareParms(self, save_spare_parms)

        Set the Save Spare Parameters option.  See hou.HDAOptions.saveSpareParms
        for more information.
        """

    def saveCachedCode(self):
        """
        saveCachedCode(self) -> bool

        Return the Save Cached Code option.

        When set, this option will save cached code for applicable definitions,
        such as digital assets defined by VOP networks that generate VEX code.
        With this option on, the compiled code will be saved to the HDA
        section(s) and will be used for shaders, etc, without the need to
        recompile the network. This can save significant amounts of time for
        complex shaders.
        """
        return True

    def setSaveCachedCode(self, save_cached_code):
        """
        setSaveCachedCode(self, save_cached_code)

        Set the Save Cached Code option. See hou.HDAOptions.saveCachedCode for
        more information.
        """

class HDASection(object):
    """
    hou.HDASection

    Represents a "section" of data stored along with a digital asset.

    A digital asset stores its contents in a number of different pieces of
    data called sections.  Each section is named and contains an arbitrarily
    sized piece of data, often textual.  Each section is like a file
    embedded inside the definition, and Houdini uses specially named
    sections to store the node contents, list of parameters, etc.  You can
    embed your own data into a digital asset by putting it inside a section.

    Any parameter in Houdini that references a file can also reference a
    section inside a digital asset.  For example, if car is an object-level
    digital asset and the section is named "texture.jpg", you can
    reference that texture with opdef:/Object/car?texture.jpg.  Note that
    hou.readFile also supports this opdef: syntax.

    By moving files into digital asset sections, you can build self-
    contained digital assets that can be distributed via a single otl file.

    Note that section names may contain '/'.


    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def definition(self):
        """
        definition(self) -> hou.HDADefinition

        Return the digital asset definition containing this section.
        """
        return HDADefinition()

    def name(self):
        """
        name(self) -> str

        Return the name of this section.

        Note that is is not possible to rename a section, but the following
        function will emulate renaming:
          def renameSection(section):
              '''Rename a section by removing it and creating a new one.  Return the new section.'''
              new_section = section.definition().addSection(new_name, section.contents())
              section.destroy()
              return new_section
        """
        return ''

    def contents(self):
        """
        contents(self) -> str

        Return a string containing the contents of this section.

          def saveSectionToFile(section, file_name):
              '''Given a section, save it to a file.'''
              section_file = file(file_name, "w")
              section_file.write(section.contents())
              section_file.close()

        REPLACES
            otcontentsave command        """
        return ''

    def setContents(self, contents):
        """
        setContents(self, contents)

        Set the contents of this section to the given string.  A section may
        contain binary information, like bgeo files, images, etc.

        See hou.HDADefinition.addSection for an example of how to create a
        section from a file on disk.
        """

    def size(self):
        """
        size(self) -> int

        Return the number of bytes in the contents.  This method is a shortcut
        for len(self.contents()).

        REPLACES
            otcontentls command        """
        return 0

    def modificationTime(self):
        """
        modificationTime(self) -> int

        Return the time when the section was last modified.  This time is
        returned as a POSIX timestamp, such as is returned by time.time().

          >>> hou.nodeType(hou.cop2NodeTypeCategory(), "colorwheel").definition()
          <hou.HDADefinition of Cop2 colorwheel in /opt/hfs9.5/houdini/otls/OPlibCop2.otl>
          >>> definition = hou.nodeType(hou.cop2NodeTypeCategory(), "colorwheel").definition()
          >>> definition.sections().keys()
          ['VflCode', 'DialogScript', 'VexCode']
          >>> section = definition.sections()['VflCode']
          >>> section.modificationTime()
          1177535169
          >>> import datetime, time
          >>> datetime.datetime.fromtimestamp(section.modificationTime())
          datetime.datetime(2007, 4, 25, 17, 6, 9)
          >>> time.ctime(section.modificationTime())
          'Wed Apr 25 17:06:09 2007'

        REPLACES
            otcontentls command        """
        return 0

    def destroy(self):
        """
        destroy(self)

        Remove this section from the HDA definition.  You can also remove a
        section with hou.HDADefinition.removeSection, and this method is
        equivalent to self.definition().removeSection(self.name()).

        Only remove sections that you explicitly added.  Do not remove the
        special sections that Houdini uses to store the contents of the digital
        asset definition, or Houdini will generate errors or strange side
        effects.

        To add a section, use hou.HDADefinition.addSection.

        REPLACES
            otcontentdelete command        """


class hipFile(object):
    """
    hou.hipFile

    """

    def __init__(self): raise AttributeError, "No constructor defined"
    @staticmethod
    def save(file_name=None, save_to_recent_files=True):
        """
        save(file_name=None, save_to_recent_files=True)

        Saves the current session to a hip file.

        file_name
            The name or path to the file that will be written.  If you attempt
            to save a file to a directory that does not exist, the directory
            will be created.  If this parameter is None, Houdini will use the
            current hip file path.

        save_to_recent_files
            Whether Houdini will add this file to the contents of the File >
            Open Recent Files list.  This parameter is ignored when this
            function is called from a non-graphical session.

        Raises hou.OperationFailed if the target file or directory cannot be
        created or if other errors occur during save.  The same exception will
        also be raised if the method is called during shutting down or
        loading/saving a hip file. In each case, the exception instance message
        will reflect the failure reason.

        REPLACES
            mwrite command        """
    @staticmethod
    def saveAndIncrementFileName():
        """
        saveAndIncrementFileName()

        Saves the current session to a hip file, automatically incrementing the
        file name.

        Raises hou.OperationFailed if the target file or directory cannot be
        created or if other errors occur during save. The same exception will
        also be raised if the method is called during shutting down or
        loading/saving a hip file. In each case, the exception instance message
        will reflect the failure reason.

        REPLACES
            mwrite command        """
    @staticmethod
    def saveAsBackup():
        """
        saveAsBackup()

        Creates a numbered backup from the current session.

        If a file with the same name as the current backup already exists, then
        the backup is renamed to contain the next number in the sequence before
        saving. The backup files are saved in the directory set in the
        environment variable HOUDINI_BACKUP_DIR. If HOUDINI_BACKUP_DIR is not
        set, then a default relative directory called "backup" is used.

        Raises hou.OperationFailed if the target file or directory cannot be
        created or if other errors occur during save. The same exception will
        also be raised if the method is called during shutting down or
        loading/saving a hip file. In each case, the exception instance message
        will reflect the failure reason.

        REPLACES
            mwrite command        """
    @staticmethod
    def basename():
        """
        basename() -> str

        Return only the filename portion of the current hip file.
        """
        return ''
    @staticmethod
    def name():
        """
        name() -> str

        Return the name of the current hip file.

        This function may or may not return a full path.  If you need to always
        get a full path, use hou.hipFile.path instead.
        """
        return ''
    @staticmethod
    def path():
        """
        path() -> str

        Return a full path to the current hip file.
        """
        return ''
    @staticmethod
    def setName(file_name):
        """
        setName(file_name)

        Changes the name of the current session for the next time it is saved to
        a hip file.

        If the user subsequently chooses File > Save, Houdini saves to a hip
        file with this name.  Note that this function does not actually save the
        hip file.  To both set the name of the current session and save it to a
        hip file, use hou.hipFile.save.
        """
    @staticmethod
    def clear(suppress_save_prompt=False):
        """
        clear(suppress_save_prompt=False)

        This function replaces the current session with an empty session.

        If suppress_save_prompt is set to False, the method acts as File > New
        in an interactive session. It prompts you to save the current file
        before clearing. Otherwise, the session is cleared non-interactively: no
        prompts appear and any changes are discarded.

        If the UI is not available (for example, if you run the method from
        hython), the suppress_save_prompt parameter is ignored and non-
        interactive clear is always performed.

        REPLACES
            mnew command        """
    @staticmethod
    def load(file_name, suppress_save_prompt=False, ignore_load_warnings=False):
        """
        load(file_name, suppress_save_prompt=False, ignore_load_warnings=False)

        Loads a hip file.

        If suppress_save_prompt is False, the function acts as if the file was
        loaded via File > Open.... It prompts you to save the current file
        before loading the new file and displays any load errors in a pop-up
        window. It also changes the name of the current file at the top of the
        main window and adds the file name to the list of most recently used
        files.

        If the UI is not available (for example, if you run the function from
        hython), the suppress_save_prompt parameter is ignored and non-
        interactive load is always performed.

        Raises hou.OperationFailed if the file to be loaded does not exist or
        cannot be opened. The same exception will also be raised if the method
        is called during shutting down or loading/saving a hip file. In each
        case, the exception instance message will reflect the failure reason.

        Raises hou.LoadWarning if warnings are generated during load and
        ignore_load_warnings is False.  The instance message will contain the
        warning text.

        REPLACES
            mread command        """
    @staticmethod
    def merge(file_name, node_pattern="*", overwrite_on_conflict=False,
        ignore_load_warnings=False):
        """
        merge(file_name, node_pattern="*", overwrite_on_conflict=False,
        ignore_load_warnings=False)

        Merges the given file into the current hip file. The nodes to merge in
        are indicated by the node_pattern parameter.

        If overwrite_on_conflict is True, the method will overwrite nodes with
        the same name as nodes in the merge file.

        This method will raise a hou.OperationFailed exception if the file to be
        merged into the current one does not exist or cannot be opened. The same
        exception will also be raised if the method is called during shutting
        down or loading/saving a hip file. In each case, the exception instance
        message will reflect the failure reason.

        This method will raise a hou.LoadWarning exception if warnings are
        generated during merge and ignore_load_warnings is False. The instance
        message will contain the warning text.

        REPLACES
            mread command        """
    @staticmethod
    def collisionNodesIfMerged(file_name, node_pattern="*"):
        """
        collisionNodesIfMerged(file_name, node_pattern="*") -> tuple of
        hou.Node

        Returns the Nodes that would collide if a merge was performed with the
        specified node_pattern.

        The result is a tuple of all Nodes in the merge file satisfying the
        node_pattern and having the same name as any of the existing nodes.

        Raises hou.OperationFailed if the file to be used in the collision check
        does not exist, cannot be opened, or is not a valid hip file. The same
        exception will also be thrown if the method is called during shutting
        down or loading/saving a hip file. In each case, the exception instance
        message will reflect the failure reason.
        """
        return (Node(),)
    @staticmethod
    def isLoadingHipFile():
        """
        isLoadingHipFile() -> bool

        Return whether the main application is loading a hip file.

        REPLACES
            opisloading function        """
        return True
    @staticmethod
    def isShuttingDown():
        """
        isShuttingDown() -> bool

        Return whether the main application is shutting down.

        REPLACES
            opisquitting function        """
        return True
    @staticmethod
    def hasUnsavedChanges():
        """
        hasUnsavedChanges() -> bool

        Returns whether the current Houdini session has been modified since it
        was last saved.
        """
        return True

class hmath(object):
    """
    hou.hmath

    Houdini and 3D related math functions.


    """

    def buildTranslate(values):
        """
        Return a transformation matrix containing only a translation. You can build more complex transformations by multiplying the result with another transformation matrix.
        values

        A sequence of 3 floats representing the translation in x, y, and z.

        See hou.Geometry.transformPrims and hou.Matrix4.explode for examples.
         """
        return Matrix4()

    def buildRotateAboutAxis(axis, angle_in_deg):
        """
        Return a transformation matrix containing only a rotation, given an axis and a rotation amount. You can build more complex
        transformations by multiplying the result with another transformation matrix.

        See hou.Geometry.transformPrims and hou.Matrix4.explode for examples.

        If you want to convert Euler angles into a corresponding axis and angle, you can use the following code:


        def extractAxisAndAngleFromRotateMatrix(m):
            '''Given a matrix, return an (Vector3, float) tuple containing the
               axis and angle.  See Wikipedia's rotation represention page for
               more details.'''
            import math

            acos_input = (m.at(0, 0) + m.at(1, 1) + m.at(2, 2) - 1.0) * 0.5
            if acos_input < -1.0 or acos_input > 1.0:
                return None

            angle = math.acos(acos_input)
            if angle >= -1e-6 and angle <= 1e-6:
                # There is no rotation.  Choose an arbitrary axis and a rotation of 0.
                return hou.Vector3(1, 0, 0), 0.0

            inv_sin = 1.0 / (2.0 * math.sin(angle))
            axis = hou.Vector3(
                (m.at(1, 2) - m.at(2, 1)) * inv_sin,
                (m.at(2, 0) - m.at(0, 2)) * inv_sin,
                (m.at(0, 1) - m.at(1, 0)) * inv_sin)
            return axis, hou.hmath.radToDeg(angle)

        def eulerToAxisAndAngle(angles):
            return extractAxisAndAngleFromRotateMatrix(hou.hmath.buildRotate(angles))

        See Wikipedias axis angle page and rotation representation page for more information.
        """
        return Matrix4()

    def buildRotate(values, order='xyz'):
        """
        Return a transformation matrix containing only a rotation, given a sequence of Euler angles. You can build more complex transformations by multiplying the result with another transformation matrix.
        values

        A sequence of 3 floats representing the rotations about each of the x, y, and z axes. Each rotation value is in degrees.
        order

        A string containing a permutation of the letters x, y, and z that determines the order in which rotations are performed about the coordinate axes.

        See Wikipedias Euler angles page for more information.

        See hou.Matrix4.explode for an example. See also hou.hmath.buildRotateAboutAxis and hou.hmath.radToDeg.
        """
        return Matrix4()
    def buildRotateToFrame(new_z_axis, new_y_axis):
        """
        This feature is not yet implemented
        """
        return Matrix4()

    def buildScale(values):
        """
        Return a transformation matrix containing only a scale, given a sequence of scale values for x, y, and z. You can build more complex transformations by multiplying the result with another transformation matrix.
        To apply a uniform scale, use the same value for x, y, and z.
        See hou.Geometry.createNURBSSurface and hou.Matrix4.explode for examples.
        """
        return Matrix4()
    def buildShear(values):
        """
        Return a transformation matrix containing only a shear, given a sequence of shear values for x, y, and z. You can build more complex transformations by multiplying the result with another transformation matrix.
        See Wikipedias shear matrix page for more information.
        See hou.Matrix4.explode for an example.
        """
        return Matrix4()
    def buildTransform(values_dict, transform_order="srt", rotate_order="xyz"):
        """
        Given a set of translate, rotate, scale, shear, and pivot values; and transform rotate orders, return a corresponding matrix. This function is the inverse of hou.Matrix4.explode.
        values_dict
        A dictionary whose keys are one of the strings translate, rotate, scale, shear, pivot and whose values are sequences of three floats. Note that the rotate values are Euler angles about the x, y, and z axes, in degrees.
        transform_order
        A string containing a permutation of the letters s, r, and t. The rotate, scale, and translate results are dependent on the order in which you perform those operations, and this string specifies that order.
        rotate_order
        A string containing a permutation of the letters x, y, and z that determines the order in which rotations are performed about the coordinate axes.
        This function can be approximately implemented as follows:

        def buildTransform(values_dict, transform_order="srt", rotate_order="xyz"):
            # Take the return value from explode, along with the transform and
            # rotate order, and rebuild the original matrix.
            result = hou.hmath.identityTransform()
            for operation_type in transform_order:
                if operation_type == "t":
                    result *= hou.hmath.buildTranslate(values_dict["translate"])
                elif operation_type == "s":
                    result *= hou.hmath.buildScale(values_dict["scale"])
                    if "shear" in values_dict:
                        result *= hou.hmath.buildShear(values_dict["shear"])
                elif operation_type == "r":
                    result *= hou.hmath.buildRotate(values_dict["rotate"], rotate_order)
                else:
                    raise ValueError("Invalid transform order")
            return result
        """
        return Matrix4()

    def identityTransform():
        """
        Returns the identity matrix. This is the same as calling hou.Matrix4(1).
        >>> hou.hmath.identityTransform()
        <hou.Matrix4 [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]>
        See also hou.Matrix4.__init__.
        """
        return Matrix4()

    def degToRad(degrees):
        """
        Given a value in degrees, return the corresponding value in radians.
        This function is equivalent to degrees * math.pi / 180.0.
        """
        return 0.0

    def radToDeg(radians):
        """
        Given a value in radians, return the corresponding value in degrees.
        This function is equivalent to radians * 180.0 / math.pi.
        """
        return 0.0
    def clamp(value, min, max):
        """
        Returns the value clamped to the range min to max. See also hou.hmath.wrap. This function is useful in expressions to prevent a value from going outside the specified range.
        """
        return 0.0

    def wrap(value, min, max):
        """
        Similar to the hou.hmath.clamp function in that the resulting value will always fall between the specified minimum and maximum value. However, it will create a saw-tooth wave for continuously increasing or decreasing parameter values.
        """
        pass
    def sign(value):
        """
        Returns 1.0 if value is positive, -1.0 if negative and 0.0 if value is zero.
        Note that you can achieve the same effect with Pythons built-in cmp function: float(cmp(value, 0)).
        """
        return 0

    def smooth(value, min, max):
        """
        Takes a value and range and returns a smooth interpolation between 0 and 1.
        When value is less than min, the return value is 0. If value is greater than max, the return value is 1.
        >>> hou.hmath.smooth(5, 0, 20)
        0.15625
        >>> hou.hmath.smooth(10, 0, 20)
        0.5
        >>> hou.hmath.smooth(15, 0, 20)
        0.84375
        # Visualize the output of this function by positioning geometry objects at  various locations.
        def createSpheres(num_spheres=40):
            for i in range(num_spheres):
                sphere = hou.node("/obj").createNode("geo").createNode("sphere")
                sphere.parmTuple("rad").set((0.1, 0.1, 0.1))
                sphere.setDisplayFlag(True)

                # Given a value between 0 and 5, we'll call smooth with a range
                # of 0 to 3, and the resulting y value will be between 0 and 1.
                x = 5.0 * i / num_spheres
                y = hou.hmath.smooth(x, 0, 3)
                sphere.parent().setParmTransform(hou.hmath.buildTranslate((x, y, 0)))
        """
        return 0.0

    def fit(value, old_min, old_max, new_min, new_max):
        """
        Returns a number between new_min and new_max that is relative to the value between the range old_min and old_max. If the value is outside the old_min to old_max range, it will be clamped to the new range.
        >>> hou.hmath.fit(3, 1, 4, 5, 20)
        15.0
        """
        return 0.0

    def fit01(value, new_min, new_max):
        """
        Returns a number between new_min and new_max that is relative to the value between the range 0 and 1. If the value is outside the 0 to 1 range, it will be clamped to the new range.
        This function is a shortcut for hou.hmath.fit(value, 0.0, 1.0, new_min, new_max).
        """
        return 0.0

    def fit10(value, new_min, new_max):
        """
        Returns a number between new_min and new_max that is relative to the value between the range 1 to 0. If the value is outside the 1 to 0 range, it will be clamped to the new range.
        This function is a shortcut for hou.hmath.fit(value, 1.0, 0.0, new_min, new_max).
        """
        return 0.0

    def fit11(value, new_min, new_max):
        """
        Returns a number between new_min and new_max that is relative to the value between the range -1 to 1. If the value is outside the -1 to 1 range, it will be clamped to the new range.
        This function is a shortcut for hou.hmath.fit(value, -1.0, 1.0, new_min, new_max).
        """
        return 0.0
    def modularBlend(value1, value2, modulus, blend_factor):
        """
        This feature is not yet implemented
        """
        return
    def rand(seed):
        """
        Returns a pseudo-random number from 0 to 1. Using the same seed will always give the same result.
        """
        return 0.0
    def noise1d(self, pos):
        """
        Given a sequence of 1 to 4 floats representing a position in N-dimensional space, return a single float corresponding to 1 dimensional noise.
        This function matches the output of the noise function from VEX.
        """
        return 0.0

    def noise3d(self, pos):
        """
        Given a sequence of 1 to 4 floats representing a position in N-dimensional space, return a hou.Vector3 object representing the vector noise at the given position.
        This function matches the output of the noise function from VEX.
        """
        return hou.Vector3

    def sparseConvolutionNoise(pos3):
        pass
    def sparseConvolutionTurbulantNoise(pos3, depth):
        return 0.0
    def turbulantNoise(pos3, depth):
        return 0.0
    def orient2d(pa, pb, point):
        """
        Performs an adaptive exact sidedness test of the 2d point against the line defined by pa and pb.
        See http://www.cs.cmu.edu/~quake/robust.html for details of the implementation.
        """
        return 0.0
    def orient3d(pa, pb, pc, point):
        """
        Performs an adaptive exact sidedness test of the 3d point against the plane defined by pa, pb, and pc.
        See http://www.cs.cmu.edu/~quake/robust.html for details of the implementation.
        """
        return 0.0
    def inCircle(pa, pb, pc, point):
        """
        Performs an adaptive exact inside test of the 2d point against the circle defined by pa, pb, and pc. pa, pb, and pc must be in counter-clockwise order to get a positive value for interior points.
        See http://www.cs.cmu.edu/~quake/robust.html for details of the implementation.
        """
        return 0.0
    def inSphere(pa, pb, pc, pd, point):
        """
        Performs an adaptive exact inside test of the 3d point against the sphere defined by pa, pb, pc, and pd. Note that inconsistent orientation of the four sphere defining points will reverse the sign of the result.
        See http://www.cs.cmu.edu/~quake/robust.html for details of the implementation.
        """
        return 0.0

class IndexPairPropertyTable(object):
    """
    hou.IndexPairPropertyTable

    Describes properties of an index pair attribute.
    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def attrib(self):
        """
        attrib(self) -> hou.Attrib

        Return the parent index pair attribute.
        """
        return Attrib()

    def numIndices(self): return 0
    def propertyNames(self):
        """
        propertyNames(self) -> tuple of string

        Return a list of all property names.
        """
        return ('',)

    def propertyDataType(self, property_name):
        """
        propertyDataType(self, property_name) -> hou.attribData enum value

        Return the property's data type (int, float or string).
        """
        return attribData()

    def propertySize(self,property_name):
        """
        propertySize(self, property_name) -> int

        Return the number of data components in the property value.
        """
        return 0

    def floatPropertyValueAtIndex(self, property_name, row):
        """
        floatPropertyValueAtIndex(self, property_name, row) -> float

        Return the property value for a particular floating point property.

        Raises hou.OperationFailed if no property exists with this name or the
        property is not float of size 1.
        """
        return 0.0

    def floatListPropertyValueAtIndex(self, property_name, row):
        """
        floatListPropertyValueAtIndex(self, property_name, row) -> tuple of
        float

        Return a list of property values for a particular floating point
        property.

        Raises hou.OperationFailed if no property exists with this name.
        """
        return (0.0,)

    def intPropertyValueAtIndex(self, property_name, row):
        """
        intPropertyValueAtIndex(self, property_name, row) -> int

        Return the property value for a particular integer property.

        Raises hou.OperationFailed if no property exists with this name or the
        property is not integer of size 1.
        """
        return 0

    def intListPropertyValueAtIndex(self, property_name, row):
        """
        intListPropertyValueAtIndex(self, property_name, row) -> tuple of int

        Return a list of property values for a particular integer property.

        Raises hou.OperationFailed if no property exists with this name.
        """
        return (0,)

    def stringPropertyValueAtIndex(self, property_name, row):
        """
        stringPropertyValueAtIndex(self, property_name, row) -> string

        Return the property value for a particular string property.

        Raises hou.OperationFailed if no property exists with this name or the
        property is not string of size 1.
        """
        return ''

    def stringListPropertyValueAtIndex(self, property_name, row):
        """
        stringListPropertyValueAtIndex(self, property_name, row) -> tuple of
        string

        Return a list of property values for a particular string property.

        Raises hou.OperationFailed if no property exists with this name.
        """
        return ('',)

class InterruptableOperation(object):
    """
    hou.InterruptableOperation

    Use this class to turn any Python code block into an interruptable
    operation.


    """

    def __init__(self, operation_name, long_operation_name=None,
        open_interrupt_dialog=False):
        """
        __init__(self, operation_name, long_operation_name=None,
        open_interrupt_dialog=False)

        Construct a new InterruptableOperation.

        operation_name
            A description of the interruptable operation that appears in the
            progress bar of the interrupt dialog.

        long_operation_name
            A description of the long, or higher-level, operation.  If it is not
            None, a second progress bar appears on the interrupt dialog with the
            long operation name in it.

        open_interrupt_dialog
            Determines whether the interrupt dialog should appear or not.

        The constructor should only be called from within a with statement.  For
        example:
          with hou.InterruptableOperation(
                  "Performing Tasks", open_interrupt_dialog=True) as operation:
              for i in num_tasks:
                  #
                  # PERFORM TASK HERE.
                  #

                  # Update operation progress.
                  percent = float(i) / float(num_tasks)
                  operation.updateProgress(percent)


        In Python 2.5, the with statement is not enabled by default.  To enable
        it, you need to add the following line at the beginning of your
        script/module:
          from __future__ import with_statement


        You can nest multiple interruptable operations.  This is ideal when you
        have a long operation consisting of several smaller operations.  For
        example:
          # Start the overall, long operation.
          with hou.InterruptableOperation(
                  "Performing", "Performing Tasks",
                  open_interrupt_dialog=True) as operation:
              for i in num_tasks:
                  # Update long operation progress.
                  overall_percent = float(i) / float(num_tasks)
                  operation.updateLongProgress(overall_percent)

                  # Start the sub-operation.
                  with hou.InterruptableOperation(
                          "Performing Task %i" % i) as suboperation:
                      for j in num_subtasks:
                          # Update sub-operation progress.
                          percent = float(j) / float(num_subtasks)
                          suboperation.updateProgress(percent)

                          #
                          # PERFORM SUBTASK HERE.
                          #
        """
    def updateLongProgress(self, percentage=-1.0, long_op_status=None):
        """
        updateLongProgress(self, percentage=-1.0, long_op_status=None)

        Update the progress percentage and status of the long, or high-level,
        operation.  At the same time, check if the operation was interrupted by
        the user.

        percentage
            A fractional number between 0.0 and 1.0.  A value of 0.0 means that
            no progress has been made while 1.0 means that the operation is
            complete. A negative percentage indicates that the progress
            percentage is not available.

        long_op_status
            Text describing the current status of the long operation.  The
            status will overwrite the text in the 2nd progress bar of the
            interrupt dialog.  To keep the previous text in the progress bar,
            set this parameter to None.

        Raises hou.OperationInterrupted if the user has chosen to interrupt the
        operation.

        Raises hou.OperationFailed if the interruptable operation object was
        constructed outside of a with statement.
        """

    def updateProgress(self, percentage=-1.0):
        """
        updateProgress(self, percentage=-1.0)

        Update the progress percentage of the operation.  At the same time,
        check if the operation was interrupted by the user.

        percentage
            A fractional number between 0.0 and 1.0.  A value of 0.0 means that
            no progress has been made while 1.0 means that the operation is
            complete. A negative percentage indicates that the progress
            percentage is not available.

        Raises hou.OperationInterrupted if the user has chosen to interrupt the
        operation.

        Raises hou.OperationFailed if the interruptable operation object was
        constructed outside of a with statement.
        """

    def __enter__(self): return InterruptableOperation()
    def __exit__(self): return InterruptableOperation()

class IntParmTemplate(ParmTemplate):
    """
    hou.IntParmTemplate

    Describes a parameter tuple containing integer values.


    """

    def __init__(self, name, label, num_components, default_value=(), min=0,
        max=10, min_is_strict=False, max_is_strict=False,
        naming_scheme=hou.parmNamingScheme.XYZW, disable_when=None,
        is_hidden=False, is_label_hidden=False, join_with_next=False, help=None,
        script_callback=None,
        script_callback_language=hou.scriptLanguage.Hscript, tags={},
        default_expression=(), default_expression_language=()):
        """
        __init__(self, name, label, num_components, default_value=(), min=0,
        max=10, min_is_strict=False, max_is_strict=False,
        naming_scheme=hou.parmNamingScheme.XYZW, disable_when=None,
        is_hidden=False, is_label_hidden=False, join_with_next=False, help=None,
        script_callback=None,
        script_callback_language=hou.scriptLanguage.Hscript, tags={},
        default_expression=(), default_expression_language=())

        Construct a new IntParmTemplate.

        name
            See hou.ParmTemplate.name for more information.

        label
            See hou.ParmTemplate.label for more information.

        num_components
            See hou.ParmTemplate.numComponents for more information.

        default_value
            See the defaultValue method for more information.

        min
            See the minValue method for more information.

        max
            See the maxValue method for more information.

        min_is_strict
            See the minIsStrict method for more information.

        max_is_strict
            See the maxIsStrict method for more information.

        look
            See hou.ParmTemplate.look for more information.

        naming_scheme
            See hou.ParmTemplate.namingScheme for more information.

        disable_when
            See hou.ParmTemplate.disableWhen for more information.

        is_hidden
            See hou.ParmTemplate.isHidden for more information.

        is_label_hidden
            See hou.ParmTemplate.isLabelHidden for more information.

        join_with_next
            See hou.ParmTemplate.joinsWithNext for more information.

        help
            See hou.ParmTemplate.help for more information.

        script_callback
            See hou.ParmTemplate.scriptCallback for more information.

        script_callback_language
            See hou.ParmTemplate.scriptCallbackLanguage for more information.

        tags
            See hou.ParmTemplate.tags for more information.

        default_expression
            See the defaultExpression method for more information.

        default_expression_language
            See the defaultExpressionLanguage method for more information.
        """
    def minValue(self):
        """
        minValue(self) -> int

        Return the minimum value of the parameter.

        See also the minIsStrict method.
        """
        return 0

    def setMinValue(self, min_value):
        """
        setMinValue(self, min_value)

        Set the minimum value of the parameter.

        See the minValue method for more information.
        """

    def maxValue(self):
        """
        maxValue(self) -> int

        Return the minimum value of the parameter.

        See also the minIsStrict method.
        """

    def setMaxValue(self, max_value):
        """
        setMaxValue(self, max_value)

        Set the maximum value of the parameter.

        See the maxValue method for more information.
        """

    def minIsStrict(self):
        """
        minIsStrict(self) -> bool

        Returns whether the minimum value is strictly enforced.

        If a minimum value is not strictly enforced, the slider will not let you
        change the value below the minimum, but you can set the value to be
        lower than the minimum by typing it in, changing it via
        hou.Parm.setValue, or using the ladder handle.

        If it is strictly enforced and you try to change it below the minimum
        value using any mechanism, Houdini will set it to the minimum value.

        See also the minValue method.
        """
        return True

    def setMinIsStrict(self, on):
        """
        setMinIsStrict(self, on)

        Set whether the minimum value is strictly enforced.

        See the minIsStrict method for more information.
        """

    def maxIsStrict(self):
        """
        maxIsStrict(self) -> bool

        Return whether the maximum value is strictly enforced.

        See the minIsStrict method for more information.
        """
        return True

    def setMaxIsStrict(self, on):
        """
        setMaxIsStrict(self, on)

        Set whether the maximum value is strictly enforced.

        See the maxIsStrict method for more information.
        """

    def defaultValue(self):
        """
        defaultValue(self) -> tuple of int

        Return the default value for new parameter instances.

        For example, suppose this parm template is named "divisions", the
        naming scheme is XYZW, it has 3 components, and the default value is
        (10, 20, 30). The corresponding parm tuple instance on a node would be
        named "divisions" and would contain parameters "divisionsx",
        "divisionsy", and "divisionsz". When the node is created,
        "divisionsx" would be 10, "divisionsy" would be 20, and
        "divisionsz" would be 30.
        """
        return (0,)

    def setDefaultValue(self, default_value):
        """
        setDefaultValue(self, default_value)

        Set the default value for new parameter instances to a sequence of ints.

        See the defaultValue method for more information.  Note that if the
        number of ints in the sequence is different from the number of
        components in the parm template, any extra values will be discarded and
        any missing values will become zeros.
        """

    def defaultExpression(self):
        """
        defaultExpression(self) -> tuple of strings

        Return the default expression for new parameter instances.

        The default expression takes precendence over the default value. If a
        component has no default expression (i.e. an empty string), then the
        default value is used for new parameter instances.

        Note that the default expression language is needed to interpret the
        meaning of the default expression.

        For example, suppose this parm template is named "divisions",  the
        naming scheme is XYZW, it has 3 components, the default value  is (10,
        20, 30), the default expression is ("$F", "hou.frame()", "")  and
        the default expression language is (hou.scriptLanguage.Hscript,
        hou.scriptLanguage.Python, hou.scriptLanguage.Hscript). Then the
        corresponding parm tuple instance on a node would be named
        "divisions" and would contain parameters "divisionsx",
        "divisionsy",  "divisionsz".  When the node is created,
        "divisionsx" would have a default Hscript expression of "$F",
        "divisionsy" would have a default Python expression of
        "hou.frame()",  and "divisionsz" would have a default value of 30.
        """
        return ('',)

    def setDefaultExpression(self, default_expression):
        """
        setDefaultExpression(self, default_expression)

        Set the default expression for new parameter instances to a sequence  of
        strings.

        See the hou.IntParmTemplate.defaultExpression method  for more
        information.  Note that if the number of strings in the sequence  is
        different from the number of components in the parm template,  any extra
        values will be discarded and any missing expressions will become the
        empty string.
        """

    def defaultExpressionLanguage(self):
        """
        defaultExpressionLanguage(self) -> tuple of hou.scriptLanguage

        Return the default expression language for new parameter instances.

        The default expression language only applies if the default expression
        is set.  If the default expression of a component is not set, then the
        expression language is set to hou.scriptLanguage.Hscript.
        """
        return (scriptLanguage(),)

    def setDefaultExpressionLanguage(self, default_expression_language):
        """
        setDefaultExpressionLanguage(self, default_expression_language)

        Set the default expression language for new parameter instances  to a
        sequence of hou.scriptLanguage values.

        See the defaultExpressionLanguage method for more information.   Note
        that if the number of hou.scriptLanguage values in the sequence  is
        different from the number of components in the parm template,  any extra
        values will be discarded and any missing expression languages  will
        become hou.scriptLanguage.Hscript.
        """

class IPRViewer(PaneTab):
    """
    hou.IPRViewer

    An interactive preview render (IPR) window.

    The IPR viewer progressively refines a render, first providing a rough
    view of the rendered image and eventually providing the fully rendered
    image. When you change a shader value, move an object, etc., the viewer
    will re-render the image.

    When you Ctrl+click on a pixel in the rendered image, Houdini searches
    $HOUDINI_PATH for scripts/ipr/pickpixel.py and runs it.  The version of
    this file that ships with Houdini pops up the shader contributing the
    pixel, or an information window if there is is no shader.  If Houdini
    cannot find that Python file it then looks for the Hscript file
    scripts/ipr/pickpixel.cmd.

    When you drag a SHOP node onto the rendered image, Houdini searches for
    and runs scripts/ipr/dragdrop.py.  By default, this script assigns the
    SHOP to the object contributing the pixel.  If it cannot find a Python
    version, Houdini then looks for scripts/ipr/dragdrop.cmd.

    Note that shelf scripts can access the last location the user clicked on
    with hou.IPRViewer.lastClickLocation.


    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def isPaused(self):
        """
        isPaused(self) -> bool

        Indicates whether the IPR session is paused.  If there is no active
        session, this returns false.
        """
        return True

    def killRender(self):
        """
        killRender(self)

        Kills the active IPR session (if there is one).
        """

    def pauseRender(self):
        """
        pauseRender(self)

        Pauses the active IPR session (if there is one).
        """

    def resumeRender(self):
        """
        resumeRender(self)

        Resumes the active IPR session (if there is one).
        """

    def startRender(self):
        """
        startRender(self)

        Start a new render if there is no active IPR session or issue a re-
        render if there is one.
        """

    def isPreviewOn(self):
        """
        isPreviewOn(self) -> bool

        Return whether or not the Preview checkbox is checked.  When it is
        unchecked, the viewer will not progressively refine the image using IPR,
        and will instead use the rendering engine from the ROP node to render
        it.

        See also hou.IPRViewer.setPreview.

        REPLACES
            iprquery function        """
        return True

    def setPreview(self, on):
        """
        setPreview(self, on)

        Check or uncheck the Preview checkbox.

        See hou.IPRViewer.isPreviewOn for more information.

        REPLACES
            iprquery function        """

    def isAutoUpdateOn(self):
        """
        isAutoUpdateOn(self) -> bool

        Return whether or not the Auto-Update checkbox is checked.  When it is
        unchecked, the viewer will not refresh when objects, shaders, lights,
        etc. change.  In this case, you can force a re-render by clicking on the
        Render button.

        See also hou.IPRViewer.setAutoUpdate.

        REPLACES
            iprview command        """
        return True

    def setAutoUpdate(self, on):
        """
        setAutoUpdate(self, on)

        Check or uncheck the Auto-Update checkbox.

        See hou.IPRViewer.isAutoUpdateOn for more information.

        REPLACES
            iprview command        """

    def delay(self):
        """
        delay(self) -> float

        Return the contents of the viewer's Delay field.  This value determines
        how long Houdini waits between when you change a parameter value and
        when it starts re-rendering.

        See also hou.IPRViewer.setDelay and hou.IPRViewer.updateTime.

        REPLACES
            iprview command        """
        return 0.0

    def setDelay(self, time):
        """
        setDelay(self, time)

        Set the contents of the viewer's Delay field.

        See hou.IPRViewer.delay for more information.

        REPLACES
            iprview command        """

    def updateTime(self):
        """
        updateTime(self) -> float

        Return the contents of the viewer's Update Time field.  This value
        determines approximately how long each progressive refinement should
        take. Smaller values will produce more progressive renders where detail
        is added more gradually.

        See also hou.IPRViewer.setUpdateTime and hou.IPRViewer.delay.
        """
        return 0.0

    def setUpdateTime(self, time):
        """
        setUpdateTime(self, time)

        Set the contents of the viewer's Update Time field.

        See hou.IPRViewer.updateTime for more information.
        """

    def lastClickLocation(self):
        """
        lastClickLocation(self) -> (int, int)

        Return the x and y coordinates for the pixel location where the user
        last clicked in the IPR viewer.  Note that this location might be
        outside the image: the x and y coordinates can be negative and can be
        greater than or equal to the image resolution.  Note that if the user
        never clicked in the viewer, the x and y coordinates will be negative.

        You would typically call this method from a shelf script.  For example,
        a user can click on a pixel in the IPR viewer and then click on the
        shelf to perform an action on that pixel (e.g. display the shader
        parameters, assign a shader, etc.).

        Use hou.IPRViewer.imageResolution to get the valid range for pixel
        coordinates.

        Note that when you Ctrl-click on a pixel, Houdini searches $HOUDINI_PATH
        for scripts/ipr/pickpixel.py and runs it.  This script can access the
        viewer with kwargs["viewer"] and the location where the user clicked
        with kwargs["position"].

        The following script opens a floating parameter window for the shader
        corresponding to the pixel the user last clicked on.
          viewer = hou.ui.paneTabOfType(hou.paneTabType.IPRViewer)
          px, py = viewer.lastClickLocation()

          if (px < 0 or px > viewer.imageResolution()[0] or
                  py < 0 or py >= viewer.imageResolution()[1]):
              hou.ui.displayMessage("Click on the image and then run this script again")
          else:
              material = viewer.materialNode(px, py)

              if material is not None:
                  parm_window = hou.ui.curDesktop().createFloatingPaneTab(
                      hou.paneTabType.Parm)
                  parm_window.setCurrentNode(material)
                  parm_window.setPin(True)
              else:
                  hou.ui.displayMessage("Click on an object to bring up the shader.")
        """
        return (0,0)

    def ropNode(self):
        """
        ropNode(self) -> hou.RopNode or None

        Return the ROP node that is selected in the viewer, or None if nothing
        is selected.

        REPLACES
            iprquerys function        """
        return RopNode()

    def setRopNode(self, rop_node):
        """
        setRopNode(self, rop_node)

        Set the ROP node to use for rendering.
        """

    def imageResolution(self):
        """
        imageResolution(self) -> (int, int)

        Return the resolution of the image.

        Raises hou.OperationFailed if the viewer does not contain an image.

        REPLACES
            iprquery function        """
        return (0,0)

    def cropRegion(self):
        """
        cropRegion(self) -> (float, float, float, float)

        Return the x0, x1, y0, and y1 normalized coordinates of the subregion
        that is selected, where (x0, y0) is the bottom-left corner and (x1, y1)
        is the top-right corner of the subregion.

        You can optionally tell the IPR viewer to only re-render only a portion
        of the image.  To select a subportion of the image, hold down shift and
        select the box.

        Note that the bottom-left corner is (0.0, 0.0) and the top-right corner
        is (1.0, 1.0).  For example, if the entire image is being rendered, this
        method returns (0.0, 1.0, 0.0, 1.0).

        REPLACES
            iprquery function        """
        return (0.0, 1.0, 0.0, 1.0)

    def planes(self):
        """
        planes(self) -> tuple of str

        Return the names of the image planes in the rendered output.

        Note that the special Op_Id image plane contains the hou.Node.sessionId
        ids of the object nodes in the image.  -1 indicates that there is no
        object node associated with the pixel. Use hou.IPRViewer.objectNode to
        access the object corresponding to that id.

        Similarly, the Prim_Id plane contains the hou.Prim.number ids of the
        primitives in the image.  Use hou.IPRViewer.prim to access the primitive
        corresponding to that id.

        Raises hou.OperationFailed if the viewer does not contain an image.

        REPLACES
            iprquery function
            iprquerys function        """
        return ('',)

    def pixel(self, plane_name, x, y):
        """
        pixel(self, plane_name, x, y) -> tuple of float

        Return the value of a pixel in one plane of the image.  This method
        returns a tuple of 1 to 4 floats, depending on the type of image plane.

        Note that the color plane is named C.

        Raises hou.OperationFailed if the plane name is invalid, the pixel
        location is outside the image, or the viewer does not contain an image.

        You can determine the number of components in the image plane using the
        following: len(viewer.pixel(plane_name, 0, 0)).

          >>> viewer.pixel("C", 300, 200)
          (0.69970703125, 0.46728515625, 0.289794921875, 1.0)

        REPLACES
            iprquery function        """
        return (0.0, 0.0, 0.0, 1.0)

    def objectNode(self, x, y):
        """
        objectNode(self, x, y) -> hou.ObjNode or None

        Return the object node contributing the pixel at the specified location,
        or None if there is no object at the pixel or if the pixel location is
        outside the image bounds

        The following function returns the SOP node containing the geometry that
        contributes the pixel to the final image:
          def sopNode(viewer, x, y):
              obj_node = viewer.objectNode(x, y)
              return (obj_node.renderNode() if obj_node is not None else None)


        Raises hou.OperationFailed if the viewer does not contain an image.

        REPLACES
            iprquerys function        """
        return ObjNode()

    def prim(self, x, y):
        """
        prim(self, x, y) -> hou.Prim or None

        Return the geometry primitive contributing the pixel at the specified
        location, or None if there is nothing at the pixel or if the pixel
        location is outside the image bounds

        Raises hou.OperationFailed if the viewer does not contain an image.

        REPLACES
            iprquery function        """
        return Prim()

    def materialNode(self, x, y):
        """
        materialNode(self, x, y) -> hou.ShopNode or None

        Return the SHOP node contributing the pixel at the specified location,
        or None if there is nothing at the pixel, the pixel location is outside
        the image bounds, or there is no shader on the geometry.

        This method first checks the primitive corresponding to the pixel and
        returns the SHOP corresponding to its shop_materialpath attribute. If
        the primitive does not have this attribute then it returns the SHOP
        assigned to the object.  If no SHOP is assigned to the object, it
        returns None.

        Raises hou.OperationFailed if the viewer does not contain an image.

        REPLACES
            iprquerys function        """
        return ShopNode()

class Keyframe(BaseKeyframe):
    """
    hou.Keyframe

    Class representing the default keyframe type, a numerical keyframe.

    REPLACES
      * chkey
      * chkeyls
    """

    def __init__(self, *args):
        """
        __init__(self, values)

        Return a new Keyframe object.  You can pass no parameters (the result
        will have no value set), a float value, a float value and float time, or
        a Keyframe object.
        """
    def evaluatedType(self):
        """
        evaluatedType(self) -> hou.parmData enum value
        """
        return parmData()

    def setValue(self, value):
        """
        setValue(self, value)

        Sets the value leaving the keyframe.
        """

    def value(self):
        """
        value(self) -> double

        Returns the value leaving the keyframe.

        This method raises hou.KeyframeValueNotSet if the value has not been
        set.
        """
        return 0.0

    def isValueSet(self):
        """
        isValueSet(self) -> bool

        Returns True if the value entering or leaving the keyframe has been set.
        """
        return True

    def setInValue(self, in_value):
        """
        setInValue(self, in_value)

        Sets the value entering the keyframe. Sets the value leaving the
        keyframe, if not already set. Unties the value.
        """

    def unsetInValue(self):
        """
        unsetInValue(self)

        Unsets the value entering the keyframe and untie the values.
        """

    def inValue(self):
        """
        inValue(self) -> double

        Returns the value entering the keyframe.

        This method raises hou.KeyframeValueNotSet if the value has not been set
        or the value is tied.
        """
        return 0.0

    def isValueTied(self):
        """
        isValueTied(self) -> bool

        Returns True if the value entering the keyframe has not been set.
        """
        return True

    def isValueUsed(self): return True
    def useValue(self): return
    def setSlope(self, slope):
        """
        setSlope(self, slope)

        Sets the slope leaving the keyframe.
        """

    def slope(self):
        """
        slope(self) -> double

        Returns the slope leaving the keyframe.

        This method raises hou.KeyframeValueNotSet if the slope has not been
        set.
        """
        return 0.0

    def isSlopeSet(self):
        """
        isSlopeSet(self) -> bool

        Returns True if the slope entering or leaving the keyframe has been set.
        """
        return True

    def isSlopeUsed(self): return True
    def useSlope(self): return
    def isSlopeAuto(self):
        """
        isSlopeAuto(self) -> bool

        Returns True if the slope leaving the keyframe is set to automatic.
        """
        return True

    def setSlopeAuto(self, on):
        """
        setSlopeAuto(self, on)

        Sets the slope leaving the keyframe to automatic.
        """

    def setInSlope(self, in_slope):
        """
        setInSlope(self, in_slope)

        Sets the slope entering the keyframe.  Sets the slope leaving the
        keyframe, if not already set.  Unties the slope.
        """

    def unsetInSlope(self):
        """
        unsetInSlope(self)

        Unsets the slope entering the keyframe and untie the slope.
        """

    def inSlope(self):
        """
        inSlope(self) -> double

        Returns the slope entering the keyframe.

        This method raises hou.KeyframeValueNotSet if the slope has not been set
        or the slope is tied.
        """
        return 0.0

    def isSlopeTied(self):
        """
        isSlopeTied(self) -> bool

        Returns True if the slope entering the keyframe has not been set.
        """
        return True

    def isInSlopeAuto(self):
        """
        isInSlopeAuto(self) -> bool

        Returns True if the slope entering the keyframe is set to automatic.
        """
        return True

    def setInSlopeAuto(self, on):
        """
        setInSlopeAuto(self, on)

        Sets the slope entering the keyframe to automatic.
        """

    def setAccel(self, accel):
        """
        setAccel(self, accel)

        Sets the acceleration leaving the keyframe.
        """

    def accel(self):
        """
        accel(self) -> double

        Returns the acceleration leaving the keyframe.

        This function raises hou.KeyframeValueNotSet if the acceleration has not
        been set.
        """
        return 0.0

    def isAccelSet(self):
        """
        isAccelSet(self) -> bool

        Returns True if the acceleration entering or leaving the keyframe has
        been set.
        """
        return True

    def isAccelUsed(self): return True
    def useAccel(self): return
    def setInAccel(self, in_accel):
        """
        setInAccel(self, in_accel)

        Sets the acceleration entering the keyframe.  Sets the acceleration
        leaving the keyframe, if not already set. Unties the acceleration.
        """

    def unsetInAccel(self):
        """
        unsetInAccel(self)

        Unsets the acceleration entering the keyframe and untie the
        acceleration.
        """

    def inAccel(self):
        """
        inAccel(self) -> double

        Returns the acceleration entering the keyframe.

        This method raises hou.KeyframeValueNotSet if the acceleration has not
        been set or it is tied.
        """
        return 0.0

    def isAccelTied(self):
        """
        isAccelTied(self) -> bool

        Returns True if the acceleration entering the keyframe has not been set.
        """
        return True

    def interpretAccelAsRatio(self, on):
        """
        interpretAccelAsRatio(self, on)

        Sets whether Houdini should interpret the acceleration values entering
        and leaving the keyframe as a single ratio.  When set to True, the
        ratio of the in-acceleration to out-acceleration is always maintained.
        If, for example, the in-acceleration is made to be twice as large  using
        the Animation Editor, then the out-acceleration will automatically  be
        adjusted to be twice as large as well.  This is the default behavior
        for Houdini keyframes.
        """

    def isAccelInterpretedAsRatio(self):
        """
        isAccelInterpretedAsRatio(self) -> bool

        Returns True if the acceleration values entering and leaving the
        keyframe are interpreted as a ratio by Houdini.
        """
        return True

class LabelParmTemplate(ParmTemplate):
    """
    hou.LabelParmTemplate

    Describes a label parameter.  Unlike most other parameters, labels do
    not store parameter values.


    """

    def __init__(self, name, label, column_labels=(), is_hidden=False,
        is_label_hidden=False, join_with_next=False, help=None, tags={}):
        """
        __init__(self, name, label, column_labels=(), is_hidden=False,
        is_label_hidden=False, join_with_next=False, help=None, tags={})

        Create a new LabelParmTemplate instance.

        name
            See hou.ParmTemplate.name for more information.

        label
            See hou.ParmTemplate.label for more information.

        column_labels
            See the setColumnLabels method for more information.

        is_hidden
            See hou.ParmTemplate.isHidden for more information.

        is_label_hidden
            See hou.ParmTemplate.isLabelHidden for more information.

        join_with_next
            See hou.ParmTemplate.joinsWithNext for more information.

        help
            See hou.ParmTemplate.help for more information.

        tags
            See hou.ParmTemplate.tags for more information.

        Note that the number of components in a label parm template corresponds
        to the number of column labels.
        """
    def columnLabels(self):
        """
        columnLabels() -> tuple of str

        Return the tuple of strings of column labels.  Normally, label parm
        templates do not have any column labels.  However, they may have these
        extra labels that are displayed in addition to the main label.

        Note that the number of components in a label parm template corresponds
        to the number of column labels.
        """
        return ('',)

    def setColumnLabels(self,column_labels):
        """
        setColumnLabels(column_labels)

        Set the column labels to a sequence of strings.

        The parameter editor in the <Type Properties Dialog> always has at least
        one column label, so if you supply an empty sequence there will be one
        column label that is an empty string.

        See the columnLabels method for more information.
        """

class Matrix2(object):

    def __init__(self, values):pass
    def isAlmostEqual(self, matrix2, tolerance=0.00001): return True
    def at(self): return
    def asTuple(self): return (0,)
    def asTupleOfTuples(self): return ((0,),(0,))
    def setAt(self): return
    def setTo(self): return
    def setToIdentity(self): return
    def setToZero(self): return
    def __add__(self): return
    def __sub__(self): return
    def __mul__(self): return
    def preMult(self): return
    def transposed(self): return
    def inverted(self): return
    def determinant(self): return
    def _asVoidPointer(self): return

class Matrix3(object):
    """
    hou.Matrix3

    A 3x3 matrix of floating point values.

    3x3 matrices are typically used in Houdini to represent a 3D rotation
    (with a possible scale).  Most places in Houdini use hou.Matrix4, which
    can store generation 3D transformations (including translations).

    Note that you can construct a general transformation Matrix4 from a
    Matrix3 by writing hou.Matrix4(matrix3).

    """

    def __init__(self, values ):
        """
        __init__(self, values)

        Return a new Matrix3.  You can pass no parameters (the result will
        contain all zeros), a float (the result's diagonal values will contain
        that float and the rest is all zeros), a sequence of 9 floats, or a
        sequence of sequences of 3 floats.

          >>> hou.Matrix3()
          <hou.Matrix3 [[0, 0, 0], [0, 0, 0], [0, 0, 0]]>

          >>> hou.Matrix3(1)
          <hou.Matrix3 [[1, 0, 0], [0, 1, 0], [0, 0, 1]]>

          >>> hou.Matrix3((0, 1, 2, 3, 4, 5, 6, 7, 8))
          <hou.Matrix3 [[0, 1, 2], [3, 4, 5], [6, 7, 8]]>

          >>> hou.Matrix3(((0, 1, 2), (3, 4, 5), (6, 7, 8)))
          <hou.Matrix3 [[0, 1, 2], [3, 4, 5], [6, 7, 8]]>

        Note that Houdini's matrices are stored in row-major order, so the
        matrix's contents are grouped by row.

        REPLACES
            matrix function        """
    def isAlmostEqual(self, matrix3, tolerance=0.00001):
        """
        isAlmostEqual(self, matrix3, tolerance=0.00001) -> bool

        Returns whether this matrix is equal to another, within a tolerance.
        """
        return _hou.Matrix3_isAlmostEqual(*args)
    def at(self, row, col):
        """
        at(self, row, col) -> double

        Return the value of the matrix at the given row and column.

        Raises IndexError if the row or column are not between 0 and 2,
        inclusive. Note that negative indices will not index from the end.
        """
        return 0.0

    def asTuple(self):
        """
        asTuple(self) -> tuple of float

        Return the contents of the matrix as a tuple of 9 floats.
        """
        return (0.0,)

    def asTupleOfTuples(self):
        """
        asTupleOfTuples(self) -> tuple of tuple of float

        Return the contents of the matrix as a tuple of tuples of 3 floats.
        """
        return ((0.0,),)

    def setAt(self, row, col, value):
        """
        setAt(self, row, col, value)

        Set the value of the matrix at the given row and column.

        Raises IndexError if the row or column are not between 0 and 2,
        inclusive. Note that negative indices will not index from the end.
        """

    def setTo(self, tuple):
        """
        setTo(self, tuple)

        Set this matrix's contents.  The sequence may contain either 9 floats or
        3 sequences, each with 3 floats.

        See hou.Matrix3.__init__ for examples of suitable parameter values.
        """

    def setToIdentity(self):
        """
        setToIdentity(self)

        Set this matrix to the multiplicative identity, having 1's in the
        diagonal.

        The matrix will contain the values [[1, 0, 0], [0, 1, 0], [0, 0, 1]].
        Note that you can construct a new matrix with these values using
        hou.Matrix3(1).
        """

    def setToZero(self):
        """
        setToZero(self)

        Set this matrix to contain all zeros.

        Note that you can construct a new matrix with all zeros with
        hou.Matrix3().
        """

    def __add__(self, matrix3):
        """
        __add__(self, matrix3) -> hou.Matrix3

        Add two matrices by adding corresponding entries together and return a
        new matrix.  This method lets you write m1 + m2, where m1 and m2 are
        Matrix3 objects.
        """
        return Matrix3()

    def __sub__(self, matrix3):
        """
        __sub__(self, matrix3) -> hou.Matrix3

        Subtract another matrix from this one, subtracting corresponding
        entries, and return a new matrix.  This method lets you write m1 - m2,
        where m1 and m2 are Matrix3 objects.
        """
        return Matrix3()

    def __mul__(self, matrix3_or_scalar):
        """
        __mul__(self, matrix3_or_scalar) -> hou.Matrix3

        Multiply this matrix by another matrix or by a scalar, returning a new
        matrix.  This method lets you write m1 * m2, where m1 and m2 are Matrix3
        objects, or m1 * s, where s is a float.

        See Wikipedia's matrix multiplication page for details on how each
        element in the result is computed.  Also see hou.Matrix4.
        """
        return Matrix3()

    def preMult(self, matrix3):
        """
        preMult(self, matrix3) -> hou.Matrix3

        Returns matrix3 * self.  Note that __mul__ returns self * matrix3, which
        is a different result because matrix multiplication is not commutative.
        """
        return Matrix3()

    def transposed(self):
        """
        transposed(self) -> hou.Matrix3

        Return the transpose of this matrix.  The result is such that self.at(i,
        j) == self.transposed().at(j, i) for 0 <= i,j <= 2.

        See Wikipedia's transpose page for more information.
        """
        return Matrix3()

    def inverted(self):
        """
        inverted(self) -> hou.Matrix3

        Return the inverse of this matrix.

        Raises hou.OperationFailed if the matrix is not invertible. Otherwise,
        (self * self.inverted()).isAlmostEqual(hou.Matrix3(1)) is True.

        See Wikipedia's invertible matrix page for more information.
        """
        return Matrix3()

    def determinant(self):
        """
        determinant(self) -> double

        Return the determinant of the matrix.

        See Wikipedia's determinant page.
        """
        return 0.0

    def extractRotates(self, rotate_order="xyz"):
        """
        extractRotates(self, rotate_order="xyz") -> hou.Vector3

        Return a Vector3 of Euler angles, in degrees, representing the rotation
        component of this matrix.  Rotating about the coordinate axes in the
        specified order by these amounts will yield the rotation contained in
        this matrix.

        rotate_order
            A string containing a permutation of the letters x, y, and z that
            determines the order in which rotations are performed about the
            coordinate axes.

        Raises hou.OperationFailed if the matrix does not represent a valid
        rotation matrix (e.g. it is singular) or the rotate order is not a
        permutation of the string 'xyz'.

        See also hou.Matrix4.explode and hou.Matrix4.extractRotates.
        """
        return Vector3()

    def _asVoidPointer(self): return

class Matrix4(object):
    """
    hou.Matrix4

    A 4x4 matrix of floating point values.

    4x4 matrices are typically used in Houdini to represent a 3D
    transformation (e.g. some combination of rotation, scaling, shearing,
    and translation).  A single matrix compactly represents a
    transformation, and is much easier to deal with than multiple translate,
    rotate, scale, shear, transformation order, and rotation order values.

    Note that Houdini's matrices are stored in row-major format, and vectors
    that are multiplied with matrices are treated as row vectors.  So, if p
    is a hou.Vector4 representing a point and M is a Matrix4, you write p*M,
    *not* M*p.  Similarly, p*M1*M2 will first transform p by M1, and then
    transform it by M2.


    Most mathematical notations treat vectors and points as column vectors
    instead of row vectors.  They will often use A*B*C (or simply ABC) to
    refer to a combined transform that first applies C's transform, then
    B's, and then applies A's. However, the convention is different in
    Houdini. To represent the equivalent matrix expression in Houdini, you
    need to concatenate the transforms in the reverse order.  So, you would
    instead write C'*B'*A', where C', B', A' are the transpose of C, B, A
    respectively.

    You can multiply Vector3s or Vector4s by Matrix4s.  If you multiply a
    Vector3, it is the same as multiplying a Vector4 where the fourth
    component is 1 (see hou.Vector3.__mul__).

    To transform a normal (as opposed to a point or vector), you need to
    multiply by the inverse transpose of the matrix.  For example, suppose:

    p
        is a hou.Vector3 object representing a position (or a hou.Vector4
        with v[4]==1)

    v
        is a hou.Vector4 object representing a vector (a direction with a
        length but no fixed location in space), with v[3]==0

    n
        is a hou.Vector4 object representing a normal, with v[3]==0

    m
        is a Matrix4 object representing a transform matrix

    Then you would write:

      p * m # to transform the point
      v * m # to transform the vector
      n * m.inverted().transposed() # to transform the normal
      # (note that m.inverted().transposed() is mathematically equivalent to m.transposed().inverted())

    Here is a concrete example:

      >>> m = hou.hmath.buildTranslate((1, 1, 2))
      >>> m
      <hou.Matrix4 [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [1, 1, 2, 1]]>
      >>> p = hou.Vector3(1, 2, 3)
      >>> p * m
      <hou.Vector3 [2, 3, 5]>

    Both VEX and the UT_DMatrix4 class in the Houdini Development Kit (HDK)
    also store matrices in row-major format.


    """

    def __init__(self, values):
        """
        __init__(self, values)

        Return a new Matrix4.  You can pass no parameters (the result will
        contain all zeros), a float (the result's diagonal values will contain
        that float and the rest is all zeros), a sequence of 16 floats, a
        sequence of sequences of 4 floats, or a hou.Matrix3.

          >>> hou.Matrix4()
          <hou.Matrix4 [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]>

          >>> hou.Matrix4(1)
          <hou.Matrix4 [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]>

          >>> hou.Matrix4((0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))
          <hou.Matrix4 [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15]]>

          >>> hou.Matrix4(((0, 1, 2, 3), (4, 5, 6, 7), (8, 9, 10, 11), (12, 13, 14, 15)))
          <hou.Matrix4 [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15]]>

          >>> matrix3 = hou.Matrix3((0, 1, 2, 3, 4, 5, 6, 7, 8))
          >>> matrix3
          <hou.Matrix3 [[0, 1, 2], [3, 4, 5], [6, 7, 8]]>
          >>> hou.Matrix4(matrix3)
          <hou.Matrix4 [[0, 1, 2, 0], [3, 4, 5, 0], [6, 7, 8, 0], [0, 0, 0, 1]]>

        Note that Houdini's matrices are stored in row-major order, so the
        matrix's contents are grouped by row.

        REPLACES
            matrix function        """
    def isAlmostEqual(self, matrix4, tolerance=0.00001):
        """
        isAlmostEqual(self, matrix4, tolerance=0.00001) -> bool

        Return whether this matrix is equal to another, within a tolerance.
        """
        return True

    def at(self, row, col):
        """
        at(self, row, col) -> float

        Return the value of the matrix at the given row and column.

        Raises IndexError if the row or column are not between 0 and 3,
        inclusive. Note that negative indices will not index from the end.
        """
        return 0.0

    def asTuple(self):
        """
        asTuple(self) -> tuple of float

        Return the contents of the matrix as a tuple of 16 floats.
        """
        return (0.0,)

    def asTupleOfTuples(self):
        """
        asTupleOfTuples(self) -> tuple of tuple of float

        Return the contents of the matrix as a tuple of tuples of 4 floats.
        """
        return ((0.0,),)

    def setAt(self, row, col, value):
        """
        setAt(self, row, col, value)

        Set the value of the matrix at the given row and column.

        Raises IndexError if the row or column are not between 0 and 3,
        inclusive. Note that negative indices will not index from the end.
        """

    def setTo(self, sequence):
        """
        setTo(self, sequence)

        Set this matrix's contents.  The sequence may contain either 16 floats
        or 4 sequences, each with 4 floats.

        See hou.Matrix4.__init__ for examples of suitable parameter values.
        """

    def setToIdentity(self):
        """
        setToIdentity(self)

        Set this matrix to the multiplicative identity, having 1's in the
        diagonal.

        The matrix will contain the values [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0,
        1, 0], [0, 0, 0, 1]].  Note that you can construct a new matrix with
        these values using hou.hmath.identityTransform or hou.Matrix4(1).

        REPLACES
            identity function        """

    def setToZero(self):
        """
        setToZero(self)

        Set this matrix to contain all zeros.

        Note that you can construct a new matrix with all zeros with
        hou.Matrix4().

        REPLACES
            mzero function        """

    def __add__(self, matrix4):
        """
        __add__(self, matrix4) -> hou.Matrix4

        Add two matrices by adding corresponding entries together and return a
        new matrix.  This method lets you write m1 + m2, where m1 and m2 are
        Matrix4 objects.
        """
        return Matrix4()

    def __sub__(self, matrix4):
        """
        __sub__(self, matrix4) -> hou.Matrix4

        Subtract another matrix from this one, subtracting corresponding
        entries, and return a new matrix.  This method lets you write m1 - m2,
        where m1 and m2 are Matrix4 objects.
        """
        return Matrix4()

    def __mul__(self, matrix4_or_scalar):
        """
        __mul__(self, matrix4_or_scalar) -> hou.Matrix4

        Multiply this matrix by another matrix or by a scalar, returning a new
        matrix.  This method lets you write m1 * m2, where m1 and m2 are Matrix4
        objects, or m1 * s, where s is a float.

        If m1 and m2 are transformation matrices and v is a vector, v * m1 * m2
        will transform v by m1, and then transform it by m2. This ordering
        occurs because Houdini's Matrices are stored in row-major format, and is
        opposite from the ordering used in traditional mathematical notation.
        Note that m1 * v is not a valid expression in Houdini

        See the Matrix4 class documentation and hou.Vector3.__mul__ for more
        information.  See Wikipedia's matrix multiplication page for details on
        how each element in the result is computed.
        """
        return Matrix4()

    def preMult(self):
        """
        preMult(self, matrix4) -> hou.Matrix4

        Returns matrix4 * self.  Note that __mul__ returns self * matrix4, which
        is a different result because matrix multiplication is not commutative.
        """
        return Matrix4()

    def transposed(self):
        """
        transposed(self) -> hou.Matrix4

        Return the transpose of this matrix.  The result is such that self.at(i,
        j) == self.transposed().at(j, i) for 0 <= i,j <= 3.

        See Wikipedia's transpose page for more information.

        REPLACES
            transpose function        """
        return Matrix4()

    def inverted(self):
        """
        inverted(self) -> hou.Matrix4

        Return the inverse of this matrix.

        Raises hou.OperationFailed if the matrix is not invertible. Otherwise,
        (self * self.inverted()).isAlmostEqual(hou.hmath.identityTransform()) is
        True.

        See Wikipedia's invertible matrix page for more information.

        REPLACES
            invert function        """
        return Matrix4()

    def determinant(self):
        """
        determinant(self) -> float

        Return the determinant of the matrix.

        See Wikipedia's determinant page.

        REPLACES
            determinant function        """
        return 0.0

    def explode(self, transform_order='srt', rotate_order='xyz',
        pivot=hou.Vector3()):
        """
        explode(self, transform_order='srt', rotate_order='xyz',
        pivot=hou.Vector3()) -> dict of str to hou.Vector3

        Return a dictionary with keys 'rotate', 'scale', 'translate', and
        'shear' whose values are hou.Vector3 objects.  When applied in the
        specified order, the corresponding rotations, scales (and shears), and
        translations will give this matrix.

        The rotation is returned as a set of Euler angles, in degrees.  See
        Wikipedia's Euler angles page for more information.

        transform_order
            A string containing a permutation of the letters s, r, and t. The
            rotate, scale, and translate results are dependent on the order in
            which you perform those operations, and this string specifies that
            order.

            For example, imagine a transformation where you first translate in x
            by one unit, then you rotate in z by 45 degrees.  With a transform
            order of 'trs' (translate, rotate, scale), the translate component
            is (1, 0, 0).  However, this same transformation could be
            constructed, for example, by first scaling, then rotating, and then
            translating. For this transformation order, the translate component
            would be (1.0 / math.sqrt(2), 1.0 / math.sqrt(2), 0).

        rotate_order
            A string containing a permutation of the letters x, y, and z that
            determines the order in which rotations are performed about the
            coordinate axes.

        pivot
            A Vector3 containing a position about which rotations and scales are
            performed.  By default, this parameter is set to the origin.

        Raises hou.OperationFailed if the matrix does not represent a valid
        transform matrix (e.g. it is singular), the transform order is not a
        permutation of the string 'srt', or the rotate order is not a
        permutation of the string 'xyz'.

        See hou.hmath.buildRotateAboutAxis for an example of how to convert
        Euler angles into an axis and rotation.

        See hou.ObjNode.setParmTransform for an example.  This method is the
        inverse of hou.hmath.buildTransform.  See also the other functions in
        hou.hmath that build transformation matrices.

        REPLACES
            explodematrix function        """
        return {'':Vector3(),}

    def extractTranslates(self, transform_order='srt'):
        """
        extractTranslates(self, transform_order='srt') -> hou.Vector3

        A shortcut for self.explode(transform_order)['translate'].  See
        hou.Matrix4.explode for more information.

          >>> matrix = hou.hmath.buildTranslate(1, 0, 0) * hou.hmath.buildRotate(0, 0, 45)
          >>> matrix.extractTranslates('trs')
          <hou.Vector3 [4, 0, 0]>
          >>> matrix.extractTranslates('srt')
          <hou.Vector3 [0.707107, 0.707107, 0]>

        REPLACES
            vtorigin function        """
        return Vector3()

    def extractRotates(self, transform_order='srt', rotate_order='xyz',
        pivot=Vector3()):
        """
        extractRotates(self, transform_order='srt', rotate_order='xyz',
        pivot=hou.Vector3()) -> hou.Vector3

        A shortcut for self.explode(transform_order, rotate_order,
        pivot)['rotate'].  See hou.Matrix4.explode for more information.

        REPLACES
            vrorigin function        """
        return Vector3()

    def extractScales(self, transform_order='srt', pivot=hou.Vector3()):
        """
        extractScales(self, transform_order='srt', pivot=hou.Vector3()) ->
        hou.Vector3

        A shortcut for self.explode(transform_order, rotate_order,
        pivot)['scale'].  See hou.Matrix4.explode for more information.
        """
        return Vector3()

    def extractShears(self, transform_order='srt', pivot=hou.Vector3()):
        """
        extractShears(self, transform_order='srt', pivot=hou.Vector3()) ->
        hou.Vector3

        A shortcut for self.explode(transform_order, rotate_order,
        pivot)['shear'].  See hou.Matrix4.explode for more information.
        """
        return Vector3()

    def extractRotationMatrix3(self):
        """
        extractRotationMatrix3(self)` -> hou.Matrix3

        Extracts the 3x3 rotation matrix from this matrix, assuming it is a
        transformation matrix. If it fails to extract the rotation, for example
        if scaling is zero on one axis, it returns the identity matrix instead.
        """
        return Matrix3()

    def _asVoidPointer(self): return

class MenuParmTemplate(ParmTemplate):
    """
    hou.MenuParmTemplate

    Describes a menu parameter containing evaluating to integer values. Note
    that StringParmTemplates may also have menus.

    REPLACES
      * opmenu


    """

    def __init__(self, name, label, menu_items, menu_labels=(), default_value=0,
        icon_names=(), item_generator_script='',
        item_generator_script_language=None, disable_when=None,
        menu_type=hou.menuType.Normal, is_hidden=False, is_label_hidden=False,
        join_with_next=False, help=None, script_callback=None,
        script_callback_language=hou.scriptLanguage.Hscript, tags={},
        default_expression="",
        default_expression_language=hou.scriptLanguage.Hscript):
        """
        __init__(self, name, label, menu_items, menu_labels=(), default_value=0,
        icon_names=(), item_generator_script='',
        item_generator_script_language=None, disable_when=None,
        menu_type=hou.menuType.Normal, is_hidden=False, is_label_hidden=False,
        join_with_next=False, help=None, script_callback=None,
        script_callback_language=hou.scriptLanguage.Hscript, tags={},
        default_expression="",
        default_expression_language=hou.scriptLanguage.Hscript)

        name
            See hou.ParmTemplate.name for more information.

        label
            See hou.ParmTemplate.label for more information.

        menu_items
            See the menuItems method for more information.

        menu_labels
            See the menuLabels method for more information.

            If this parameter is not given, it defaults to the value of the
            menu_items parameter.

        default_value
            See the defaultValue method for more information.

        icon_names
            See the iconNames method for more information.

            If this parameter is an empty tuple, the menu will not contain
            icons.

        item_generator_script
            See the itemGeneratorScript method for more information.

        item_generator_script_language
            See the itemGeneratorScriptLanguage method for more information.  If
            this parameter is None it defaults to hou.scriptLanguage.Python.

        menu_type
            See the menuType method for more information.

        disable_when
            See hou.ParmTemplate.disableWhen for more information.

        is_hidden
            See hou.ParmTemplate.isHidden for more information.

        is_label_hidden
            See hou.ParmTemplate.isLabelHidden for more information.

        join_with_next
            See hou.ParmTemplate.joinsWithNext for more information.

        help
            See hou.ParmTemplate.help for more information.

        script_callback
            See hou.ParmTemplate.scriptCallback for more information.

        script_callback_language
            See hou.ParmTemplate.scriptCallbackLanguage for more information.

        tags
            See hou.ParmTemplate.tags for more information.

        default_expression
            See the defaultExpression method for more information.

        default_expression_language
            See the defaultExpressionLanguage method for more information.

        Note that MenuParmTemplates have only one component.
        """
    def defaultValue(self):
        """
        defaultValue(self) -> int

        Return the index of the default menu item.

        See also the defaultValueAsString method.
        """
        return 0

    def defaultValueAsString(self): return ''
    def setDefaultValue(self, default_value):
        """
        setDefaultValue(self, default_value)

        Set the index of the default menu item.

        Note that if this index is out of range, it will be adjusted.
        """

    def defaultExpression(self):
        """
        defaultExpression(self) -> string

        Return the expression, which when evaluated, returns the index of the
        default menu item.

        The default expression takes precendence  over the default value.  If
        the default expression is not set  (i.e. an empty string), then the
        default value is used instead.

        Note that the default expression language is needed to interpret the
        meaning of the default expression.
        """
        return ''

    def setDefaultExpression(self, default_expression):
        """
        setDefaultExpression(self, default_expression)

        Set the default expression, which when evaluated, returns the index of
        the default menu item.

        If default_expression is the empty string, then the default expression
        is unset.
        """

    def defaultExpressionLanguage(self):
        """
        defaultExpressionLanguage(self) -> tuple of hou.scriptLanguage

        Return the default expression language.

        The default expression language only applies if the default expression
        is set.  If the default expression is not set, then the expression
        language is set to hou.scriptLanguage.Hscript.
        """
        return (scriptLanguage,)

    def setDefaultExpressionLanguage(self, default_expression_language):
        """
        setDefaultExpressionLanguage(self, default_expression_language)

        Set the default expression language.

        See the defaultExpressionLanguage method for more information.
        """

    def menuItems(self):
        """
        menuItems(self) -> tuple of str

        Return the tuple of internal menu names.

        These internal menu names are not displayed in the UI, but they can be
        passed to hou.Parm.set and will be returned by  hou.Parm.evalAsString
        for menu parameters.
        """
        return ('',)

    def setMenuItems(self, menu_items):
        """
        setMenuItems(self, menu_items)

        Set the internal menu names to the given sequence of strings.

        See the menuItems method for more information.

        If the new number of menu items is less than the old number, the menu
        labels will be shortened and the default value will be modified if it is
        out of range.
        """

    def menuLabels(self):
        """
        menuLabels(self) -> tuple of str

        Return the tuple of menu labels displayed in the UI.
        """
        return ('',)

    def setMenuLabels(self, menu_labels):
        """
        setMenuLabels(self, menu_labels)

        Set the menu labels displayed in the UI to the given sequence of
        strings.

        If the number of menu labels is less than the number of menu items,
        Houdini uses the internal menu item names for the missing labels.  If
        the number of labels is more than the number of menu items, Houdini
        discards the extra labels.

        If you want to change both the menu items and menu labels, be sure to
        change the menu items first.
        """

    def iconNames(self):
        """
        iconNames(self) -> tuple of str

        Return the tuple of icons corresponding to the menu items. If there are
        no icons, returns a tuple of empty strings.
        """
        return ('',)

    def setIconNames(self, icon_names):
        """
        setIconNames(self, icon_names)

        Set the icon names to the given sequence of strings.
        """

    def itemGeneratorScript(self):
        """
        itemGeneratorScriptLanguage(self) -> hou.scriptLanguage enum value

        Return the programming language for the script that generates menu
        items.
        """
        return scriptLanguage()

    def setItemGeneratorScript(self,item_generator_script):
        """
        setItemGeneratorScript(self, item_generator_script)

        Set the script used to generate menu items.

        See the itemGeneratorScript method for more information.
        """

    def itemGeneratorScriptLanguage(self): return
    def setItemGeneratorScriptLanguage(self, language):
        """
        setItemGeneratorScriptLanguage(self, language)

        Set the script language used to generate menu items to a
        hou.scriptLanguage enum value.

        See the itemGeneratorScriptLanguage method for more information.
        """

    def menuType(self):
        """
        menuType(self) -> hou.menuType enum value

        Return the type of menu.  Note that some menu types only apply to string
        parameters with menus, so the meaningful menu types for
        MenuParmTemplates are hou.menuType.Normal (for standard menus) and
        hou.menuType.Mini for menus that only display a dropdown arrow.  See
        hou.menuType for more information.
        """
        return menuType()

    def setMenuType(self, menu_type):
        """
        setMenuType(self, menu_type)

        Set the type of menu to a hou.menuType enum value.

        See the menuType method for more information.
        """

class NetworkEditor(PathBasedPaneTab):
    """
    hou.NetworkEditor

    REPLACES
      * neteditor
    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def autoPlaceNodes(self):
        """
        autoPlaceNodes(self) -> bool
        """
        return True

    def autoScrollNodes(self): return True
    def listMode(self):
        """
        listMode(self) -> bool
        """
        return True

    def setListMode(self, list_mode):
        """
        setListMode(self, list_mode)
        """

    def selectPosition(self, input_node=None, output_index=0, output_node=None,
        input_index=0):
        """
        selectPosition(self, input_node=None, output_index=0, output_node=None,
        input_index=0) -> Vector2
        """
        return Vector2()

    def cursorPosition(self): return Vector2()
    def homeToSelection(self):
        """
        homeToSelection(self)

        Centers the nodes within the network editor to show the current
        selection.
        """

    def frameSelection(self):
        """
        frameSelection(self)

        Centers the nodes within the network editor to show the current
        selection and zooms to its extents.
        """

    def insertIntoUnderlyingConnections(self): return
    def autoAddToNetbox(self): return
    def modifyPositionForNode(self, vector2, node):
        """
        modifyPositionForNode(self, vector2, node) -> Vector2

        A service method that offsets the position of the node, if necessary,
        for the node's midpoint to truly be located at the input position. This
        is necessary to properly position VOP nodes when given initial
        coordinates.
        """
        return Vector2()

class Bundle(object):
    """
    hou.NodeBundle

    A named set of nodes whose contents can be from different networks.  A
    bundle's contents may be fixed or may be determined from a pattern, and
    the contents may be filtered by node type.

    Unlike node groups, the nodes in a bundle may be from different node
    networks. For example, the same bundle may contain /obj/geo1 and
    /obj/subnet1/geo2. Node groups are primarily used to organize and
    display very large networks, while node bundles are normally used to
    track which objects are lit by a light, which objects are visible in a
    scene, etc.

    There are two types of node bundles: regular and smart.  You can add and
    remove individual nodes to and from a regular bundle.  The nodes in a
    smart bundle, on the other hand, are determined from a pattern stored in
    the bundle. As nodes matching the pattern are created or deleted in
    Houdini, the contents of the bundle will update automatically.  You can
    use hou.NodeBundle.pattern to determine if the bundle is a smart bundle
    or a regular one.

    When a node matches the pattern in a smart bundle, that node and its
    children will be added to the bundle.  For example, if the pattern in
    "/obj/*" and /obj/box_object1 is a geometry object, all the nodes
    inside /obj/box_object1 will be added to the bundle, recursively.
    Carets (^) in the pattern can be used to remove nodes; for example,
    "/obj/* ^/obj/geo1" will match everything in /obj except for
    /obj/geo1.

    A bundle may also have a filter to specify what types of nodes may be in
    the bundle.  See hou.nodeTypeFilter for the possible filters.  If you
    try to add a node to a regular bundle but the node does not match the
    filter, Houdini will fail to add the node.  For smart bundles, the
    filter is applied after doing any pattern matching.  For example, if the
    pattern is "/obj/*" and the filter is hou.nodeTypeFilter.Obj, the
    bundle will contain only the objects in /obj, without any SOPs, etc.
    inside them. Because the pattern is applied recursively, however, any
    objects inside object subnets will also be in the bundle.

    To specify a bundle in a node parameter that expects a list of nodes,
    prefix the bundle name with @.  For example, you can enter @bundle1 in
    the light mask parameter of an object so it is lit by the nodes inside
    the bundle named bundle1.

    You can view and edit node bundles in Houdini's Bundle List pane.  Use
    hou.nodeBundle_ and hou.nodeBundles to access existing node bundles, and
    hou.addNodeBundle to create a new bundle.


    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def destroy(self):
        """
        destroy(self)

        Remove this bundle.

        REPLACES
            opbrm command        """

    def name(self):
        """
        name(self) -> str

        Return the name of the bundle.

        REPLACES
            opbls command        """
        return ''

    def setName(self, name):
        """
        setName(self, name)

        Change the name of the bundle.

        Raises hou.OperationFailed if the name contains non-alphanumeric
        characters other than _, or if a bundle with that name already exists.

        REPLACES
            opbname command        """

    def filter(self):
        """
        filter(self) -> hou.nodeTypeFilter enum value

        Return the bundle's filter.  For smart bundles, the filter is applied
        after matching nodes to the pattern, and nodes whose types do not match
        the filter are removed from the bundle.

        See hou.nodeTypeFilter for the possible filters.
        hou.nodeTypeFilter.NoFilter is a special value to indicate that there is
        no filtering.

        See the class documentation for more information about filtering.

        REPLACES
            opbls command        """
        return nodeTypeFilter()

    def setFilter(self, node_type_filter):
        """
        setFilter(self, node_type_filter)

        Set this bundle's filter to a hou.nodeTypeFilter enumerated value. Use
        hou.nodeTypeFilter.NoFilter to clear the filter.

        See hou.NodeBundle.filter and the class documentation for more
        information.
        """

    def pattern(self):
        """
        pattern(self) -> str or None

        Return None if this bundle is a regular bundle, or a string pattern if
        the bundle is a smart bundle.

        See the class documentation for more information on smart bundles.  Note
        that if a node matches the pattern, all its subchildren will be in the
        bundle, as long as they match the filter.  For example, if the pattern
        is "/obj/*" and the filter is hou.nodeTypeFilter.NoFilter, the bundle
        will contain all nodes under /obj, recursively.

        REPLACES
            opbls command        """
        return ''

    def setPattern(self, pattern_or_none):
        """
        setPattern(self, pattern_or_none)

        Change the pattern of this bundle.

        Setting the pattern to None changes the bundle into a regular bundle.
        In this case, the bundle's contents are unchanged, but Houdini will no
        longer do pattern matching to determine the bundle's contents.

        If the pattern is a string, the bundle becomes a smart bundle and its
        contents immediately change to match the pattern.  The bundle's contents
        will update as nodes are created and deleted in Houdini.

        See hou.NodeBundle.pattern and the class documentation for more
        information.

        REPLACES
            opbop command        """

    def nodes(self):
        """
        nodes(self) -> tuple of hou.Node

        Return a tuple of the nodes in this bundle.

        REPLACES
            opbls command
            opblist function        """
        return (Node(),)

    def containsNode(self, node):
        """
        containsNode(self, node) -> bool

        Return True if the node is in the bundle and False otherwise.  node must
        be a hou.Node object.

        This method is a shortcut for node in bundle.nodes().  For bundles with
        many nodes, this method will be slightly faster.

        REPLACES
            opexist function        """
        return True

    def addNode(self, node):
        """
        addNode(self, node)

        Add a node to the bundle.

        Raises hou.OperationFailed if this bundle is a smart bundle, since the
        contents of smart bundles are automatically determined by their pattern.

        REPLACES
            opbop command        """

    def removeNode(self, node):
        """
        removeNode(self, node)

        Remove a node from the bundle.

        Raises hou.OperationFailed if this bundle is a smart bundle, since the
        contents of smart bundles are automatically determined by their pattern.

        REPLACES
            opbop command        """

    def clear(self):
        """
        clear(self)

        Remove all nodes from the bundle.

        Raises hou.OperationFailed if this bundle is a smart bundle, since the
        contents of smart bundles are automatically determined by their pattern.

        REPLACES
            opbop command        """

    def isSelected(self):
        """
        isSelected(self) -> bool

        Return True if the bundle is selected in the bundle list pane and False
        otherwise.

        REPLACES
            opbls command        """
        return True

    def setSelected(self, on, clear_all_selected=false):
        """
        setSelected(self, on, clear_all_selected=false)

        Select this bundle in the bundle list pane.  If clear_all_selected is
        True, only this bundle will remain selected.  Otherwise, this bundle
        will be added to the existing selection.
        """

class NodeConnection(object):
    """
    hou.NodeConnection

    Represents a connection (wire) between two Nodes.

    OVERVIEW
    You can get a list of NodeConnection objects from a hou.Node instance
    using hou.Node.inputConnections and hou.Node.outputConnections.


    It is probably easier to use the hou.Node..inputs and hou.Node.outputs
    methods (which return the endpoints of a node's connections) to traverse
    the network, rather than dealing with the connections themselves.

    This object is "read-only". To create or edit connections, use methods
    on the node, such as hou.Node.setNamedInput, hou.Node.setInput,
    hou.Node.setFirstInput, hou.Node.setNextInput, hou.Node.createInputNode,
    and hou.Node.createOutputNode.

        You can get a list of NodeConnection objects from a hou.Node
        instance using hou.Node.inputConnections and
        hou.Node.outputConnections.


        It is probably easier to use the hou.Node..inputs and
        hou.Node.outputs methods (which return the endpoints of a node's
        connections) to traverse the network, rather than dealing with the
        connections themselves.

        This object is "read-only". To create or edit connections, use
        methods on the node, such as hou.Node.setNamedInput,
        hou.Node.setInput, hou.Node.setFirstInput, hou.Node.setNextInput,
        hou.Node.createInputNode, and hou.Node.createOutputNode.


    INPUT AND OUTPUT MEANING
    Somewhat confusingly, the hou.NodeConnection.outputNode and
    hou.NodeConnection.inputNode are named in relation to the _nodes_, *not*
    the "input" and "output" ends of the _connector_.


    So, outputNode() returns the node whose _output_ is this connector. In
    the diagram, outputNode() on the highlighted connection would return
    node "A". inputNode() returns the node whose input is this connector.
    In the diagram, inputNode() on the highlighted connection would return
    node "C".

        Somewhat confusingly, the hou.NodeConnection.outputNode and
        hou.NodeConnection.inputNode are named in relation to the _nodes_,
        *not* the "input" and "output" ends of the _connector_.


        So, outputNode() returns the node whose _output_ is this connector.
        In the diagram, outputNode() on the highlighted connection would
        return node "A". inputNode() returns the node whose input is this
        connector. In the diagram, inputNode() on the highlighted connection
        would return node "C".


    CONNECTION INDEXES
    Some nodes have multiple inputs and/or multiple outputs. For example,
    most VOPs have several inputs and outputs. The Split DOP has multiple
    outputs.

    A node with a multi-input, such as the Merge SOP, has multiple
    "inputs" for each connection, even though in the network editor it is
    drawn with one "connection point" at the top.

    Inputs and outputs are always addressed by their position (index).


        Some nodes have multiple inputs and/or multiple outputs. For
        example, most VOPs have several inputs and outputs. The Split DOP
        has multiple outputs.

        A node with a multi-input, such as the Merge SOP, has multiple
        "inputs" for each connection, even though in the network editor it
        is drawn with one "connection point" at the top.

        Inputs and outputs are always addressed by their position (index).




    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def inputNode(self):
        """
        inputNode(self) -> hou.Node

        Return the node on the input side of this connection. This is the node
        that the connection comes from, in the direction of data flow.
        """
        return Node()

    def outputNode(self):
        """
        outputNode(self) -> hou.Node

        Return the node on the output side of this connection. This is the node
        that the connection goes to, in the direction of data flow.
        """
        return Node()

    def inputIndex(self):
        """
        inputIndex(self) -> int

        Returns the index of the input connection on the node that the output
        side of this connections connects to.

        See the class documentation for more information.
        """
        return 0

    def outputIndex(self):
        """
        outputIndex(self) -> int

        Returns the index of the output connection on the node that the input
        side of this connections connects to.

        See the class documentation for more information.
        """
        return 0

    def inputName(self):
        """
        inputName(self) -> str

        Returns the name of the input connection on the node that the output
        side of this connections connects to.
        """
        return ''

    def outputName(self):
        """
        outputName(self) -> str

        Returns the name of the output connection on the node that the input
        side of this connections connects to.
        """
        return ''

    def subnetIndirectInput(self):
        """
        subnetIndirectInput(self) -> hou.SubnetIndirectInput

        If this connection has a subnet indirect input connected to it instead
        of a node, return the corresponding object.  Otherwise, return None.
        See hou.SubnetIndirectInput for information on subnet indirect inputs.
        """
        return SubnetIndirectInput()

class NodeTypeCategory(object):
    """
    hou.NodeTypeCategory

    Represents a category of node types, such as surface nodes (SOPs) or
    particle nodes (POPs).

    Use hou.nodeTypeCategories to get a dict of node type category names to
    NodeTypeCategory objects.  You can use hou.objNodeTypeCategory,
    hou.sopNodeTypeCategory, etc. to directly access a particular node type
    category.

    See also hou.NodeType and hou.Node.

      # Get the names of all the node type categories.
      >>> hou.nodeTypeCategories().keys()
      ['Shop', 'Cop2', 'CopNet', 'Particle', 'ChopNet', 'Object', 'Driver', 'Pop',
      'Chop', 'Sop', 'Manager', 'Vop', 'Director', 'Dop', 'VopNet']

    RELATED
      * hou.nodeTypeCategories
      * hou.objNodeTypeCategory
      * hou.sopNodeTypeCategory
      * hou.popNodeTypeCategory
      * hou.dopNodeTypeCategory
      * hou.cop2NodeTypeCategory
      * hou.shopNodeTypeCategory_
      * hou.vopNodeTypeCategory
      * hou.ropNodeTypeCategory
      * hou.chopNodeTypeCategory
      * hou.popNetNodeTypeCategory
      * hou.cop2NetNodeTypeCategory
      * hou.vopNetNodeTypeCategory
      * hou.chopNetNodeTypeCategory
      * hou.managerNodeTypeCategory
      * hou.rootNodeTypeCategory


    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def name(self):
        """
        name(self) -> str

        Returns the name of this node type category.

        REPLACES
            optype command
            optypeinfo function        """
        return ''

    def typeName(self): return ''
    def nodeTypes(self):
        """
        nodeTypes(self) -> dict of str to hou.NodeType

        Return a dict mapping node type names to node types in this category.

        For example, if this node type category is SOPs, the keys in the
        dictionary would be "box", "sphere", "polyextrude", "subdivide",
        etc.

        Note that the node types in this category may not all be instances of
        the same class.  For example, most node types in the SOP node type
        category are instances of hou.SopNodeType, but some, like SHOP networks,
        CHOP networks, etc. are not.

          # Access the box SOP's node type.
          hou.sopNodeTypeCategory().nodeTypes()['box']

          def findNodeTypes(node_type_category, pattern):
              '''Return a list of node types in a particular node type category
                 whose names match a pattern.'''
              import fnmatch

              return [node_type
                  for node_type_name, node_type in node_type_category.nodeTypes().items()
                  if fnmatch.fnmatch(node_type_name, pattern)]

        See also hou.nodeType_.

        REPLACES
            opadd command
            otglob command        """
        return (NodeType(),)

    def viewerStates(self, viewer_type):
        """
        viewerStates(self, viewer_type) -> tuple of hou.ViewerState
        """
        return (ViewerState(),)

    def loadDSO(self, dso_path):
        """
        loadDSO(self, dso_path)

        Loads the HDK custom operator identified by the given file path for this
        node type category. It will use the HOUDINI_DSO_PATH environment
        variable to find it if necessary.
        """

    def _asVoidPointer(self): return

def nodeTypeCategories():
    return NodeTypeCategory()
def objNodeTypeCategory():
    return NodeTypeCategory()
def sopNodeTypeCategory():
    return NodeTypeCategory()
def popNodeTypeCategory():
    return NodeTypeCategory()
def dopNodeTypeCategory():
    return NodeTypeCategory()
def cop2NodeTypeCategory():
    return NodeTypeCategory()
def shopNodeTypeCategory():
    return NodeTypeCategory()
def vopNodeTypeCategory():
    return NodeTypeCategory()
def ropNodeTypeCategory():
    return NodeTypeCategory()
def chopNodeTypeCategory():
    return NodeTypeCategory()
def popNetNodeTypeCategory():
    return NodeTypeCategory()
def cop2NetNodeTypeCategory():
    return NodeTypeCategory()
def vopNetNodeTypeCategory():
    return NodeTypeCategory()
def chopNetNodeTypeCategory():
    return NodeTypeCategory()
def managerNodeTypeCategory():
    return NodeTypeCategory()
def rootNodeTypeCategory():
    return NodeTypeCategory()


class OrboltURLHandler(object):

    def __init__(self): raise AttributeError, "No constructor defined"
    def updateProgressBar(self): return
    def closeSplashScreen(self): return

class PackedPrim(Prim):
    """
    hou.HOM_PackedPrim

    A packed primitive.

    See packed primitives for more information.

    To set contents of the packed primitive, use the
    hou.Prim.setIntrinsicValue method:

      prim = myGeometry.createPacked("PackedDisk")
      prim.setIntrinsicValue("unexpandedfilename", "defgeo.bgeo")

    To get the list of available "intrinsic attributes" you can set:

    * View a packed primitive of the type you want in the geometry
      spreadsheet and turn on display of intrinsic attributes.

      _or_

    * In a Houdini tools command line, type ginfo -IP to see a list of all
      intrinsc attributes on all packed primitive types.

    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def transform(self):
        """
        transform(self) -> hou.Matrix3

        Returns the local 3x3 transform associated with this primitive. The
        transform doesn't include the local point transform or any transforms
        inside the primitive (for example, transforms inside an Alembic file).
        """
        return Matrix3()

    def fullTransform(self): return
    def setTransform(self, matrix4):
        """
        setTransform(self, m4)

        Sets this primitive's local transform. This sets the local 3x3 transform
        _and_ the translation of the point. This does not affect any transforms
        inside the primitive (for example, transforms inside an Alembic file).

        m4
            A hou.Matrix4 object containing the full transform.
        """

    def vertex(self, index):
        """
        vertex(self, index) -> hou.Vertex

        A shortcut for self.vertices()[index].  You probably don't need to call
        this method.

        This method supports negative indices to index from the end, just like
        self.vertices()[index] would.  Also, like Python's indexing operator, it
        will raise IndexError when the index is out of range.
        """
        return Vertex()

class Parm(object):
    """
    hou.Parm

    A parameter in a node.  Each parameter has a unique name within its node
    and exists inside a parameter tuple.

    REPLACES
      * chadd
      * chalias
      * chautoscope
      * chkey
      * chkeyget
      * chkeyls
      * chlock
      * chrefit
      * chreverse
      * chrm
      * chround
      * chscope
      * chstretch
      * opparm
      * opscript
      * ch
      * chf
      * chs
      * chsraw
      * cht


    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def node(self):
        """
        node(self) -> hou.Node

        Returns the node on which this parameter exists.
        """
        return Node()

    def tuple(self):
        """
        tuple(self) -> hou.ParmTuple

        Returns the hou.ParmTuple associated with this parameter.

        For example, calling this method on the Parm object for the translation
        parameter "tx", would return a ParmTuple that contains Parm objects
        for the three translation parameters "tx", "ty" and "tz". If no
        tuple is associated with the parameter, then the parameter itself is
        returned in a tuple of size 1.
        """
        return ParmTuple()

    def parmTemplate(self):
        """
        parmTemplate(self) -> hou.ParmTemplate

        Returns the template for this parameter.
        """
        return ParmTemplate()

    def name(self):
        """
        name(self) -> str

        Returns this parameter's name.
        """
        return ''

    def path(self):
        """
        path(self) -> str

        Returns the full path to this parameter.
        """
        return ''

    def description(self):
        """
        description(self) -> str

        Returns this parameter's label.
        """
        return ''

    def componentIndex(self):
        """
        componentIndex(self) -> int

        Returns the component index of this parameter.

        For example, the translation parameter along the x-axis, "tx", would
        return a component index of 0, while the translation parameter along the
        y-axis, "ty" would return a component index of 1.
        """
        return 0

    def menuLabels(self):
        """
        menuLabels(self) -> tuple of str

        Returns a list of labels for all possible menu items (for a menu
        parameter). Raises hou.OperationFailed if this parameter is not a menu.
        """
        return ('',)

    def menuItems(self):
        """
        menuItems(self) -> tuple of str

        Returns a list of all possible menu items (for a menu parameter). Raises
        hou.OperationFailed if this parameter is not a menu.
        """
        return ('',)

    def pressButton(self):
        """
        pressButton(self)

        Emulates clicking a button parameter to trigger its callback script.
        Raises hou.OperationFailed if the callback script could not be run.
        """

    def setPending(self, value):
        """
        setPending(self, value)

        Sets the parameter value at the current frame and marks it as pending if
        the parameter is keyed.

        Raises hou.TypeError if the type of value does not match this
        parameter's type. Raises hou.PermissionError if this parameter is not
        writable.
        """

    def set(self, value, language=None):
        """
        set(self, value, language=None)

        Sets the parameter value at the current frame.

        If this parm currently contains a channel reference to another
        parameter, this method will follow channel references and change the
        value of the referenced parameter.  If this is not the desired behavior,
        first delete the channel reference with deleteAllKeyframes.

        Pass in a hou.Ramp object, as the parameter value, to set the value  of
        a ramp parameter. The ramp object's type needs to match the target
        ramp's type.

        Raises hou.TypeError if the type of value does not match the type of
        this parameter. Raises hou.PermissionError if this parameter is not
        writable.

        See also hou.Node.setParms.
        """

    def revertToDefaults(self):
        """
        revertToDefaults(self)

        Change the value back to the default(s). See also the
        revertToAndRestoreFactoryDefaults() method.
        """

    def revertToAndRestorePermanentDefaults(self):
        """
        revertToAndRestorePermanentDefaults(self)

        Changes the value back to the default that ships with Houdini, and
        restores that default.

        See also the revertToDefaults() method, and
        hou.ParmTuple.revertToAndRestorePermanentDefaults
        """

    def hasTemporaryDefaults(self):
        """
        hasTemporaryDefaults(self) -> bool

        Returns whether a default has been explicitly set on the parameter.

        See also the revertToDefaults() and
        revertToAndRestorePermanentDefaults()methods.
        """
        return True

    def isAtDefault(self, compare_temporary_defaults=True,
        compare_expressions=False):
        """
        isAtDefault(self, compare_temporary_defaults=True,
        compare_expressions=False) -> bool

        Returns whether the parameter is currently at its default.

        compare_temporary_defaults
            When <compare_temporary_defaults> is True, isDefault also checks
            against any temporary defaults a user may have set.  The value of
            <compare_temporary_defaults> must be either True or False.

        compare_expressions
            When <compare_Expressions> is True, isDefault compares the actual
            expression when a parameter has a default factory expression. The
            value of <compare_expressions> must be either True or False.

        See also the revertToDefaults() and
        revertToAndRestorePermanentDefaults()methods.
        """
        return True

    def setExpression(self, expression, language=None, replace_expression=True):
        """
        setExpression(self, expression, language=None, replace_expression=True)

        Sets this parameter's expression.

        expression
            A string containing the expression that will go inside the
            parameter.

        language
            Either a hou.exprLanguage enumeration value or None.

            If language is None and the parameter does not already contain an
            expression, the language will be the node's expression language.
            (See hou.Node.expressionLanguage.)  Otherwise, if language is None
            and the parameter already has an expression, the expression language
            will not change.

        replace_expression
            This parameter only has effect if the parameter already contains
            keyframes.  If it is True, Houdini will replace the keyframe before
            the current time with one containing the new expression. Otherwise,
            it will always add a keyframe at the current time. Note that this
            behavior matches what happens when you edit an expression from
            Houdini's parameter dialog.

        Unlike hou.Parm.set, this method does not follow channel references.
        That is, if this parameter is referencing another parameter and you call
        setExpression(), it change the channel reference expression into the
        specified expression.

        If the parameter does not already contain any keyframes, this method is
        roughly equivalent to setting a keyframe at frame 1, where the
        keyframe's expression and language are the ones specified.

        This method can be approximately implemented as follows:

          def setExpression(self, expression, language=None, replace_expression=None)
              if self.template().type() == hou.parmTemplateType.String:
                  k = hou.StringKeyframe()
              else:
                  k = hou.Keyframe()

              k.setExpression(expression, language)

              if len(self.keyframes()):
                  if replace_expression:
                      k.setTime(self.effectiveKeyframeAtFrame(hou.frame()).time())
                  else:
                      k.setTime(hou.time())
              else
                  k.setTime(0.0)

              self.setKeyframe(k)

        See also the expression, expressionLanguage, and setKeyframe methods,
        hou.Node.expressionLanguage, and hou.Node.setExpressions.
        """

    def expression(self):
        """
        expression(self) -> str

        Returns this parameter's expression.

        For example, a parameter might contain the Python expression "frame() *
        2". In this case [Hom:hou.Parm#eval] at frame 2 would return the value
        4, while calling expression() would return the string "frame() * 2".

        If the parameter does not contain an expression, this method will raise
        hou.OperationFailed.  Also, if the parameter contains more than one
        keyframe then it could contain multiple different expressions, so it
        also raises hou.OperationFailed in that case.

        This method is roughly equivalent to...
          parm.keyframes()[0].expression()


        See also the setExpression(), expressionLanguage(), keyframes(), and
        eval() methods.
        """
        return ''

    def expressionLanguage(self):
        """
        expressionLanguage(self) -> hou.exprLanguage enum value

        Returns the parameter's expression's language.

        If the parameter does not contain an expression, this method will raise
        hou.OperationFailed.  Also, if the parameter contains more than one
        keyframe then it could contain multiple different expressions, so it
        also raises hou.OperationFailed in that case.

        To change the expression language, use hou.Parm.setExpression and
        explicitly specify the language: parm.setExpression(parm.expression(),
        language).

        This method is roughly equivalent to...

          parm.keyframes()[0].expressionLanguage()

        See also the expression(), setExpression(), keyframes(), and
        setExpressionLanguage() methods.
        """
        return exprLanguage()

    def setKeyframe(self,keyframe):
        """
        setKeyframe(self, keyframe)

        Sets a keyframe on this parameter.

        Raises hou.TypeError if keyframe is not of type hou.BaseKeyframe. Raises
        hou.PermissionError if this parameter is not writable.
        """

    def keyframes(self):
        """
        keyframes(self) -> tuple of hou.BaseKeyframe

        Returns the keyframes on this parameter.
        """
        return (BaseKeyframe(),)

    def evalAsFloat(self):
        """
        evalAsFloat(self) -> float

        Evaluates this parameter at the current frame and returns the result as
        a float.

        Raises hou.TypeError if the value cannot be converted to a float.
        """
        return 0.0

    def evalAsFloatAtFrame(self, frame):
        """
        evalAsFloatAtFrame(self, frame) -> float

        Evaluates this parameter at a certain frame and returns the result as a
        float.

        Raises hou.TypeError if the value cannot be converted to a float.
        """
        return 0.0

    def evalAsInt(self):
        """
        evalAsInt(self) -> int

        Evalutes this parameter at the current frame and returns the result as
        an integer.

        Raises hou.TypeError if the value cannot be converted to an integer.
        """
        return 0

    def evalAsIntAtFrame(self, frame):
        """
        evalAsIntAtFrame(self, frame) -> int

        Evaluates this parameter at a certain frame and returns the result as an
        integer.

        Raises hou.TypeError if the value cannot be converted to an integer.
        """
        return 0

    def evalAsString(self, frame):
        """
        evalAsRampAtFrame(self, frame) -> str

        Evalutes this parameter at a certain frame and returns the result as a
        ramp.

        Raises hou.TypeError if the parameter is not a ramp.

        REPLACES
            opramp command        """
        return ''

    def evalAsStringAtFrame(self, frame):
        """
        evalAsStringAtFrame(self, frame) -> str

        Evaluates this parameter at a certain frame and returns the result as a
        string.

        If you want the string contents of the parameter before variable
        expansion and expression evaluation then call hou.Parm.unexpandedString.

        Raises hou.TypeError if the value cannot be converted to a string.
        """
        return ''

    def evalAsRamp(self): return Ramp()
    def evalAsRampAtFrame(self, frame): return Ramp()
    def unexpandedString(self):
        """
        unexpandedString(self) -> str

        Returns the contents of the parameter before dollar sign and back-tick
        expansion.

        Examples of unexpanded strings would be "image$F.pic",
        "$HIP/split.otl", or "chs('../font1/text')".  If you were to call
        eval() on them, Houdini would perform variable expansion and back-tick
        expression evaluation, so you would get back something like
        "image1.pic" instead of "image$F.pic".

        Because only string parameters will attempt to do dollar sign and string
        expansion, this method will raise hou.OperationFailed if called from a
        non-string parameter.

        Suppose a string parameter contains keyframes. In this situation,
        Houdini will not attempt to do string expansion on the parameter's
        value, so calling this method will raise hou.OperationFailed. Instead of
        calling this method, you can call expression() to access the first
        Keyframe's expression. If there are multiple keyframes, you can call
        keyframes() to get a list of hou.StringKeyframe objects and call
        expression() on those objects to retrieve the expression.
        """
        return ''

    def deleteKeyframeAtFrame(self, frame): return
    def deleteAllKeyframes(self):
        """
        deleteAllKeyframes(self)

        Removes all keyframes from this parameter.

        This has no effect if there are no keyframes to delete. The value of the
        parameter after all keyframes are removed will be the one it evaluated
        to at the current frame.

        This function will raise a hou.ObjectWasDeleted exception if it is
        invoked  on a parameter that does not exist in Houdini.

        This function will raise a hou.PermissionError exception if writing to
        the specified parameter is impossible.

        See also hou.ParmTuple.deleteAllKeyframes.
        """

    def getReferencedParm(self):
        """
        getReferencedParm(self) -> hou.Parm

        Returns the referenced parameter. If no parameter is referenced, returns
        this parameter.
        """
        return Parm()

    def parmsReferencingThis(self):
        """
        parmsReferencingThis(self) -> tuple of hou.Parm

        Return a tuple of all the parameters in the scene that have channel
        references to this parameter.
        """
        return (Parm(),)

    def isLocked(self):
        """
        isLocked(self) -> bool

        Returns whether this parameter is locked (uneditable).
        """
        return True

    def lock(self, on):
        """
        lock(self, on)

        Locks (lock(True)) or unlocks (lock(False)) this parameter (this is,
        makes the value uneditable).

        Raises hou.PermissionError if this parameter is part of a locked digital
        asset.
        """

    def isAutoscoped(self):
        """
        isAutoscoped(self) -> bool

        Returns whether this parameter's autoscope property is on.
        """
        return True

    def setAutoscope(self, on):
        """
        setAutoscope(self, on)

        Changes the autoscope property of the parameter. If this property is on,
        this parameter is automatically scoped when the object is selected.
        """

    def alias(self):
        """
        alias(self) -> str

        Returns the parameter's channel alias name. Returns an empty string if
        no such name exists.
        """
        return ''

    def setAlias(self, alias_name):
        """
        setAlias(self, alias_name)

        Gives the parameter another name by which it can be referenced in
        channels.  You can pass in an empty string to remove an existing alias
        name.
        """

    def isSpare(self):
        """
        isSpare(self) -> bool

        Returns whether this parameter is a "spare" (user-defined) parameter.
        """
        return True

    def isTimeDependent(self):
        """
        isTimeDependent(self) -> bool

        Returns whether this parameter is _time dependent_, that is, its value
        changes depending on the point on the timeline at which it's evaluated.
        For example the parameter has an expression containing the $F (current
        frame number) variable.
        """
        return True

    def isMultiParmInstance(self):
        """
        isMultiParmInstance(self) -> bool

        Return whether this parameter is an instance of a multi parm.  For
        example, the pt0x, pt1x, pt2x, etc. parameters in an add SOP are
        instances of a multiparm.
        """
        return True

    def multiParmInstances(self):
        """
        multiParmInstances(self) -> tuple of hou.Parm

        If this parameter corresponds to the number of instances for a
        multiparm, return all the parameters corresponding to all instances of
        this multiparm.

        Returns an empty tuple if this parameter is not for a multiparm.
        """
        return Parm()

    def insertMultiParmInstance(self, index):
        """
        insertMultiParmInstance(self, index)

        Insert a new multi parm instance before the given index. To append a new
        multi parm instance, set the index to be the current number of
        instances. The current number can be queried by calling evalAsInt on the
        this  parameter.
        """

    def removeMultiParmInstance(self, index):
        """
        removeMultiParmInstance(self, index)

        Removes the multi parm instance at the given index.
        """

    def containingFolders(self):
        """
        containingFolders(self) -> tuple of str

        Returns a tuple of strings corresponding to the names of the folders
        containing this parameter.

        For example, if this parameter is in the Shading folder and the Shading
        folder is inside the Render folder, this method will return ("Render",
        "Shading").

        Returns an empty tuple if this parameter is not inside a folder.

        Note that calling this method on many parameters may be slow. For a
        faster alternative, see hou.Node.parmsInFolder.

        See also the containingFolderSetParmTuples method, and
        hou.Node.parmTuplesInFolder.
        """
        return ('',)

    def containingFolderIndices(self):
        """
        containingFolderIndices(self) -> tuple of int

        Return a tuple of indices corresponding to the folders containing this
        parameter.  Each index refers to a folder in the corresponding folder
        set parameter.

        This method can be implemented as follows:
          def containingFolderIndices(self):
              return tuple(
                  list(folder_set_parm_tuple.parmTemplate().folderNames()).index(
                      folder_name)
                  for folder_set_parm_tuple, folder_name in zip(
                      parm.containingFolderSetParmTuples(), parm.containingFolders()))


        This example makes a parameter visible in the parameter pane by opening
        all the folders containing it.
          def makeParmVisible(parm):
              for folder_set_parm_tuple, folder_index in zip(
                      parm.containingFolderSetParmTuples(),
                      parm.containingFolderIndices()):
                  folder_set_parm_tuple[0].set(folder_index)
        """
        return (0,)

    def containingFolderSetParmTuples(self):
        """
        containingFolderSetParmTuples(self) -> tuple of hou.ParmTuple

        Return a tuple of ParmTuples corresponding to the folders containing
        this parameter.

        For example, if this parameter is in the Shading folder and the Shading
        folder is inside the Render folder, this method will return a tuple
        containing the Render parm tuple and the Shading parm tuple.  Any parm
        tuples returned will be folder sets.

        If this parameter is not inside a folder, an empty tuple is returned.

        See also the containingFolders() method, and hou.Node.parmsInFolder and
        hou.Node.parmTuplesInFolder.
        """
        return (ParmTuple(),)

    def asCode(self, brief=False, save_values=True, save_keyframes=True,
        save_keys_in_frames=False, save_flag_values=True, save_aliases=True,
        function_name=None):
        """
        asCode(self, brief=False, save_values=True, save_keyframes=True,
        save_keys_in_frames=False, save_flag_values=True, save_aliases=True,
        function_name=None) -> str

        Returns a script of Python statements that can be executed to  set the
        parameter tuple's values, flags and other properties. To run the script,
        use either Python's exec or execfile functions.

        brief
            When <brief> is True, the output script omits commands for  setting
            values and flags that are set to the factory defaults.   The script
            also omits keyframe commands that set unused values, slopes and
            accelerations.  The value of <brief> must be either True or False.

        save_values
            When <save_values> is True, asCode outputs commands for setting the
            parameter tuple's values.  The value of  <save_values> must be
            either True or False.

        save_keyframes
            When <save_keyframes> is True, asCode outputs commands for creating
            the parameter tuple's keyframes (if any).  The value  of
            <save_keyframes> must be either True or False.

        save_keys_in_frames
            When <save_keys_in_frames> is True, asCode outputs commands for
            setting channel and key times in samples (frames) instead  of
            seconds.  This parameter has no effect if <save_keyframes> is set to
            False.  The value of <save_keys_in_frames> must be either True or
            False.

        save_flag_values
            When <save_flag_values> is True, asCode outputs commands for setting
            the parameter tuple's flag values.  The value of <save_flag_values>
            must be either True or False.

        save_aliases
            When <save_aliases> is True, asCode outputs commands for setting the
            parameter tuple's channel aliases.  The value of <save_aliases> must
            be either True or False.

        function_name
            If <function_name> is specified, then the output script  is wrapped
            in a Python function definition with the given name. <function_name>
            must be a non-zero length string consisting of  only alphanumeric
            and underscore characters.  Any invalid characters  are internally
            converted to underscores.

            The wrapper function takes in a single argument which must be a
            reference to an existing node parameter tuple.  For symmetry, the
            function also returns the parameter tuple reference.

        Here is an example of saving the output to a file and then loading  it
        back into Houdini:
          # Get a reference to the target parameter tuple.
          pt = hou.parmTuple("/obj/geo1/t")

          # Execute asCode and write the output script to file.
          script = pt.asCode()
          f = open("set_parm_tuple_properties.py", "w")
          f.write(script)
          f.close()

          # Execute the script.  This will set the values, flag values
          # and other properties on /obj/geo1's t parameter tuple.  It will
          # also store a reference to the t parameter tuple into a variable
          # named 'hou_parm_tuple'.
          execfile("set_parm_tuple_properties.py")


        Here is an example of saving the output into a function and then
        calling it in Houdini:
          # Get a reference to the target parameter tuple.
          node = hou.parmTuple("/obj/geo1/t")

          # Execute asCode and write the function definition to file.
          func = p.asCode(function_name="setParmTupleProperties")
          f = open("parmtuplelib.py", "w")
          f.write(func)
          f.close()

          # Call the function definition to set the properties on another
          # parameter tuple.
          import parmtuplelib
          hou_parm_tuple = parmtuplelib.setParmTupleProperties(node.parm("t"))
        """
        return ''

    def createClip(self, parent_node, name, create_new, apply_immediately,
        current_value_only):
        """
        createClip(self, parent_node, name, create_new, apply_immediately,
        current_value_only) -> hou.ChopNode

        Creates a Channel CHOP representing this parameter. The Channel CHOP is
        created with the given name as a child of the given parent node. The
        parent_node is typically created via
        hou.Node.findOrCreateMotionEffectsNetwork.

        create_new
            Always create a new Channel CHOP. If set to False, then if a Channel
            CHOP already exists with the same name, it will be re-used. If the
            parameter already exists on the Channel CHOP, the older parameter
            will be removed first.

        apply_immediately
            If set to True, then the export flag on the Channel CHOP will be
            set.

        current_value_only
            If set to True, then only the current value of the parameter will be
            stored.

        See also hou.Node.findOrCreateMotionEffectsNetwork.
        """
        return ChopNode()

    def overrideTrack(self):
        """
        overrideTrack(self) -> hou.Track or None

        Returns the CHOP track overriding this parameter, if any.
        """
        return Track()

    def copyToParmClipboard(self):
        """
        copyToParmClipboard(self)

        Copies this to the parameter clipboard. See also
        hou.parmClipboardContents.
        """

    def isDisabled(self): return True
    def disable(self): return
    def isHidden(self): return True
    def hide(self): return
    def eval(self):
        """
        eval(self) -> int, float, or str

        Evaluates this parameter at the current frame and returns the result.
        See also the evalAtFrame and evalAtTime methods.
        """
        return

    def evalAtFrame(self, frame):
        """
        evalAtFrame(self, frame) -> int, float, or str

        Evalute this parameter at a given frame and return the result as an
        integer, float or string.

        See also evalAtTime.
        """
        return

    def evalAtTime(self, time):
        """
        evalAtTime(self, time) -> int, float, or str

        Evalute this parameter at a given time and return the result as an
        integer, float or string.

        See also evalAtFrame.
        """
        return

    def setKeyframes(self, keyframes):
        """
    Sets multiple keyframe on this parameter. Calling this method is more efficient than calling hou.Parm.setKeyframe()
    several times because it sends out only one update event to Houdini for the entire batch of keyframes that are set.
    keyframes must be a tuple or list of hou.BaseKeyframe objects.
    Raises /hom/hou/PermissionError if this parameter is not writable.
    """

class ParmTuple(object):
    """
    hou.ParmTuple

    A tuple of one or more node parameters.  Each parameter tuple has a
    unique name within its node.

    The ParmTuple class behaves like a Python sequence, so you can index
    into it using square brackets, iterate over it, call len on it, etc.
    The elements inside the parameter tuple are hou.Parm objects.

    A parameter tuple's name may only contain letters, numbers, and
    underscores. For example, objects contain a parameter tuple named "t"
    that contains three integer parameters.  The names of the parameters
    inside the tuple are determined from the parameter tuple's name and its
    naming scheme.  For example, the "t" parameter uses the XYZW naming
    scheme, so the three parameters inside it are named "tx", "ty", and
    "tz".  Note that if the parameter tuple only contains one parameter,
    the tuple and the parameter inside it may have the same name.

    In addition to a name, a parameter tuple also has a label that is
    displayed to the user in the parameter dialog.  For example, the "t"
    parameter's label is "Translate".  The label may contain spaces and
    punctuation characters.

    Each parameter in a tuple stores a value.  Different instances of parm
    tuples in different nodes will store their own set of parameter values.
    The value in a parameter may be animated, in which case the parameter
    evaluates to a different result depending on the current time on the
    playbar.  See hou.Keyframe for more information about animated
    parameters.

    Each hou.NodeType has a set of parameter tuple descriptions associated
    with it, and each instance of a hou.Node has a corresponding set of
    parameter tuple instances.  The parameter tuples store specific values
    that are saved with the node.  The descriptions of the parameter tuples,
    however, are represented by a hou.ParmTemplate.  A parameter template
    describes the type, default values, ranges, etc. of a parameter tuple.

    See also hou.parmTuple_ and hou.Node.parmTuple.


    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def node(self):
        """
        node(self) -> hou.Node

        Return the node containing this parameter tuple.
        """
        return Node()

    def parmTemplate(self):
        """
        parmTemplate(self) -> hou.ParmTemplate

        Return this parameter tuple's template.

        Note that a folder parameter will have a hou.FolderSetParmTemplate
        template and a multiparm parameter will have a hou.FolderParmTemplate
        template.
        """
        return ParmTemplate()

    def name(self):
        """
        name(self) -> str

        Return the name of this parameter tuple.  Note that the parameter
        tuple's name and its naming scheme determine the names of the parameters
        inside it.

          >>> node = hou.node("/obj").createNode("geo")
          >>> node.parmTuple("t").parmTemplate().namingScheme()
          parmNamingScheme.XYZW
          >>> [parm.name() for parm in node.parmTuple("t")]
          ['tx', 'ty', 'tz']

          >>> parm_tuple = node.parent().createNode("cam").parmTuple("dcolor")
          >>> parm_tuple.parmTemplate().namingScheme()
          parmNamingScheme.RGBA
          >>> [parm.name() for parm in parm_tuple]
          ['dcolorr', 'dcolorg', 'dcolorb']

        REPLACES
            opparm command        """
        return ''

    def description(self):
        """
        description(self) -> str

        Return this parameter tuple's label that is displayed in the parameter
        dialog.

        REPLACES
            opparm command        """
        return ''

    def set(self, values):
        """
        set(self, values)

        Sets the value of a parameter in the tuple at the current frame.

        values
            A sequence of floats or strings, corresponding to the components of
            this parameter tuple.

        For example, the parameter tuple for "translation" contains Parm
        objects for translation along each of the axes, "tx", "ty" and
        "tz". If set is called with following tuple of floats, (2.5, 4.0,
        5.5), then the parameter "tx" with be set to 2.5, "ty" will be set
        to 4.0 and "tz" will be set to 5.5.

        If this parm tuple currently contains a channel reference to another
        parameter, this method will follow channel references and change the
        value of the referenced parameter.  If this is not the desired behavior,
        first delete the channel reference with deleteAllKeyframes.

        Raises hou.InvalidSize if values has a different length than this
        parameter tuple. Raises hou.PermissionError if any of the parameters in
        this parameter tuple are not writable.

        REPLACES
            opparm command        """

    def setPending(self, values):
        """
        setPending(self, values)

        Sets the value of a parameter in the tuple at the current frame and
        marks it as pending if the parameter is keyed.

        values
            A sequence of floats or strings, corresponding to the components of
            this parameter tuple.

        For example, the parameter tuple for "translation" contains Parm
        objects for translation along each of the axes, "tx", "ty" and
        "tz". If set is called with following tuple of floats, (2.5, 4.0,
        5.5), then the parameter "tx" with be set to 2.5, "ty" will be set
        to 4.0 and "tz" will be set to 5.5.

        Raises hou.InvalidSize if values has a different length than this
        parameter tuple. Raises hou.PermissionError if any of the parameters in
        this parameter tuple are not writable.

        REPLACES
            opparm command        """

    def revertToDefaults(self):
        """
        revertToDefaults(self)

        Changes the value back to the default(s). See also the
        revertToAndRestoreFactoryDefaults() method.
        """

    def revertToAndRestorePermanentDefaults(self):
        """
        revertToAndRestorePermanentDefaults(self)

        Changes the value back to the defaults that ship with Houdini, and
        restore those defaults.

        See also the revertToDefaults() method.
        """

    def isAtDefault(self, compare_temporary_defaults=True,
        compare_expressions=False):
        """
        isAtDefault(self, compare_temporary_defaults=True,
        compare_expressions=False) -> bool

        Returns whether the parameter tuple is currently at its defaults.

        compare_temporary_defaults
            When <compare_temporary_defaults> is True, isDefault also checks
            against any temporary defaults a user may have set.  The value of
            <compare_temporary_defaults> must be either True or False.

        compare_expressions
            When <compare_Expressions> is True, isDefault compares the actual
            expression when a parameter has a default factory expression. The
            value of <compare_expressions> must be either True or False.

        See also the revertToDefaults() and
        revertToAndRestorePermanentDefaults()methods.
        """
        return True

    def evalAsFloats(self):
        """
        evalAsFloats(self) -> tuple of float

        Evaluates this parameter tuple at the current frame and returns the
        result as a tuple of floats.

        Raises hou.TypeError if a value cannot be converted to a float.
        """
        return (0.0,)

    def evalAsFloatsAtFrame(self, frame):
        """
        evalAsFloatsAtFrame(self, frame) -> tuple of float

        Evaluates this parameter tuple at a certain frame and returns the result
        as a tuple of floats.

        Raises hou.TypeError if a value cannot be converted to a float.
        """
        return (0.0,)

    def evalAsInts(self):
        """
        evalAsInts(self) -> tuple of int

        Evaluates this parameter tuple at the current frame and returns the
        result as a tuple of integers.

        Raises hou.TypeError if a value cannot be converted to an integer.
        """
        return (0,)

    def evalAsIntsAtFrame(self, frame):
        """
        evalAsIntsAtFrame(self, frame) -> tuple of int

        Evaluates this parameter tuple at a certain frame and returns the result
        as a tuple of integers.

        Raises hou.TypeError if a value cannot be converted to an integer.
        """
        return (0,)

    def evalAsStrings(self):
        """
        evalAsStrings(self) -> tuple of str

        Evaluates this parameter tuple at the current frame and returns the
        result as a tuple of strings.

        Raises hou.TypeError if a value cannot be converted to a string.
        """
        return ('',)

    def evalAsStringsAtFrame(self, frame):
        """
        evalAsStringsAtFrame(self, frame) -> tuple of str

        Evaluates the parameter tuple at a frame and returns the result as a
        tuple of strings.

        Raises hou.TypeError if a value cannot be converted to a string.
        """
        return ('',)

    def evalAsRamps(self):
        """
        evalAsRamps(self) -> hou.Ramp

        Evaluates this parameter tuple at the current frame and returns the
        result as a tuple containing a hou.Ramp object.

        Raises hou.TypeError if this is not a ramp parameter.
        """
        return Ramp()

    def evalAsRampsAtFrame(self, frame):
        """
        evalAsRampsAtFrame(self, frame) -> hou.Ramp

        Evaluates this parameter tuple at a certain frame and returns the result
        as a tuple containing a hou.Ramp object.

        Raises hou.TypeError if this is not a ramp parameter.
        """
        return Ramp()

    def lock(self, bool_values):
        """
        lock(self, bool_values)

        Lock or unlock all the parameters in this tuple.  Houdini displays
        locked parameters as disabled and does not let you change their values.

        bool_values
            A sequence of True or False values, where each value corresponds to
            a component of this parameter. Where an element of bool_values is
            True, that component will be locked (uneditable), and where an
            element is False, the corresponding component will be unlocked
            (editable).

        For example, the parameter tuple for "translation" contains Parm
        objects for translation along each of the axes, "tx", "ty" and
        "tz". If lock is called with the following tuple of boolean values,
        (True, True, False), then the parameter "tx" and "ty" will be locked
        and made non-editable, while "tz" will be unlocked and made editable.

        Raises hou.InvalidSize if bool_values has a different length than this
        parameter tuple. Raises hou.PermissionError if any of the parameters in
        this parameter tuple are not writable.

        REPLACES
            chlock command        """

    def setAutoscope(self, bool_values):
        """
        setAutoscope(self, bool_values)

        Changes the autoscope property of components of this parameter tuple.

        bool_values
            A sequence of True or False values, where each value corresponds to
            a component of this parameter. Where an element of bool_values is
            True, that component will be autoscope.

        For example, the parameter tuple for "translation" contains Parm
        objects for translation along each of the axes, "tx", "ty" and
        "tz". If setAutoscope is called with the following tuple of boolean
        values, (True, True, False), then the parameter "tx" and "ty" will
        be automatically scoped, while "tz" will not.

        Raises hou.InvalidSize if values has a different length than this
        parameter tuple. Raises hou.PermissionError if any of the parameters in
        this parameter tuple are not writable.

        REPLACES
            chautoscope command        """

    def isSpare(self):
        """
        isSpare(self) -> bool

        Returns whether the parameter is a "spare" (user-defined) parameter.
        """
        return True

    def isMultiParmInstance(self):
        """
        isMultiParmInstance(self) -> bool

        Return whether this parameter is an instance of a multi parm.  For
        example, the pt0, pt1, pt2, etc. parameter tuples in an add SOP are
        instances of a multiparm.
        """
        return True

    def deleteAllKeyframes(self):
        """
        deleteAllKeyframes(self)

        Remove all the keyframes from this parameter tuple.

        This method be approximately implemented as follows:
          def deleteAllKeyframes(self):
              for parm in self:
                  parm.deleteAllKeyframes()


        See also hou.Parm.deleteAllKeyframes.
        """

    def __getitem__(self):
        """
        __getitem__(self, index) -> hou.Parm

        Return the Parm object for the specified component of this parameter
        tuple. Negative indices will index from the end.

        This method makes instances of this class appear like a tuple, and lets
        you iterate over the parms in a ParmTuple.

        Raises IndexError if the index is not valid.

          >>> parm_tuple = hou.node("/obj").createNode("geo").parmTuple("t")
          >>> for parm in parm_tuple:
          ...     print parm.name(),
          tx ty tz
          >>> tuple(parm_tuple)
          (<hou.Parm tx in /obj/geo1>, <hou.Parm ty in /obj/geo1>, <hou.Parm tz in /obj/geo1>)
        """
        return Parm()

    def __len__(self):
        """
        __len__(self) -> int

        Return the number of hou.Parms in this parameter tuple.
        """
        return 0

    def createClip(self, parent_node, name, create_new, apply_immediately,
        current_value_only):
        """
        createClip(self, parent_node, name, create_new, apply_immediately,
        current_value_only) -> hou.ChopNode

        Creates a Channel CHOP representing this parameter. The Channel CHOP is
        created with the given name as a child of the given parent node.  The
        parent_node is typically created via
        hou.Node.findOrCreateMotionEffectsNetwork.

        create_new
            Always create a new Channel CHOP. If set to False, then if a Channel
            CHOP already exists with the same name, it will be re-used. If the
            parameter already exists on the Channel CHOP, the older parameter
            will be removed first.

        apply_immediately
            If set to True, then the export flag on the Channel CHOP will be
            set.

        current_value_only
            If set to True, then only the current value of the parameter will be
            stored.

        See also hou.Node.findOrCreateMotionEffectsNetwork.
        """
        return ChopNode()

    def copyToParmClipboard(self):
        """
        copyToParmClipboard(self)

        Copies this to the parameter clipboard. See also
        hou.parmClipboardContents.
        """

    def _asVoidPointer(self): return
    def asCode(self, brief=False, save_values=True, save_keyframes=True, save_keys_in_frames=False, save_flag_values=True, save_aliases=True, function_name=None):
        """
brief

Returns a script of Python statements that can be executed to set the parameter tuples values, flags and other properties.
To run the script, use either Pythons exec or execfile functions.


save_values
When brief is True, the output script omits commands for setting values and flags that are set to the factory defaults.
The script also omits keyframe commands that set unused values, slopes and accelerations. The value of brief must be either True or False.


save_keyframes
When save_values is True, asCode outputs commands for setting the parameter tuples values. The value of save_values
 must be either True or False.


save_keys_in_frames
When save_keyframes is True, asCode outputs commands for creating the parameter tuples keyframes
(if any). The value of save_keyframes must be either True or False.


save_flag_values
When save_keys_in_frames is True, asCode outputs commands for setting channel and key times in samples (frames) instead
of seconds. This parameter has no effect if save_keyframes is set to False. The value of save_keys_in_frames must be either True or False.


save_aliases
When save_flag_values is True, asCode outputs commands for setting the parameter tuples flag values.
The value of save_flag_values must be either True or False.


function_name
When save_aliases is True, asCode outputs commands for setting the parameter tuples channel aliases. The value of
save_aliases must be either True or False.


If function_name is specified, then the output script is wrapped in a Python function definition with the given name.
function_name must be a non-zero length string consisting of only alphanumeric and underscore characters. Any invalid
characters are internally converted to underscores.


The wrapper function takes in a single argument which must be a reference to an existing node parameter tuple.
For symmetry, the function also returns the parameter tuple reference.
        """
        return
    def help(self): return
    def helpUrl(self): return
    def isDisabled(self):
        """
        isDisabled(self) -> bool

        Returns the disable state of the parameter tuple, ignoring the lock
        state. This can be used to read the result of a disable-when
        conditional.
        """
        return True

    def disable(self, on):
        """
        disable(self, on)

        Sets the UI disable state of this parameter tuple in its node.  This is
        not the same as locking a parameter, as the underlying value  can still
        be modified. It's closer to what a disable-when conditional  does, when
        a parameter is disabled automatically by it.
        """

    def isHidden(self):
        """
        isHidden(self) -> bool

        Returns the hidden state of the parameter tuple. This can be used to
        read the result of a hide-when conditional.
        """
        return True

    def hide(self, on):
        """
        hide(self, on)

        Sets the UI hidden state of this parameter tuple in its node. Calling
        this method is equivalent to changing the Invisible checkbox  on the
        Edit Parameter Interface dialog, or hiding the parameter with  a hide-
        when conditional.

        To hide a folder, use hou.Node.setParmTemplateGroup.  This method cannot
        be used to hide a folder because a parm tuple corresponds to a set of
        folders, not an individual folder.

        To change the visibility of all new instances of the node type defined
        by a digital asset, use hou.HDADefinition.setParmTemplateGroup as in the
        following example:

          def showParmTupleInDefinition(parm_tuple, visible):
              '''parm_tuple is a hou.ParmTuple on an instance of the digital asset.'''
              definition = parm_tuple.node().type().definition()
              parm_template_group = definition.parmTemplateGroup()
              parm_template = parm_template_group.find(parm_tuple.name())
              parm_template.hide(not visible)
              parm_template_group.replace(parm_tuple.name(), parm_template)
              definition.setParmTemplateGroup(parm_template_group)
        """

    def eval(self):
        """
        eval(self) -> tuple of int, float, str, or hou.Ramp

        Evalute this parameter tuple at the current frame and returns the result
        as a tuple of integers, floats or strings, or a hou.Ramp object,
        depending on the type of the parameter.

        See also the evalAtFrame and evalAtTime methods.

        REPLACES
            chramp function
            ch function
            chs function        """
        return

    def evalAtFrame(self):
        """
        evalAtFrame(self, frame) -> tuple of int, float, str, or hou.Ramp

        Evalute the parameter tuple at a given frame and return the result as a
        tuple of integers, floats, strings, or a Ramp object, depending on the
        type of the parameter.

        See also evalAtTime.
        """
        return

    def evalAtTime(self):
        """
        evalAtTime(self, time) -> tuple of int, float, str, or hou.Ramp

        Evalute the parameter tuple at a given time and return the result as a
        tuple of integers, floats, strings, or a Ramp object, depending on the
        type of the parameter.

        See also evalAtFrame.
        """
        return

class perfMon(object):
    """
    hou.perfMon

    Module containing performance monitor related functions.

    RELATED
      * hou.PerfMonProfile
      * hou.PerfMonEvent
      * hou.PerfMonRecordOptions
      * Performance monitor pane


    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def startProfile(title, options=None):
        """
        startProfile(title, options=None) -> hou.PerfMonProfile

        Create a new profile and start it so that it can record events.  When
        the profile is stopped, it will generate statistics for the events that
        it recorded.

        options
            A hou.PerfMonRecordOptions object that specifies the types of
            Houdini events and statistics to record.  If None is passed in or if
            the options argument is not specified, then the profile will record
            all events and statistics.
        """
        return PerfMonProfile()

    def loadProfile(file_path):
        """
        loadProfile(file_path) -> hou.PerfMonProfile

        Load a profile from disk and return the loaded profile.

        Raises hou.OperationFailed if file_path points to a file that does not
        exist or is not a valid Houdini performance monitor profile file.
        """
        return PerfMonProfile()

    def startTimedEvent(description, auto_nest_events=True):
        """
        startTimedEvent(description, auto_nest_events=True) -> hou.PerfMonEvent

        This method is deprecated in favor of startEvent.
        """
        return PerfMonEvent()

    def startEvent(description, auto_nest_events=True):
        """
        startEvent(description, auto_nest_events=True) -> hou.PerfMonEvent

        Create a generic event and start it.  When the event is stopped, it will
        be logged by the performance monitor and added to any profiles that are
        recording script or memory statistics.

        Use this function to time and measure memory growth in generic scripts,
        functions or code blocks.

        Return the new event.

        description
            The description of the event that you are starting.  For example,
            this can be a function name or a script name or a description of a
            code block.

        auto_nest_events
            If set to True, the event will automatically 'nest' other events
            that are started and stopped while this event is running.  When the
            event is stopped, it will decrement the times and memory of its
            nested events from its total time and memory.  That way, the event's
            total time and memory will reflect the work performed in the event
            itself and not in any of its nested events.

        Raises hou.OperationFailed if description is an empty string.
        """
        return PerfMonEvent()

    def startTimedCookEvent(description, node):
        """
        startTimedCookEvent(description, node) -> hou.PerfMonEvent

        This method is deprecated in favor of startCookEvent.
        """
        return PerfMonEvent()

    def startCookEvent(description, node):
        """
        startCookEvent(description, node) -> hou.PerfMonEvent

        Create an event that is related to node cooking and start it.  When the
        event is stopped, it will be logged by the performance monitor and added
        to any profiles that are recording cook or memory statistics.

        Use this function to time code blocks and measure memory growth in the
        Code section of Python operators.

        Return the cook event.

        description
            The description of the event that you are timing.  For example, this
            can be a function name or a description of a code block.

        node
            The node that the timed event applies to.  This must be a hou.Node
            object.  When calling startCookEvent() from within the Code section
            of a Python operator, set node to the current node (i.e. hou.pwd()).

        Raises hou.OperationFailed if description is an empty string or if node
        does not exist.
        """
        return PerfMonEvent()

    def isRecording(self):
        """
        isRecording() -> bool

        Return True if the performance monitor is recording Houdini events.
        """
        return True

class PerfMonEvent(object):
    """
    hou.PerfMonEvent

    Represents an event that is recorded by the performance monitor and used
    to generate time and memory growth statistics for profiles.

    Note that all methods in this class may raise an hou.OperationFailed
    exception if the event was not actually recorded in the Performance
    Monitor.  This can happen if hou.perfMon.startEvent or
    hou.perfMon.startCookEvent was called when the Performance Monitor was
    not recording.


    The stopTime(), memory() and time() methods have been removed.  Memory
    and time values are now returned by the stop() method.

    RELATED
      * hou.perfMon
      * hou.PerfMonProfile
      * hou.PerfMonRecordOptions
      * Performance monitor pane


    """
    def __init__(self): raise AttributeError, "No constructor defined"
    def id(self):
        """
        id(self) -> int

        Return the event's unique identifier which is used internally by the
        performance monitor.

        This method is deprecated.
        """
        return 0

    def name(self):
        """
        name(self) -> str

        Return the event name.

        This method is deprecated.
        """
        return ''

    def object(self):
        """
        object(self) -> str

        Return the object that the event applies to.  Return None if the event
        is not associated with an object.
        """
        return ''

    def isAutoNestEnabled(self):
        """
        isAutoNestEnabled(self) -> bool

        Return True if the event will automatically 'nest' other events that are
        started and stopped while this event is running.  When the event is
        stopped, it will decrement the times and memory of its nested events
        from its total time and memory.  That way, the event's total time and
        memory will reflect the work performed in the event itself and not in
        any of its nested events.
        """
        return True

    def stop(self):
        """
        stop(self)

        Stop the event timer and return a 2-tuple, (<time>, <memory>),
        containing the event's elapsed time and memory growth.

        The elapsed time is the number of milliseconds that the event was timing
        for.  The memory growth is the increase in memory usage by Houdini (in
        bytes) from when the event started and when it stopped.

        If the event was not recording memory, then the returned memory value is
        0.0.  Likewise, if the event was not recording time, then the returned
        time value is 0.0.

        Raises hou.OperationFailed if the event is already stopped.
        """

    def isTiming(self):
        """
        isTiming(self) -> bool

        This method is deprecated in favor of isRunning.
        """
        return True

    def isRunning(self):
        """
        isRunning(self) -> bool

        Return true if the event is running, that is, if the event has been
        started but not stopped.
        """
        return True

    def startTime(self):
        """
        startTime(self) -> float

        Return the start time of the event in milliseconds since the epoch date.

        Raises hou.OperationFailed if the event does not contain any time data.
        This can happen if the event was started when the Performance Monitor
        was not recording any time statistics.
        """
        return 0.0

    def __enter__(self): return
    def __exit__(self): return

class PerfMonProfile(object):
    """
    hou.PerfMonProfile

    Represents a performance monitor profile.

    RELATED
      * hou.perfMon
      * hou.PerfMonEvent
      * hou.PerfMonRecordOptions
      * Performance monitor pane
    """
    def __init__(self): raise AttributeError, "No constructor defined"
    def id(self):
        """
        id(self) -> int

        Return the profile's unique identifier which is used internally by the
        performance monitor.
        """
        return 0

    def title(self):
        """
        title(self) -> str

        Return the profile title.
        """
        return ''

    def isActive(self):
        """
        isActive(self) -> bool

        Return True if the profile is either recording events or is paused.
        """
        return True

    def isPaused(self):
        """
        isPaused(self) -> bool

        Return True if the profile is paused from recording.
        """
        return True

    def isRecordingCookStats(self):
        """
        isRecordingCookStats(self) -> bool

        Return True if the profile is recording cook events and statistics.
        """
        return True

    def isRecordingSolveStats(self):
        """
        isRecordingSolveStats(self) -> bool

        Return True if the profile is recording simulation solver events and
        statistics.
        """
        return True

    def isRecordingDrawStats(self):
        """
        isRecordingDrawStats(self) -> bool

        Return True if the profile is recording draw events and statistics.
        """
        return True

    def isRecordingGPUDrawStats(self):
        """
        isRecordingGPUDrawStats(self) -> bool

        Return True if the profile is recording GPU draw events and statistics.
        """
        return True

    def isRecordingViewportStats(self):
        """
        isRecordingViewportStats(self) -> bool

        Return True if the profile is recording viewport events and statistics.
        """
        return True

    def isRecordingScriptStats(self):
        """
        isRecordingScriptStats(self) -> bool

        Return True if the profile is recording script events and statistics.
        """
        return True

    def isRecordingRenderStats(self):
        """
        isRecordingRenderStats(self) -> bool

        Return True if the profile is recording statistics related to rendering.
        """
        return True

    def isRecordingThreadStats(self):
        """
        isRecordingThreadStats(self) -> bool

        Return True if the profile is recording thread statistics.
        """
        return True

    def isRecordingFrameStats(self):
        """
        isRecordingFrameStats(self) -> bool

        Return True if the profile is recording frame events and statistics.
        """
        return True

    def isRecordingMemoryStats(self): return True
    def isRecordingErrors(self):
        """
        isRecordingErrors(self) -> bool

        Return True if the profile is recording errors.
        """
        return True

    def stop(self):
        """
        stop(self)

        Stop the profile from recording and generate statistics for the events
        that it has already recorded.

        Raises hou.OperatioNFailed if the profile is not active.
        """

    def cancel(self):
        """
        cancel(self)

        Stop the profile from recording timed events and remove it from the
        performance monitor.

        Raises hou.OperationFailed if the profile is not active, that is, the
        profile is neither recording nor paused.
        """

    def pause(self):
        """
        pause(self)

        Pause the profile from recording events and statistics.

        Raises hou.OperationFailed if the profile is stopped or already paused.
        """

    def resume(self):
        """
        resume(self)

        Unpause the profile so that it can record events and statistics.

        Raises hou.OperationFailed if the profile is stopped or is already
        recording (i.e. not paused).
        """

    def save(self, file_path):
        """
        save(self, file_path)

        Save the profile to disk.

        Raises hou.OperationFailed if the profile is still active or if the file
        could not be written to disk (i.e. permission problems).
        """

    def exportAsCSV(self, file_path):
        """
        exportAsCSV(self, file_path)

        Export the profile statistics to disk using a comma-separated (CSV)
        format.  The exported .csv file can be loaded into a spreadsheet
        application such as Microsoft Excel and used to generate graphs.

        Raises hou.OperationFailed if the profile is still active or if the .csv
        file could not be written to disk (i.e. permission problems).
        """

    def _stats(self): return

class PerfMonRecordOptions(object):
    """
    hou.PerfMonRecordOptions

    Represents the set of options used by the Performance Monitor and
    specifies the type of statistics to be recorded in a profile.

    RELATED
      * hou.perfMon
      * hou.PerfMonProfile
      * Performance monitor pane


    """

    def __init__(self, *args, **kwargs):
        """
        hou.PerfMonRecordOptions

        Represents the set of options used by the Performance Monitor and
        specifies the type of statistics to be recorded in a profile.

        RELATED
          * hou.perfMon
          * hou.PerfMonProfile
          * Performance monitor pane
        """
    def recordCookStats(self):
        """
        recordCookStats(self) -> bool

        Return True if cook statistics should be recorded.
        """
        return True

    def recordSolveStats(self):
        """
        recordSolveStats(self) -> bool

        Return True if DOP solver statistics should be recorded.
        """
        return True

    def recordDrawStats(self):
        """
        recordDrawStats(self) -> bool

        Return True if node draw statistics should be recorded.
        """
        return True

    def recordGPUDrawStats(self):
        """
        recordGPUDrawStats(self) -> bool

        Return True if node GPU draw statistics should be recorded.
        """
        return True

    def recordViewportStats(self):
        """
        recordViewportStats(self) -> bool

        Return True if viewport statistics should be recorded.
        """
        return True

    def recordScriptStats(self):
        """
        recordScriptStats(self) -> bool

        Return True if hscript and Python script statistics should be recorded.
        """
        return True

    def recordRenderStats(self):
        """
        recordRenderStats(self) -> bool

        Return True if Mantra render statistics should be recorded.
        """
        return True

    def recordThreadStats(self):
        """
        recordThreadStats(self) -> bool

        Return True if thread statistics should be recorded.
        """
        return True

    def recordFrameStats(self):
        """
        recordFrameStats(self) -> bool

        Return True if frame statistics should be recorded.
        """
        return True

    def recordMemoryStats(self):
        """
        recordMemoryStats(self) -> bool

        Return True if memory statistics should be recorded.
        """
        return True

    def recordErrors(self):
        """
        recordErrors(self) -> bool

        Return True if warnings and errors should be recorded.
        """
        return True

    def setRecordCookStats(self, record):
        """
        setRecordCookStats(self, record)

        Turn the recording of cook statistics on or off.
        """

    def setRecordSolveStats(self, record):
        """
        setRecordSolveStats(self, record)

        Turn the recording of DOP solver statistics on or off.
        """

    def setRecordDrawStats(self, record):
        """
        setRecordDrawStats(self, record)

        Turn the recording of node draw statistics on or off.
        """

    def setRecordGPUDrawStats(self, record):
        """
        setRecordGPUDrawStats(self, record)

        Turn the recording of node GPU draw statistics on or off.
        """

    def setRecordViewportStats(self, record):
        """
        setRecordViewportStats(self, record)

        Turn the recording of viewport statistics on or off.
        """

    def setRecordScriptStats(self, record):
        """
        setRecordScriptStats(self, record)

        Turn the recording of hscript and Python statistics on or off.
        """

    def setRecordRenderStats(self, record):
        """
        setRecordRenderStats(self, record)

        Turn the recording of Mantra render statistics on or off.
        """

    def setRecordThreadStats(self, record):
        """
        setRecordThreadStats(self, record)

        Turn the recording of thread statistics on or off.
        """

    def setRecordFrameStats(self, record):
        """
        setRecordFrameStats(self, record)

        Turn the recording of frame statistics on or off.
        """

    def setRecordMemoryStats(self, record):
        """
        setRecordMemoryStats(self, record)

        Turn the recording of memory statistics on or off.
        """

    def setRecordErrors(self, record):
        """
        setRecordErrors(self, record)

        Turn the recording of warnings and errors on or off.
        """

class PerformanceMonitor(PaneTab):
    """
    hou.PerformanceMonitor

    Represents a Performance Monitor panetab.

    REPLACES
      * performance


    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def isLiveUpdatesEnabled(self):
        """
        isLiveUpdatesEnabled(self) -> bool

        Return whether live updates is enabled.

        REPLACES
            performance command        """
        return True

    def enableLiveUpdates(self, on):
        """
        enableLiveUpdates(self, on)

        Enable or disable live updates for recordings.  If live updates is
        enabled, then statistics are displayed in the statistics viewer and are
        periodically updated while the performance monitor is recording.

        REPLACES
            performance command        """

    def isRecording(self):
        """
        isRecording(self) -> bool

        Return whether the performance monitor is recording.

        REPLACES
            performance command        """
        return True

    def startRecording(self):
        """
        startRecording(self)

        Start recording in the performance monitor.

        Raises hou.OperationFailed if the performance monitor is already
        recording.

        REPLACES
            performance command        """

    def stopRecording(self):
        """
        stopRecording(self)

        Stop recording in the performance monitor.

        Raises hou.OperationFailed if the performance monitor is already
        stopped.

        REPLACES
            performance command        """

    def isSamplingCookStats(self):
        """
        isSamplingCookStats(self) -> bool

        Return whether the sampling of cook statistics is turned on.

        REPLACES
            performance command        """
        return True

    def isSamplingErrors(self):
        """
        isSamplingErrors(self) -> bool

        Return whether the sampling of warnings and errors is turned on.

        REPLACES
            performance command        """
        return True

    def isSamplingFrameStats(self):
        """
        isSamplingFrameStats(self) -> bool

        Return whether the sampling of frame statistics is turned on.

        REPLACES
            performance command        """
        return True

    def isSamplingMemoryStats(self): return True
    def isSamplingObjectDrawStats(self):
        """
        isSamplingObjectDrawStats(self) -> bool

        Return whether the sampling of object drawing statistics is turned on.

        REPLACES
            performance command        """
        return True

    def isSamplingObjectGPUDrawStats(self):
        """
        isSamplingObjectGPUDrawStats(self) -> bool

        Return whether the sampling of object GPU drawing statistics is turned
        on.

        REPLACES
            performance command        """
        return True

    def isSamplingScriptStats(self):
        """
        isSamplingScriptStats(self) -> bool

        Return whether the sampling of script statistics is turned on.

        REPLACES
            performance command        """
        return True

    def isSamplingSolveStats(self):
        """
        isSamplingSolveStats(self) -> bool

        Return whether the sampling of DOP solve statistics is turned on.

        REPLACES
            performance command        """
        return True

    def isSamplingThreadStats(self):
        """
        isSamplingThreadStats(self) -> bool

        Return whether the sampling of thread statistics is turned on.

        REPLACES
            performance command        """
        return True

    def isSamplingViewportStats(self):
        """
        isSamplingViewportStats(self) -> bool

        Return whether the sampling of viewport statistics is turned on.

        REPLACES
            performance command        """
        return True

    def sampleCookStats(self, on):
        """
        sampleCookStats(self, on)

        Turn sampling of cook statistics on or off.

        REPLACES
            performance command        """

    def sampleErrors(self, on):
        """
        sampleErrors(self, on)

        Turn sampling of warnings and errors on or off.

        REPLACES
            performance command        """

    def sampleFrameStats(self, on):
        """
        sampleFrameStats(self, on)

        Turn sampling of frame statistics on or off.

        REPLACES
            performance command        """

    def sampleMemoryStats(self): return
    def sampleObjectDrawStats(self, on):
        """
        sampleObjectDrawStats(self, on)

        Turn sampling of object drawing statistics on or off.

        REPLACES
            performance command        """

    def sampleObjectGPUDrawStats(self, on):
        """
        sampleObjectGPUDrawStats(self, on)

        Turn sampling of object GPU drawing statistics on or off.

        REPLACES
            performance command        """

    def sampleScriptStats(self, on):
        """
        sampleScriptStats(self, on)

        Turn sampling of script statistics on or off.

        REPLACES
            performance command        """

    def sampleSolveStats(self, on):
        """
        sampleSolveStats(self, on)

        Turn sampling of DOP solve statistics on or off.

        REPLACES
            performance command        """

    def sampleThreadStats(self, on):
        """
        sampleThreadStats(self, on)

        Turn sampling of thread statistics on or off.  Note that turning on
        thread sampling can add overhead to the processing times (i.e. cook
        times, solve times, etc.) in the scene.

        REPLACES
            performance command        """

    def sampleViewportStats(self, on):
        """
        sampleViewportStats(self, on)

        Turn sampling of object-drawing statistics on or off.

        REPLACES
            performance command        """

    def objectView(self):
        """
        objectView(self) -> hou.perfMonObjectView enum value

        Return the structure type that is used to view objects in the statistics
        viewer.

        REPLACES
            performance command        """
        return perfMonObjectView()

    def setObjectView(self, view):
        """
        setObjectView(self, view)

        Set the structure type to use when viewing objects in the statistics
        viewer.

        REPLACES
            performance command        """

    def timeFormat(self):
        """
        timeFormat(self) -> hou.perfMonTimeFormat enum value

        Return the format that is used to view times in the statistics viewer.

        REPLACES
            performance command        """
        return perfMonTimeFormat()

    def setTimeFormat(self, format):
        """
        setTimeFormat(self, format)

        Set the format to use when viewing times in the statistics viewer.

        REPLACES
            performance command        """

class playbar(object):
    """
    hou.playbar

    The animation playbar module.

    REPLACES
      * fplayback
      * frange
      * pane
      * play
    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def isPlaying(self):
        """
        isPlaying(self) -> bool

        Return True if the playbar is playing.  Return False otherwise.
        """
        return True

    def play(self):
        """
        play(self)

        Play in the forward direction.

        Raises hou.NotAvailable if the playbar is not available.

        REPLACES
            play command        """

    def stop(self):
        """
        stop(self)

        Stop playing.

        Raises hou.NotAvailable if the playbar is not available.

        REPLACES
            play command        """

    def reverse(self):
        """
        reverse(self)

        Play in the reverse direction.

        Raises hou.NotAvailable if the playbar is not available.

        REPLACES
            play command        """

    def playMode(self):
        """
        playMode(self) -> hou.playMode

        Return the playbar's play mode.

        Raises hou.NotAvailable if the playbar is not available.

        REPLACES
            play command        """
        return playMode()

    def setPlayMode(playMode, mode):
        """
        setPlayMode(self, mode)

        Set the play mode to one of the following:          hou.playMode.Loop -
        Loop to the start of the range when the playback slider reaches the end
        of the range.         hou.playMode.Once - Stop playback when the slider
        reaches the end of the range.         hou.playMode.Zigzag - Play in the
        forward direction until reaching the end of the playback range, then
        play in the reverse direction.

        Raises hou.NotAvailable if the playbar is not available.

        REPLACES
            play command        """

    def frameIncrement(self):
        """
        frameIncrement(self) -> float

        Return the frame increment step size.

        REPLACES
            fplayback command        """
        return 0.0

    def setFrameIncrement(self, increment):
        """
        setFrameIncrement(self, increment)

        Set the frame increment step size.  This value is ignored when playing
        with realtime playback turned on.

        Raises hou.NotAvailable if the playbar is not available.

        REPLACES
            fplayback command        """

    def playbackRange(self):
        """
        playbackRange(self) -> hou.Vector2

        Return a 2-tuple containing the start and end frame of the playback
        range.

        REPLACES
            frange command        """
        return Vector2()

    def setPlaybackRange(self, start, end):
        """
        setPlaybackRange(self, start, end)

        Set the playback range.

        Raises hou.NotAvailable if the playbar is not available.

        REPLACES
            frange command        """

    def isRangeRestricted(self):
        """
        isRangeRestricted(self) -> bool

        Return true if playback is restricted to within the playbar's start
        frame and end frame.

        REPLACES
            fplayback command        """
        return True

    def setRestrictRange(self, on):
        """
        setRestrictRange(self, on)

        Turn restriction on the playback range on or off.  When the restriction
        is turned on, playback will remain with the start and end frames of the
        playback range.

        Raises hou.NotAvailable if the playbar is not available.

        REPLACES
            fplayback command        """

    def usesIntegerFrames(self):
        """
        usesIntegerFrames(self) -> bool

        Return True if playback uses integer frame values.  Return False
        otherwise.

        REPLACES
            fplayback command        """
        return True

    def setUseIntegerFrames(self, on):
        """
        setUseIntegerFrames(self, on)

        Turn integer frame values on or off.

        Raises hou.NotAvailable if the playbar is not available.

        REPLACES
            fplayback command        """

    def isRealTime(self):
        """
        isRealTime(self) -> bool

        Return True if realtime playback is turned on.  Return False otherwise.

        REPLACES
            fplayback command        """
        return True

    def setRealTime(self):
        """
        setRealTime(self, on)

        Turn realtime playback either on or off.

        Raises hou.NotAvailable if the playbar is not available.

        REPLACES
            fplayback command        """

    def realTimeFactor(self):
        """
        realTimeFactor(self) -> float

        Return the multiplier factor used when playing with realtime playback
        turned on.

        REPLACES
            fplayback command        """
        return 0.0

    def setRealTimeFactor(self, factor):
        """
        setRealTimeFactor(self, factor)

        Set the realtime playback multiplier.  A multiplier value of less than 1
        slows down the playback.  A multiplier value of greater than 1 speeds up
        the playback.  A multiplier value equal to 1 maintains realtime
        playback.  The multiplier has no effect if realtime playback is turned
        off.

        Raises hou.NotAvailable if the playbar is not available.

        REPLACES
            fplayback command        """

    def isAudioShown(self):
        """
        isAudioShown(self) -> bool

        Return True if the display of audio in the playbar is turned on.  Return
        False otherwise.

        REPLACES
            fplayback command        """
        return True

    def showAudio(self, on):
        """
        showAudio(self, on)

        Turn display of audio on the playbar on or off.

        Raises hou.NotAvailable if the playbar is not available.

        REPLACES
            fplayback command        """

    def areKeysShown(self):
        """
        areKeysShown(self) -> bool

        Return True if the display of keyframes in the playbar is turned on.
        Return False otherwise.

        REPLACES
            fplayback command        """
        return True

    def showKeys(self, on):
        """
        showKeys(self, on)

        Turn display of keyframes on the playbar on or off.

        Raises hou.NotAvailable if the playbar is not available.

        REPLACES
            fplayback command        """

    def isSimCacheShown(self): return True
    def showSimCache(self): return
    def isRangeSliderShown(self):
        """
        isRangeSliderShown(self) -> bool

        Return True if the display of the range slider in the playbar is turned
        on.  Return False otherwise.

        REPLACES
            fplayback command        """
        return True

    def showRangeSlider(self, on):
        """
        showRangeSlider(self, on)

        Turn display of the range slider on the playbar on or off.

        Raises hou.NotAvailable if the playbar is not available.

        REPLACES
            fplayback command        """

    def areTicksShown(self):
        """
        areTicksShown(self) -> bool

        Return True if the display of frame ticks in the playbar is turned on.
        Return False otherwise.

        REPLACES
            fplayback command        """
        return True

    def showTicks(self, on):
        """
        showTicks(self, on)

        Turn display of the frame ticks on the playbar on or off.

        Raises hou.NotAvailable if the playbar is not available.

        REPLACES
            fplayback command        """

    def moveToBottom(self):
        """
        moveToBottom(self)

        Move the playbar to the bottom of the desktop.

        Raises hou.NotAvailable if the user interface is not available.

        REPLACES
            pane command        """

    def moveToPane(self, pane):
        """
        moveToPane(self, pane)

        Move the playbar to the bottom of the specified pane.

        Raises hou.ObjectWasDeleted if pane does not point to a valid pane.
        Raises hou.NotAvailable if the user interface is not available.

        REPLACES
            pane command        """

    def addEventCallback(self, callback):
        """
        addEventCallback(self, callback)

        Register a Python callback to be called whenever a playbar event occurs
        (i.e. frame change, playback stopped).

        callback
            Any callable Python object that expects two arguments.  The first
            argument is a hou.playbarEvent enum value and the second argument is
            a float storing the frame number of when the event took place.

          def outputPlaybarEvent(event_type, frame):
              print "Playbar event", event_type, "at frame", frame

          hou.playbar.addEventCallback(outputPlaybarEvent)
        """

    def removeEventCallback(self):
        """
        removeEventCallback(callback)

        Remove a Python callback that was previously registered with
        hou.playbar.addEventCallback.  See hou.playbar.addEventCallback for more
        information.

        Raises hou.OperationFailed if the callback was not previously
        registered.
        """

    def clearEventCallbacks(self):
        """
        clearEventCallbacks()

        Remove all Python callbacks that have been registered with
        hou.playbar.addEventCallback.
        """

    def eventCallbacks(self):
        """
        eventCallbacks() -> tuple of callback

        Return a tuple of all the Python callbacks that have been registered
        with hou.playbar.addEventCallback.
        """
        return (object,)

    def selectedKeyframes(self): return
    def selectionRange(self):
        """
        selectionRange(self) -> hou.Vector2 or None

        Return a 2-tuple containing the start and end frame of the selection
        range. If there is no selection, then None is returned.
        """
        return Vector2()

class Point(object):
    """
    hou.Point

    Each Point object resides inside a Geometry object and stores a 3D
    position.  Points may be shared between primitives (such as polygons),
    and the set of points and primitives describes a 3D shape.

    The set of points may also store arbitrary data in the form of
    attributes, and each point instance stores a unique attribute value.


    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def geometry(self):
        """
        geometry(self) -> hou.Geometry

        Return the hou.Geometry object containing this point.
        """
        return Geometry()

    def number(self):
        """
        number(self) -> int

        Return the number of this point.  Points are numbered sequentially
        starting from 0, and the points returned by hou.Geometry.points are in
        order by their number.

        REPLACES
            pointlist function
            poppointnum function        """
        return 0

    def position(self):
        """
        position(self) -> hou.Vector3

        Return the position of this point as a Vector3 containing the (X, Y, Z)
        position values.

        This method is a shortcut for accessing the P attribute of the point.
          point.position()
          # is equivalent to
          hou.Vector3(point.attribValue("P"))


        Because the position is returned as a Vector3, it can be accessed as a
        sequence.  However, you can also easily use hou.Matrix4 to transform the
        position.

        See also:

        * hou.Point.weight
        * hou.Vector3
        * hou.Matrix4        """
        return Vector3()
    def setPosition(self, position):
        """
        setPosition(self, position)

        Changes the point's location.  You would typically call this method from
        the code of a Python-defined SOP.

        position
            Any sequence of floats, such has a hou.Vector3 or a tuple of floats,
            of length either 3 or 4.  The fourth coordinate corresponds to the
            weight, and is usually 1.  The weight is typically used by NURBS
            curves and sequences.  If the sequence is of size 3, the weight will
            be unchanged.

        This method is a shortcut for calling hou.Point.setAttribValue on the P
        attribute.

          point.setPosition((x, y, z))
          # is the same as
          point.setAttribValue("P", (x, y, z))

        Raises hou.GeometryPermissionError if the geometry is not modifiable.
        Raises hou.InvalidSize if the length of position is not 3.

        See also hou.Point.setWeight.
        """

    def weight(self):
        """
        weight(self) -> float

        Return the weight of this point.  Point weights are displayed in
        Houdini's geometry spreadsheet as the fourth component of the position,
        and are used in NURBS curves and surfaces.

        Most of the time, the weight is 1.0.

        This method is a shortcut for accessing the Pw attribute of the point.
          point.weight()
          # is equivalent to
          point.attribValue("Pw")


        You can build a hou.Vector4 containing both the position and weight as
        follows:
          hou.Vector4(tuple(point.position()) + (point.weight(),))


        See also hou.Point.position.
        """
        return 0

    def setWeight(self, weight):
        """
        setWeight(self, weight)

        Change the point's weight.  You would typically call this method from
        the code of a Python-defined SOP.

        This method is a shortcut for calling hou.Point.setAttribValue on the Pw
        attribute.

        See hou.Point.weight for more information about a point's weight. See
        also hou.Point.setPosition.
        """

    def attribType(self):
        """
        attribType(self) -> hou.attribType enum value

        Return the enumerated value hou.attribType.Point.  Points, primitives,
        vertices, and geometry support the same set of methods for querying
        their attributes, and this method is one of them.

        See also:

        * hou.Prim.attribType
        * hou.Vertex.attribType
        * hou.Geometry.attribType
        * hou.attribType        """
        return attribType()

    def floatAttribValue(self, name_or_attrib):
        """
        floatAttribValue(self, name_or_attrib) -> float

        Return the point attribute value for a particular floating point
        attribute. The attribute may be specified by name or by hou.Attrib
        object.

        Raises hou.OperationFailed if no attribute exists with this name or the
        attribute is not float of size 1.

        In most cases, you'll just use hou.Point.attribValue to access attribute
        values.  Houdini uses this method internally to implement attribValue.
        """
        return 0.0

    def floatListAttribValue(self, name_or_attrib):
        """
        floatListAttribValue(self, name_or_attrib) -> tuple of float

        Return the point attribute value for a particular floating point
        attribute.  The attribute may be specified by name or by hou.Attrib
        object.  The return value is a tuple of floats.

        It is valid to call this method when the attribute's size is 1.  In this
        case, a tuple with one element is returned.

        See also hou.Point.attribValue.
        """
        return (0.0,)

    def intAttribValue(self, name_or_attrib):
        """
        intAttribValue(self, name_or_attrib) -> int

        Return the point attribute value for a particular integer attribute of
        size 1.  The attribute may be specified by name or by hou.Attrib object.
        See hou.Point.floatAttribValue for more information.
        """
        return 0

    def intListAttribValue(self, name_or_attrib):
        """
        intListAttribValue(self, name_or_attrib) -> tuple of int

        Return the point attribute value for a particular integer attribute.
        The attribute may be specified by name or by hou.Attrib object.  The
        return value is a tuple of ints.  See hou.Point.floatListAttribValue for
        more information.
        """
        return (0,)

    def stringAttribValue(self, name_or_attrib):
        """
        stringAttribValue(self, name_or_attrib) -> str

        Return the point attribute value for a particular string attribute.  The
        attribute may be specified by name or by hou.Attrib object.  See
        hou.Point.floatAttribValue for more information.
        """
        return ''

    def stringListAttribValue(self):
        """
        stringListAttribValue(self, name_or_attrib) -> tuple of str

        Return the point attribute value for a particular string attribute.  The
        attribute may be specified by name or by hou.Attrib object.  The return
        value is a tuple of strings.

        It is valid to call this method when the attribute's size is 1.  In this
        case, a tuple with one element is returned.

        See also hou.Point.attribValue.
        """
        return ('',)

    def setAttribValue(self, name_or_attrib, attrib_value):
        """
        setAttribValue(self, name_or_attrib, attrib_value)

        Store an attribute value in this point.  The attribute may be specified
        by name or by hou.Attrib object, and must be an existing point attribute
        in the geometry.  You would typically call this method from the code of
        a Python-defined SOP.

        Raises hou.OperationFailed if no attribute exists with this name or if
        the attribute's data type does not match the value passed in.  If the
        attribute's size is more than 1, the attribute value must be a sequence
        of integers/floats, and the size of the sequence must match the
        attribute's size.

        Raises hou.GeometryPermissionError if this geometry is not modifiable.

        See hou.Geometry.addAttrib for an example.

        See also:

        * hou.Prim.setAttribValue
        * hou.Vertex.setAttribValue
        * hou.Geometry.setGlobalAttribValue        """

    def attribValue(self, name_or_attrib):
        """
        attribValue(self, name_or_attrib) -> int, float, str or tuple

        Return value stored in this point for a particular attribute.  The
        attribute may be specified by name or by hou.Attrib object.

        Looking up an attribute value using a hou.Attrib object is slightly
        faster than looking it up by name.  When looking up attribute values
        inside a loop, look up the hou.Attrib object outside the loop, and pass
        it into this method.

        Note that the point position attribute is named P and is 4 floats in
        size. This attribute always exists.

        When looking up the attribute values of all points, it is faster to call
        hou.Geometry.pointFloatAttribValues or
        hou.Geometry.pointFloatAttribValuesAsString than to call this method for
        each point in the geometry.

        Raises hou.OperationFailed if no attribute exists with this name.

          # Create an object containing two SOPs: a box SOP wired into a color SOP.
          geo_node = hou.node("/obj").createNode("geo")
          box = geo_node.createNode("box")
          color = geo_node.createNode("color")
          color.setFirstInput(box)

          # Grab the color SOP's geometry, get its first point, and print out the
          # value of the Cd attribute.
          geo = color.geometry()
          point = geo.iterPoints()[0]
          print point.attribValue("Cd")

          # Look up the Cd attribute and illustrate how to access the attribute
          # value using the attribute object.
          cd_attribute = geo.findPointAttrib("Cd")
          print point.attribValue(cd_attribute)

        REPLACES
            point function
            points function
            poppoint function
            poppointid function        """

class PointGroup(object):
    """
    hou.PointGroup

    A named group of points inside a Geometry object.

    Point groups reside inside the geometry, and each point group has a
    unique name.

    Groups are either ordered or unordered.  When asking for the contents of
    an ordered group, the results will be returned in the order they were
    added to to the group.  For an unordered group, the results will be
    returned in an arbitrary order (though it is normally arranged by
    increasing point number). When creating a group using the group SOP, use
    the <Create Ordered> checkbox to create an ordered group.  When creating
    one from Python, Use the is_ordered parameter of
    hou.Geometry.createPointGroup to control whether a group is ordered.

    See hou.Point for more information about points.  See also
    hou.PrimGroup.

    REPLACES
      * haspoint
      * pointlist


    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def geometry(self):
        """
        geometry(self) -> hou.Geometry

        Return the geometry object containing this group.
        """
        return Geometry()

    def name(self):
        """
        name(self)

        Return the name of the group.  Each point group has a unique name.
        """
        return ''

    def points(self):
        """
        points(self) -> tuple of hou.Point

        Return the contents of this group.
        """
        return Point()

    def contains(self, point):
        """
        contains(self, point) -> bool

        Return whether or not a point is in this group.

        Raises hou.OperationFailed if the point belongs to a different geometry
        object than this group.
        """
        return True

    def isOrdered(self): return True
    def add(self, point_or_list_or_point_group):
        """
        add(self, point_or_list_or_point_group)

        If given a hou.Point or a list of hou.Point's, add the point(s) to the
        group.  If given a hou.PointGroup, merge the contents of the other point
        group with this group (the other group is unaffected).  You would
        typically call this method from the code of a Python-defined SOP.

        It is ok to add points to the group that were already in the group.

        Raises hou.GeometryPermissionError if this geometry is not modifiable.

        Raises hou.OperationFailed if the point or point group belong to a
        different geometry object than this group.
        """

    def remove(self, point_or_list_or_point_group):
        """
        remove(self, point_or_list_or_point_group)

        If given a hou.Point or a list of hou.Point's, remove the point from the
        group.  If given a hou.PointGroup, remove all points in the other group
        from this group (the other group is unaffected).  You would typically
        call this method from the code of a Python-defined SOP.

        It is not an error to try to remove a point from the group that wasn't
        already in the group.

        Raises hou.GeometryPermissionError if this geometry is not modifiable.

        Raises hou.OperationFailed if the point belongs to a different geometry
        object than this group.
        """

    def clear(self):
        """
        clear(self)

        Remove all points from this group.  You would typically call this method
        from the code of a Python-defined SOP.

        The points remain in the geometry; only the group is affected.

        Raises hou.GeometryPermissionError if this geometry is not modifiable.
        """

    def destroy(self):
        """
        destroy(self)

        Remove this group from the geometry.  You would typically call this
        method from the code of a Python-defined SOP.

        Raises hou.GeometryPermissionError if this geometry is not modifiable.
        """

    def optionType(self, name):
        """
        optionType(self, name) -> hou.fieldType enum value

        Return a hou.fieldType enumerated value that describes the type of data
        stored in an option.  Returns hou.fieldType.NoSuchField if no field
        exists with that name.
        """
        return fieldType()

    def setOption(self, name, value, type_hint = hou.fieldType.NoSuchField):
        """
        setOption(self, name, value, type_hint = hou.fieldType::NoSuchField)

        Set an entry in the dictionary of options.  See hou.PointGroup.options
        for more information.

        name
            The name of the option to set.

        value
            An integer, float, string, hou.Vector2, hou.Vector3, hou.Vector4,
            hou.Quaternion, hou.Matrix3, hou.matrix4, or sequence of numbers.

        type_hint
            Used to determine the exact hou.fieldType desired when the specified
            value type is not enough to unambiguously determine it.
        """

    def removeOption(self, name):
        """
        removeOption(self, name)

        Remove an entry in the dictionary of options.  See
        hou.PointGroup.options for more information.

        Raises hou.OperationFailed if there is no entry in the dictionary with
        this name.
        """

    def options(self, name):
        """
        option(self, name) -> bool, int, float, str, hou.Vector2,
        Hom.hou.Vector3, hou.Vector4, hou.Quaternion, hou.Matrix3, hou.Matrix4,
        tuple of int, or tuple of float

        Return the value of an individual option, on None if no such option
        exists.

        See also hou.PointGroup.options, hou.PointGroup.setOption and
        hou.PointGroup.removeOption.
        """

    def option(self): return

class Polygon(Face):
    """
    hou.Polygon

    A Polygon is a kind of Face whose vertices are connected via straight
    lines.

    Currently, hou.Face, and its base class hou.Prim contain all the
    necessary methods for polygon inspection and manipulation.


    """

    def __init__(self): raise AttributeError, "No constructor defined"

class PopNetNode(Node):
    """
    hou.PopNetNode
    """
    def __init__(self): raise AttributeError, "No constructor defined"
    def displayNode(self):
        """
        displayNode(self) -> Node
        """
        return Node()

    def renderNode(self):
        """
        renderNode(self) -> Node
        """
        return Node()
class PopNode(Node):
    """
    hou.PopNode

    Represents a particle node.

    REPLACES
      * opget
      * opset
      * opflag
      * popevent
      * popeventtime
      * poppoint
      * poppointid
      * poppointnum


    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def curPoint(self):
        """
        curPoint(self) -> hou.Point

        Returns the current point, equivalent to the $PT local variable. This
        function only works on a node that has a $PT local variable, and only
        when the node is being cooked.
        """
        return Point()
    def isBypassed(self):
        """
        isBypassed(self) -> bool

        Returns whether this node's bypass flag is on.
        """
        return True

    def bypass(self, on):
        """
        bypass(self, on)

        Turns this node's bypass flag on or off, making this node have no
        effect.
        """

    def isTemplateFlagSet(self):
        """
        isTemplateFlagSet(self) -> bool

        Returns whether the template flag on this node is on.
        """
        return True
    def setTemplateFlag(self, on):
        """
        setTemplateFlag(self, on)

        Sets this node's template flag on or off.
        """

    def isDisplayFlagSet(self):
        """
        isDisplayFlagSet(self) -> bool

        Returns whether this node's display flag is on.
        """
        return True

    def setDisplayFlag(self, on):
        """
        setDisplayFlag(self, on)

        Turn this node's display flag on or off.
        """

    def isRenderFlagSet(self):
        """
        isRenderFlagSet(self) -> bool

        Returns whether this node's render flag is on.
        """
        return True

    def setRenderFlag(self, on):
        """
        setRenderFlag(self, on)

        Turns this node's render flag on or off.
        """

    def displayNode(self):
        """
        displayNode(self) -> Node
        """
        return Node()

    def renderNode(self):
        """
        renderNode(self) -> Node
        """
        return Node()

class PrimGroup(object):
    """
    hou.PrimGroup

    A named group of primitives inside a Geometry object.

    Primitive groups reside inside the geometry, and each primitive group
    has a unique name.

    Groups are either ordered or unordered.  When asking for the contents of
    an ordered group, the results will be returned in the order they were
    added to to the group.  For an unordered group, the results will be
    returned in an arbitrary order (though it is normally arranged by
    increasing primitive number). When creating a group using the group SOP,
    use the <Create Ordered> checkbox to create an ordered group.  When
    creating one from Python, Use the is_ordered parameter of
    hou.Geometry.createPrimGroup to control whether a group is ordered.

    See hou.Prim for more information about primitives.  See also
    hou.PrimGroup.

    REPLACES
      * hasprim
      * primlist
    """
    def __init__(self): raise AttributeError, "No constructor defined"
    def geometry(self):
        """
        geometry(self) -> hou.Geometry

        Return the geometry object containing this group.
        """
        return Geometry()

    def name(self):
        """
        name(self)

        Return the name of the group.  Each primitive group has a unique name.
        """
        return ''

    def prims(self):
        """
        prims(self) -> tuple of hou.Prim

        Return the contents of this group.
        """
        return (Prim(),)

    def contains(self, prim):
        """
        contains(self, prim) -> bool

        Return whether or not a primitive is in this group.

        Raises hou.OperationFailed if the primitive belongs to a different
        geometry object than this group.
        """
        return True

    def isOrdered(self): return True
    def add(self, prim_or_list_or_prim_group):
        """
        add(self, prim_or_list_or_prim_group)

        If given a hou.Prim or a list of hou.Prim's, add the primitive(s) to the
        group.  If given a hou.PrimGroup, merge the contents of the other
        primitive group with this group (the other group is unaffected).  You
        would typically call this method from the code of a Python-defined SOP.

        It is okay to add primitives to the group that were already in the
        group.

        Raises hou.GeometryPermissionError if this geometry is not modifiable.

        Raises hou.OperationFailed if the primitive or primitive group belong to
        a different geometry object than this group.
        """

    def remove(self, prim_or_list_or_prim_group):
        """
        remove(self, prim_or_list_or_prim_group)

        If given a hou.Prim or a list of hou.Prim's, remove the primitive(s)
        from the group.  If given a hou.PrimGroup, remove all primitives in the
        other group from this group (the other group is unaffected).  You would
        typically call this method from the code of a Python-defined SOP.

        It is not an error to try to remove a primitive from the group that
        wasn't already in the group.

        Raises hou.GeometryPermissionError if this geometry is not modifiable.

        Raises hou.OperationFailed if the primitive belongs to a different
        geometry object than this group.
        """

    def clear(self):
        """
        clear(self)

        Remove all primitives from this group.  You would typically call this
        method from the code of a Python-defined SOP.

        The primitives remain in the geometry; only the group is affected.

        Raises hou.GeometryPermissionError if this geometry is not modifiable.
        """

    def destroy(self):
        """
        destroy(self)

        Remove this group from the geometry.  You would typically call this
        method from the code of a Python-defined SOP.

        Raises hou.GeometryPermissionError if this geometry is not modifiable.
        """

    def optionType(self, name):
        """
        optionType(self, name) -> hou.fieldType enum value

        Return a hou.fieldType enumerated value that describes the type of data
        stored in an option.  Returns hou.fieldType.NoSuchField if no field
        exists with that name.
        """
        return fieldType()

    def setOption(self, name, value, type_hint = hou.fieldType.NoSuchField):
        """
        setOption(self, name, value, type_hint = hou.fieldType::NoSuchField)

        Set an entry in the dictionary of options.  See hou.PrimGroup.options
        for more information.

        name
            The name of the option to set.

        value
            An integer, float, string, hou.Vector2, hou.Vector3, hou.Vector4,
            hou.Quaternion, hou.Matrix3, hou.Matrix4, or sequence of numbers.

        type_hint
            Used to determine the exact hou.fieldType desired when the specified
            value type is not enough to unambiguously determine it.
        """

    def removeOption(self, name):
        """
        removeOption(self, name)

        Remove an entry in the dictionary of options.  See hou.PrimGroup.options
        for more information.

        Raises hou.OperationFailed if there is no entry in the dictionary with
        this name.
        """

    def options(self, name):
        """
        option(self, name) -> bool, int, float, str, hou.Vector2, hou.Vector3,
        hou.Vector4, hou.Quaternion, hou.Matrix3, hou.Matrix4, tuple of int, or
        tuple of float

        Return the value of an individual option, on None if no such option
        exists.

        See also hou.PrimGroup.options, hou.PrimGroup.setOption and
        hou.PrimGroup.removeOption.
        """

    def option(self): return


class pypanel(object):
    """
    hou.pypanel
    Module containing functions related to Python panels.
    """
    def __init__(self): raise AttributeError, "No constructor defined"
    def installFile(file_path):
        """
        installFile(file_path)

        Install all the Python Panel interfaces defined in the given .pypanel
        file into the current Houdini session.

        file_path
            The .pypanel file to load.
        """
    def interfacesInFile(file_path):
        """
        interfacesInFile(file_path) -> tuple of hou.PythonPanelInterface

        Return all the Python Panel interface definitions inside the given
        .pypanel file.  See hou.PythonPanelInterface for more information.

        Raises hou.OperationFailed if file_path does not refer to a valid
        .pypanel file.
        """
        return (PythonPanelInterface(),)

    def setMenuInterfaces(names):
        """
        setMenuInterfaces(names)

        Set the Python Panel drop-down menu to the list of interface names.
        Note that __separator__ is a valid name to indicate a separator in the
        list.

        Raises hou.OperationFailed if names contains interfaces that are not
        installed
        """

    def menuInterfaces(self):
        """
        menuInterfaces() -> tuple of str

        Return a tuple of the names of the interfaces currently shown in the
        Python Panel drop-down menu.
        """
        return ('',)

class PythonPanelInterface(object):
    """
    hou.PythonPanelInterface
    Represents the definition of a Python panel interface.
    See also hou.pypanel and hou.PythonPanel.
    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def id(self):
        """
        id(self) -> int

        Returns the id for this interface.
        """
        return 0

    def setId(self,id):
        """
        setId(self,id)

        Sets the id for this interface.
        """

    def name(self):
        """
        name(self) -> str

        Returns the name for this interface.
        """
        return ''

    def setName(self,name):
        """
        setName(self,name)

        Sets the name for this interface.
        """

    def label(self):
        """
        label(self) -> str

        Returns the label for this interface.
        """
        return ''

    def setLabel(self,label):
        """
        setLabel(self,label)

        Sets the label for this interface.
        """

    def icon(self):
        """
        icon(self) -> str
        Returns the icon for this interface.
        """
        return ''

    def setIcon(self,icon):
        """
        setIcon(self,icon)

        Sets the icon for this interface.
        """

    def script(self):
        """
        script(self) -> str

        Returns the script for this interface.
        """
        return ''

    def setScript(self,script):
        """
        setScript(self,script)

        Sets the script for this interface.
        """

    def filePath(self):
        """
        filePath(self) -> str

        Returns the file path for this interface.
        """
        return ''
    def setFilePath(self,script):
        """
        setFilePath(self,script)

        Sets the file path for this interface.
        """

class Quadric(Prim):
    """
    hou.Quadric

    A Quadric is a kind of geometry primitive (Prim object) that represents
    a 3-dimensional surface defined by a quadratic polynomial equation (e.g.
    a sphere or tube).
    """
    def __init__(self): raise AttributeError, "No constructor defined"
    def transform(self):
        """
        transform(self) -> hou.Matrix3

        Return the 3x3 matrix associated with this quadric.  This matrix
        determines what type of quadric it is.

        See Wikipedia's Quadric page for more information.
        """
        return Matrix3()

    def getTransform(self): return
    def vertex(self, index):
        """
        vertex(self, index) -> hou.Vertex

        A shortcut for self.vertices()[index].  You probably don't need to call
        this method.

        This method supports negative indices to index from the end, just like
        self.vertices()[index] would.  Also, like Python's indexing operator, it
        will raise IndexError when the index is out of range.
        """
        return Vertex()

class Quaternion(object):
    """
    hou.Quaternion

    A representation of a 3D rotation (or orientation).  You can smoothly
    interpolate between two rotation values by interpolating between two
    quaternions.

    Quaternions provide an easy way to nicely interpolate between two
    rotation values, and avoid the gimbal lock and direction changes caused
    by interpolating Euler angles.  They can easily be converted to and from
    rotation matrices, Euler angles, and angle-axis rotations.

    A quaternion is represented by a vector of 4 floats (x, y, z, and w).
    Any rotation in three dimensions is a rotation by some angle about some
    axis, and you can think of the (x, y, z) portion of the quaternion as
    storing the axis and the w portion as storing a (representation of) the
    angle.

    See Wikipedia's Quaternion page and its Quaternions and space rotation
    page for more information.


    """

    def __init__(self, *args):
        """
        __init__(self)

        You can construct a quaternion from a 3x3 rotation matrix, a 4x4
        rotation matrix, a rotation about an axis, Euler angles, or an (x, y, z,
        w) tuple. Note that rotations are represented as unit quaternions (i.e.
        quaternions of length 1), so constructing a quaternion from an arbitrary
        (x, y, z, w) tuple will not necessarily give a unit quaternion.

          # Construct a quaternion from a rotation matrix.
          hou.Quaternion(matrix3)
          hou.Quaternion(matrix4)

          # Construct a quaternion from a rotation about an arbitrary axis.
          hou.Quaternion(90, (1, 1, 0))

          # Construct a quaternion from Euler angles.
          quaternion = hou.Quaternion()
          quaternion.setToEulerAngles((rx, ry, rz), rotate_order="xyz")

          # Another way to construct a quaternion from Euler angles by first
          # constructing a matrix.
          hou.Quaternion(hou.hmath.buildRotate((rx, ry, rz), "xyz"))

          # Construct a quaternion with specific x, y, z, and w values.
          hou.Quaternion(x, y, z, w)

          # Construct a quaternion with x, y, z, set to zero and w set to one.
          # This quaternion corresponds to the identity quaternion (i.e. no
          # rotation).
          hou.Quaternion()

        See also hou.hmath.buildRotate, hou.hmath.buildRotateAboutAxis, and
        hou.Matrix4.extractRotationMatrix3.
        """
    def isAlmostEqual(self, quaternion, tolerance=0.00001):
        """
        isAlmostEqual(self, quaternion, tolerance=0.00001) -> bool

        Returns whether this quaternion is equal to another, within a numerical
        tolerance.
        """
        return True

    def almostEqual(self): return True
    def __getitem__(self, index):
        """
        __getitem__(self, index) -> float

        Return one of the four float values stored in the quaternion.  This
        method, along with hou.Quaternion.__setitem__ and
        hou.Quaternion.__len__, make quaternions behave like sequences of 4
        floats so you can use Python's square bracket notation, sequence
        iteration, etc.

          >>> q = hou.Quaternion(1, 2, 3, 4)
          >>> for value in q:
          ...     print value
          1
          2
          3
          4
          >>> q[2]
          3
          >>> len(q)
          4
        """
        return 0.0

    def __setitem__(self, index, value):
        """
        __setitem__(self, index, value)

        Set one of the four float values stored in the quaternion.  See
        hou.Quaternion.__getitem__ for more information.
        """

    def __len__(self):
        """
        __len__(self) -> int

        Return 4, the number of float elements in the quaternion.  See
        hou.Quaternion.__getitem__ for more information.
        """
        return 0
    def setTo(self, tuple):
        """
        setTo(self, tuple)

        Set the quaternion's 4 float values (x, y, z, and w).  tuple must be a
        sequence of 4 floats.

        This method will modify an existing quaternion object.  Use
        hou.Quaternion.__init__ to construct a new quaternion from these four
        values.

        See also hou.Quaternion.__setitem__.
        """

    def setToRotationMatrix(self, matrix3_or_matrix4):
        """
        setToRotationMatrix(self, matrix3_or_matrix4)

        Set this quaternion to contain the rotation component of the
        transformation in a hou.Matrix3 or hou.Matrix4.

        See also hou.Quaternion.extractRotationMatrix3.
        """

    def setToAngleAxis(self, angle_in_deg, axis):
        """
        setToAngleAxis(self, angle_in_deg, axis)

        Set this quaternion to contain the rotation about an axis by the given
        angle.  angle_in_deg is in degrees and axis is a sequence of 3 floats.

        This method can also be implemented as follows:
          def setToAngleAxis(self, angle_in_deg, axis):
              self.setToRotationMatrix(
                  hou.hmath.buildRotateAboutAxis(axis, angle_in_deg))


        See also hou.Quaternion.extractAngleAxis.
        """

    def setToEulerRotates(self, angles_in_deg, rotate_order="xyz"):
        """
        setToEulerRotates(self, angles_in_deg, rotate_order="xyz")

        Set this quaternion to contain the rotation specified by Euler rotations
        about the x, y, and z coordinate axes.

        This method can also be implemented as follows:
          def setToEulerRotates(self, angles_in_deg, rotate_order="xyz"):
              self.setToRotationMatrix(
                  hou.hmath.buildRotate(angles_in_deg, rotate_order))


        See also hou.Quaternion.extractEulerRotates and hou.hmath.buildRotate.
        """

    def conjugate(self):
        """
        conjugate(self) -> hou.Quaternion

        Return a quaternion containing the opposite rotation of that stored in
        this quaternion.  Intuitively, for unit length quaternions, the
        quaternion returned contains a rotation by the same angle about an axis
        pointing in the opposite direction.
        """
        return Quaternion()

    def inverse(self):
        """
        inverse(self) -> hou.Quaternion

        Return a quaternion containing the multiplicative inverse of this
        quaternion.  For unit quaternions, the inverse is the same as the
        conjugate.

        See also hou.Quaternion.conjugate.
        """
        return Quaternion()

    def dot(self, quaternion):
        """
        dot(self, other) -> float

        Return the dot product of this quaternion with another one.
        """
        return 0.0

    def __add__(self, quaternion):
        """
        __add__(self, quaternion) -> hou.Quaternion

        Return a new quaternion containing the sum of this quaternion and
        another. This method lets you write quaternion1 + quaternion2.

        The sum of two quaternions is defined to be the vector containing the
        pairwise sum of their elements.
        """
        return Quaternion()

    def __sub__(self, quaternion):
        """
        __sub__(self, quaternion) -> hou.Quaternion

        Return a new quaternion containing the result of subtracting another
        quaternion from this one.  This method lets you write quaternion1 -
        quaternion2.
        """
        return Quaternion()

    def __mul__(self, quaternion_or_scalar):
        """
        __mul__(self, quaternion_or_scalar) -> hou.Quaternion

        Multiply this quaternion by either another quaternion or a scalar.  This
        method lets you write quaternion1 * quaternion2 and quaternion * scalar.
        This method returns a new hou.Quaternion and does not change this
        object's value.

        The product of two quaternions is defined to be the vector containing
        the pairwise product of their elements.  Multiplying a quaternion by a
        scalar multiplies each of the elements by that scalar.
        """
        return Quaternion()

    def slerp(self, other, fraction):
        """
        slerp(self, other, fraction) -> hou.Quaternion

        Perform spherical linear interpolation between this quaternion and
        another, returning a new quaternion.  fraction is a float from 0.0 to
        1.0, where 0.0 gives this quaternion and 1.0 gives the other quaternion.
        This method is very useful to smoothly interpolate between two different
        rotations.

        See Wikipedia's Slerp page for more information.

        The following example will nicely interpolate between two sets of Euler
        rotations.
          def interpolateEulerRotations(rotation1, rotation2, fraction, rotate_order="xyz"):
              quaternion1 = hou.Quaternion()
              quaternion1.setToEulerRotates(rotation1, rotate_order)
              quaternion2 = hou.Quaternion()
              quaternion2.setToEulerRotates(rotation2, rotate_order)

              return quaternion1.slerp(quaternion2, fraction).extractEulerRotates(rotate_order)
        """
        return Quaternion()

    def normalized(self):
        """
        normalized(self) -> hou.Quaternion

        Return a normalized version of this quaternion (i.e. a version of this
        quaternion whose length is one).  Quaternions that represent rotations
        are always normalized.

        Normalizing a quaternion whose length is zero or near zero will return a
        new quaternion with the same values.

        This method can be implemented as follows (for non-zero length
        quaternions):
          def normalized(self):
              return self * (1.0 / self.length())
        """
        return Quaternion()

    def length(self):
        """
        length(self) -> float

        Return the length of the quaternion.  When quaternions represent
        rotations, their length is one.

        A quaternion's length is compute the same as a Vector4's:
        hou.Vector4(self).length()
        """
        return 0.0

    def extractRotationMatrix3(self):
        """
        extractRotationMatrix3(self) -> hou.Matrix3

        Return a 3x3 rotation matrix corresponding to the rotation in the
        quaternion.

        To create a hou.Matrix4 instead of a hou.Matrix3, you can easily create
        a Matrix4 from the Matrix3:
          hou.Matrix4(quaternion.extractRotationMatrix3())


        If the quaternion is the zero quaternion, this method does not raise an
        exception.  Instead, it returns the identity matrix.

        See also hou.Quaternion.setToRotationMatrix.
        """
        return Matrix3()

    def extractAngleAxis(self):
        """
        extractAngleAxis(self) -> (float, hou.Vector3)

        Return an axis and a rotation about that axis corresponding to the
        rotation in the quaternion.  The return value is a 2-tuple containing a
        float and a hou.Vector3.  The returned axis vector is normalized.

        If this quaternion is the zero quaternion, the angle returned is zero
        and the vector is the zero vector.  Otherwise, if it is not normalized,
        the return values will correspond to the rotation represented by the
        normalized quaternion.

        See also hou.Quaternion.setToAngleAxis.
        """
        return (float, Vector3)

    def extractEulerRotates(self, rotate_order="xyz"):
        """
        extractEulerRotates(self, rotate_order="xyz") -> hou.Vector3

        Return the Euler rotations (the x, y, and z rotation values, in degrees,
        about the coordinate axes) corresponding to the rotation in the
        quaternion.

        This method can also be implemented as follows:
          def extractEulerRotates(self, rotate_order="xyz"):
              return hou.Matrix4(self.extractRotationMatrix3()).explode(rotate_order=rotate_order)["rotate"]


        See also hou.Quaternion.setToEulerRotates.
        """
        return Vector3()

    def _asVoidPointer(self): return

class Ramp(object):
    """
    hou.Ramp

    A Ramp represents a function that yields either floating point values or
    colors.  You can evaluate this function between 0.0 and 1.0, and the
    function's shape is determined by a sequence of values at key positions
    between 0.0 and 1.0.

    If you evaluate a ramp parameter on a node, Houdini will return a Ramp
    object.

    You can check the curve "basis" of a ramp you get from a parameter by
    calling the hou.Ramp.basis method,which returns a hou.rampBasis value.

    In the Hermite basis, the curve passes through the _odd_ control points,
    and the _even_ control points control the tangent at the previous point.
    See the Wikipedia article on Hermite spline curves for more information.

    To get a smooth curve, you should evenly space the control points.

    RELATED
      * spline
    """

    def __init__(self, basis, keys, values):
        """
        __init__(self, basis, keys, values) -> float

        basis
            A sequence of hou.rampBasis values, one for each key.  The ramp
            basis for a key determines how Houdini interpolates from the key up
            until the next key.  If there is no next key, Houdini will hold the
            value constant until the end of the [0,1] domain, regardless of the
            ramp basis.

        keys
            A sequence of floats, one for each key, each between 0.0 and 1.0,
            inclusive.  Each key represents the location in the [0,1] domain of
            its corresponding value.

        values
            A sequence of values, where each value corresponds to a key.  When
            asked to evaluate at a value where there is no key, Houdini will
            interpolate between adjacent values using the basis function for the
            key on the left.

            This sequence is _either_ a sequence of floats _or_ a sequence of
            triples of floats.  In the former case, the newly-created ramp will
            evaluate to a single floating-point value.  In the latter case, it
            will evaluate to a color.

        Raises hou.InvalidSize if the keys and values sequences are not not same
        size, or if values contains subsequences of floats that are not 3
        elements long.

          >>> lin = hou.rampBasis.Linear

          # Create a ramp that linearly interpolates between 2.5 and 4.5.
          >>> r = hou.Ramp((lin, lin), (0, 1), (2.5, 4.5))
          >>> r
          <hou.Ramp is_color=False num_keys=2 data=((t=0, 2.5), (t=1, 4.5))>
          >>> r.lookup(0.0)
          2.5
          >>> r.lookup(0.5)
          3.5
          >>> r.lookup(1.0)
          4.5

          # Create a color ramp that linearly interpolates from black to red.
          >>> hou.Ramp((lin, lin), (0, 1), ((0.0, 0.0, 0.0), (1.0, 0.0, 0.2)))
          <hou.Ramp is_color=True num_keys=2 data=((t=0, rgb=(0, 0, 0)), (t=1, rgb=(1, 1, 1)))>

        REPLACES
            opramp command        """
    def isColor(self):
        """
        isColor(self) -> bool

        Return True if this is a color ramp, and False if it is a single float
        ramp.
        """
        return True

    def colorType(self):
        """
        colorType(self) -> colorType

        If this is a color ramp, return the color space that is used during
        interpolation.  The default is hou.colorType.RGB.

        Raises hou.OperationFailed if this ramp is not a color ramp.
        """
        return colorType()

    def setColorType(self, color_type):
        """
        setColorType(self, hou.colorType)

        If this is a color ramp, set the color space that is used during
        interpolation.  The default is hou.colorType.RGB.

        To obtain a more perceptually uniform interpolation, use
        hou.colorType.LAB. To obtain a ramp that matches the rainbow, use
        hou.colorType.HSV.

        Raises hou.OperationFailed if this ramp is not a color ramp.
        """

    def basis(self):
        """
        basis(self) -> tuple of hou.rampBasis enum values

        Return a tuple of hou.rampBasis enumeration values that determine how
        Houdini interpolates between the keys in the ramp.  See
        hou.Ramp.__init__ for more information.
        """
        return (rampBasis(),)

    def keys(self):
        """
        keys(self) -> tuple of float

        Return a tuple of floats between 0.0 and 1.0 containing the ramp key
        positions.  See hou.Ramp.__init__ for more information.
        """
        return (0.0,)

    def _asVoidPointer(self): return
    def lookup(self,interpolant):
        """
        lookup(self, interpolant) -> float or tuple

        Return the value of the ramp at a specified position from 0.0 to 1.0,
        inclusive.

        Returns a float (for floating-point value ramps) or a tuple of 3 floats
        (for color ramps).
        """
        return

    def values(self):
        """
        values(self) -> tuple of float or tuple of tuple of float

        Return a tuple of floats (for a float ramp) or a tuple of tuples of 3
        floats (for a color ramp) corresponding to the values in the ramp stored
        at each key.  See hou.Ramp.__init__ for more information.
        """
        return (0.0,)

class RampParmTemplate(ParmTemplate):
    """
    hou.RampParmTemplate

    Parameter template for a ramp parameter.


    """

    def __init__(self, name, label, ramp_parm_type, default_value=2,
        default_basis=None, show_controls=True, color_type=None,
        disable_when=None, is_hidden=False, help=None, script_callback=None,
        script_callback_language=hou.scriptLanguage.Hscript, tags={},
        default_expression_language=hou.scriptLanguage.Hscript):
        """
        __init__(self, name, label, ramp_parm_type, default_value=2,
        default_basis=None, show_controls=True, color_type=None,
        disable_when=None, is_hidden=False, help=None, script_callback=None,
        script_callback_language=hou.scriptLanguage.Hscript, tags={},
        default_expression_language=hou.scriptLanguage.Hscript)

        Construct a new RampParmTemplate.

        name
            See hou.ParmTemplate.name for more information.

        label
            See hou.ParmTemplate.label for more information.

        ramp_parm_type
            See the parmType method for more information.

        default_value
            The default number of ramp keys in new ramp parameter instances.
            See the defaultValue method for more information.

        default_basis
            See the defaultBasis method for more information.  If this parameter
            is not specified it defaults to hou.rampBasis.Linear.

            The following example uses a Catmull-Rom basis:
              r = hou.RampParmTemplate(
                  "myRamp", "My Ramp", hou.rampParmType.Color,
                  default_basis=hou.rampBasis.CatmullRom)


        show_controls
            See the showsControls method for more information.

        color_type
            See the colorType method for more information.  If this parameter is
            not specified it defaults to hou.colorType.RGB.

            The following example uses an L*a*b* color space:

              r = hou.RampParmTemplate(
                  "myRamp", "My Ramp", hou.rampParmType.Color,
                  color_type=hou.colorType.LAB)

        disable_when
            See hou.ParmTemplate.disableWhen for more information.

        is_hidden
            See hou.ParmTemplate.isHidden for more information.

        help
            See hou.ParmTemplate.help for more information.

        script_callback
            See hou.ParmTemplate.scriptCallback for more information.

        script_callback_language
            See hou.ParmTemplate.scriptCallbackLanguage for more information.

        tags
            See hou.ParmTemplate.tags for more information.

        default_expression
            See the defaultExpression method for more information.

        default_expression_language
            See the defaultExpressionLanguage method for more information.
        """
    def defaultValue(self):
        """
        defaultValue(self) -> int

        Return this is the default number of ramp keys in new ramp parameter
        instances.
        """
        return 0

    def setDefaultValue(self, default_value):
        """
        setDefaultValue(self, default_value)

        Set the default number of ramp keys to be used in new ramp parameter
        instances.
        """

    def defaultExpression(self):
        """
        defaultExpression(self) -> string

        Return the expression, which when evaluated, returns the number of ramp
        keys to be used in new ramp parameter instances.

        The default expression takes precendence  over the default value.  If
        the default expression is not set  (i.e. an empty string), then the
        default value is used instead.

        Note that the default expression language is needed to interpret the
        meaning of the default expression.
        """
        return ''

    def setDefaultExpression(self, default_expression):
        """
        setDefaultExpression(self, default_expression)

        Set the default expression, which when evaluated, returns the number of
        ramp keys to be used in new ramp parameter instances.

        If default_expression is the empty string, then the default expression
        is unset.
        """

    def defaultExpressionLanguage(self):
        """
        defaultExpressionLanguage(self) -> tuple of hou.scriptLanguage

        Return the default expression language.

        The default expression language only applies if the default expression
        is set.  If the default expression is not set, then the expression
        language is set to hou.scriptLanguage.Hscript.
        """
        return (scriptLanguage(),)

    def setDefaultExpressionLanguage(self,default_expression_language):
        """
        setDefaultExpressionLanguage(self, default_expression_language)

        Set the default expression language.

        See the defaultExpressionLanguage method for more information.
        """
        return _hou.RampParmTemplate_setDefaultExpressionLanguage(*args)

    def parmType(self): return rampParmType()
    def setParmType(self, ramp_parm_type):
        """
        setParmType(self, ramp_parm_type)

        Set the type of this ramp to a hou.rampParmType enum value.
        """

    def defaultBasis(self):
        """
        defaultBasis(self) -> hou.rampBasis enum value

        The basis function used to control how values are interpolated between
        ramp keys.

        See hou.rampBasis for more information.
        """
        return rampBasis()

    def setDefaultBasis(self, ramp_basis):
        """
        setDefaultBasis(self, ramp_basis)

        Set the basis function used to control how values are interpolated
        between ramp keys.  ramp_basis is a hou.rampBasis enum value.
        """

    def colorType(self):
        """
        colorType(self) -> hou.colorType enum value

        The color space in which to interpolate color ramp keys.

        See hou.colorType for more information on color spaces.
        """
        return colorType()
    def setColorType(self, color_type):
        """
        setColorType(self, color_type)

        Set the color space in which to interpolate color ramp keys to a
        hou.colorType enum value.
        """

    def showsControls(self):
        """
        showsControls(self) -> bool

        Return whether new instances of this ramp parameter have the controls
        expanded by default.  The user may later expand or collapse the ramp
        controls on the parameter.
        """
        return True

    def setShowsControls(self, on):
        """
        setShowsControls(self, on)

        Set whether new instances of this ramp parameter have the controls
        expanded by default.
        """

class RedrawBlock(object):
    """
    hou.RedrawBlock

    Use this class to collect mulitple redraws for any Python code block and
    only redraw once.
    """

    def __init__(self, *args, **kwargs):
        """
        `init(self)

        Construct a new RedrawBlock.

        The constructor should only be called from within a with statement.  For
        example:
          with hou.RedrawBlock() as redrawblock:
              #
              # Perform tasks
              #
        All tasks within the code block will have their redraw requests
        collected and deferred until after the code in the block is complete.
        Once the code block is complete (or an exception causes a jump out of
        the  block), a single redraw per window with redraw requests will be
        performed. This cuts down on "redraw flickering" for a long set of
        commands.


        Use care with Redraw Blocks. If an operation requires user interaction
        it should not be within a Redraw Block, otherwise the user will not see
        any prompts or the results of their actions.
        """
    def __enter__(self): return
    def __exit__(self): return

class RopNode(Node):
    """
    hou.RopNode

    Represents a render output node.

    REPLACES
      * opset
      * render
      * opflag
      * opget
    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def isBypassed(self):
        """
        isBypassed(self) -> bool

        Returns whether this node's bypass flag is on.
        """
        return True

    def bypass(self, on):
        """
        bypass(self, on)

        Turns the node's bypass flag on or off, making this node have no effect.
        """

    def isLocked(self):
        """
        isLocked(self) -> bool

        Returns whether this node's lock flag is on.
        """
        return True

    def setLocked(self, on):
        """
        setLocked(self, on)

        Sets this node's lock flag on or off. The lock flag caches the node's
        data and the data from its inputs and prevents them from being
        recalculated during cooking.
        """

    def inputDependencies(self):
        """
        inputDependencies(self) -> (tuple of hou.RopNode, tuple of tuples of
        float)

        Returns the input dependencies of the ROP node, consisting of ROPs, and
        the frames that need to be be rendered prior to rendering the ROP.

        This method returns a tuple of two elements:

        * The first element is a sequence of the hou.RopNode objects
          representing the input dependencies.
        * The second element is a sequence, where each element corresponds to
          the RopNode object at the same position in the first sequence, and is
          a sequence of floats representing the frames that must be rendered for
          the corresponding RopNode.        """
        return ((RopNode(),),(0.0,))

    def render(self, frame_range=(), res=(), output_file=None,
        output_format=None, to_flipbook=False, quality=2, ignore_inputs=False,
        method=RopByRop, ignore_bypass_flags=False, ignore_lock_flags=False,
        verbose=False, output_progress=False):
        """
        render(self, frame_range=(), res=(), output_file=None,
        output_format=None, to_flipbook=False, quality=2, ignore_inputs=False,
        method=RopByRop, ignore_bypass_flags=False, ignore_lock_flags=False,
        verbose=False, output_progress=False)

        Renders this node and optionally any of its inputs.  Inputs are
        recursively processed (unless ignore_inputs is True), so that all
        descendents are rendered in the proper order before this node is
        rendered.

        frame_range
            Sequence of 2 or 3 values, overrides the frame range and frame
            increment to render. The first two values specify the start and end
            frames, and the third value (if given) specifies the frame
            increment. If no frame increment is given and the ROP node doesn't
            specify a frame increment, then a value of 1 will be used. If no
            frame range is given, and the ROP node doesn't specify a frame
            range, then the current frame will be rendered.

        res
            Sequence of two scaling factors that will be used to scale the
            resolution of the image, along the x- and y-axes. The scaling
            factors will be applied to the node and all dependencies that are
            also rendered.

        output_file
            Overrides the location to which the image is written.

        output_format
            Overrides the format of the image.

        to_flipbook
            If True, renders this node to a flipbook.

        quality
            Overrides the render quality.

        ignore_inputs
            If True, renders only this node (does not render any of its
            dependencies).

        method
            Either hou.renderMethod.RopByRop or hou.renderMethod.FrameByFrame.
            The default is ROP by ROP: each ROP will render its entire sequence
            before proceeding to the next ROP. If you specify FrameByFrame, all
            ROPs will render the first frame, then the second, etc.

            This parameter is only relevant when rendering ROPs in a dependency
            network.

        ignore_bypass_flags
            If True, renders this node even if its bypass flag is on.

        ignore_lock_flags
            If True, ignores any lock flags on this node and its dependencies.

        verbose
            If True, then the method will print messages during the render. For
            example, a message is printed when each frame starts rendering.

        output_progress
            If True, then the method will print Alfred-style progress messages.
            This argument does not apply if the verbose argument is set  to
            False.
        """

class SceneViewer(PathBasedPaneTab):
    """
    hou.SceneViewer

    REPLACES
      * vieweroption
      * viewlayout
      * viewls
      * viewsnapshot
      * viewsnapshotoption
    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def viewports(self):
        """
        viewports(self) -> tuple of GeometryViewports
        """
        return (GeometryViewport(),)

    def findViewport(self):
        """
        findViewport(self, name) -> GeometryViewport
        """
        return GeometryViewport()

    def curViewport(self):
        """
        curViewport(self) -> hou.GeometryViewport

        Returns this viewer's current viewport.  The current viewport is the one
        containing the mouse cursor.  If the cursor is not in a viewport, then
        the selected, or active, viewport is returned.
        """
        return GeometryViewport()

    def currentState(self):
        """
        currentState(self) -> string

        Returns the name of the viewer's current tool state.
        """
        return ""

    def enterViewState(self, wait_for_exit=False):
        """
        enterViewState(self, wait_for_exit=False)

        Enters the viewer into view tool state. If wait_for_exit is True, then
        the function will not return until the viewer exits the tool.
        """

    def enterCurrentNodeState(self, wait_for_exit=False):
        """
        enterCurrentNodeState(self, wait_for_exit=False)

        Enters the viewer into the node-specific tool state of the last selected
        node. If wait_for_exit is True, then the function will not return until
        the viewer exits the tool.
        """

    def enterTranslateToolState(self, wait_for_exit=False):
        """
        enterTranslateToolState(self, wait_for_exit=False)

        Enters the viewer into translate tool state. This is available only for
        the node contexts that support the move tools. If wait_for_exit is True,
        then the function will not return until the viewer exits the tool.
        """

    def enterRotateToolState(self, wait_for_exit=False):
        """
        enterRotateToolState(self, wait_for_exit=False)

        Enters the viewer into rotate tool state. This is available only for the
        node contexts that support the move tools. If wait_for_exit is True,
        then the function will not return until the viewer exits the tool.
        """

    def enterScaleToolState(self, wait_for_exit=False):
        """
        enterScaleToolState(self, wait_for_exit=False)

        Enters the viewer into scale tool state. This is available only for the
        node contexts that support the move tools. If wait_for_exit is True,
        then the function will not return until the viewer exits the tool.
        """

    def setCurrentState(self, state, wait_for_exit=False,
        generate=hou.stateGenerateMode.Insert, request_new_on_generate=True):
        """
        setCurrentState(self, state, wait_for_exit=False,
        generate=hou.stateGenerateMode.Insert, request_new_on_generate=True)

        Sets the current tool state of the viewer. If wait_for_exit is True,
        then the function will not return until the viewer exits the tool.

        generate
            A hou.stateGenerateMode enumeration value to specify how a new node
            should be generated, inserted inline or into a new branch.

        request_new_on_generate
            Some states reuse the current node whenever possible.  Setting this
            argument to True requests that such states generate a new node.
        """

    def isCreateInContext(self):
        """
        isCreateInContext(self) -> bool
        """
        return True

    def viewportLayout(self):
        """
        viewportLayout(self)
        """

    def setViewportLayout(self, layout):
        """
        setViewportLayout(self, layout)
        """

    def selectObjects(self, prompt='Select objects', sel_index=0,
        allow_drag=False, quick_select=False, use_existing_selection=True,
        allow_multisel=True, allowed_types=('*',), icon=None, label=None):
        """
        selectObjects(self, prompt='Select objects', sel_index=0,
        allow_drag=False, quick_select=False, use_existing_selection=True,
        allow_multisel=True, allowed_types=('*',), icon=None, label=None) ->
        tuple of Nodes

        Document that this can raise hou.OperationInterrupted.
        """
        return (Node(),)

    def selectGeometry(self, prompt='Select geometry', sel_index=0,
        allow_drag=False, quick_select=False, use_existing_selection=True,
        initial_selection = None, initial_selection_type = None, ordered=False,
        geometry_types=(), primitive_types=(), allow_obj_sel=True, icon=None,
        label=None):
        """
        selectGeometry(self, prompt='Select geometry', sel_index=0,
        allow_drag=False, quick_select=False, use_existing_selection=True,
        initial_selection = None, initial_selection_type = None, ordered=False,
        geometry_types=(), primitive_types=(), allow_obj_sel=True, icon=None,
        label=None) -> GeometrySelection
        """
        return GeometrySelection()

    def selectDynamics(self, prompt='Select dynamics objects', sel_index=0,
        allow_objects=True, allow_modifiers=False, quick_select=False,
        use_existing_selection=True, allow_multisel=True, icon=None, label=None):
        """
        selectDynamics(self, prompt='Select dynamics objects', sel_index=0,
        allow_objects=True, allow_modifiers=False, quick_select=False,
        use_existing_selection=True, allow_multisel=True, icon=None, label=None)
        -> tuple of hou.DopData
        """
        return (DopData(),)

    def selectDynamicsPoints(self, prompt='Select dynamics points', sel_index=0,
        quick_select=False, use_existing_selection=True, allow_multisel=True,
        only_select_points=True, icon=None, label=None):
        """
        selectDynamicsPoints(self, prompt='Select dynamics points', sel_index=0,
        quick_select=False, use_existing_selection=True, allow_multisel=True,
        only_select_points=True, icon=None, label=None) -> tuple of
        (hou.DopData, hou.GeometrySelection)
        """
        return (DopData(), GeometrySelection())

    def selectDynamicsPolygons(*args, **kwargs):
        return
    def selectPositions(self, prompt='Click to specify a position',
        number_of_positions=1, connect_positions=True, show_coordinates=True,
        bbox=BoundingBox(), position_type=positionType.WorldSpace, icon=None,
        label=None):
        """
        selectPositions(self, prompt='Click to specify a position',
        number_of_positions=1, connect_positions=True, show_coordinates=True,
        bbox=BoundingBox(), position_type=positionType.WorldSpace, icon=None,
        label=None) -> tuple of Vector3s
        """
        return (Vector3,)

    def snappingMode(self):
        """
        snappingMode(self)
        """

    def setSnappingMode(self, snapping_mode):
        """
        setSnappingMode(self, snapping_mode)
        """

    def isSnappingToTemplates(self):
        """
        isSnappingToTemplates(self)
        """

    def setSnapToTemplates(self, on):
        """
        setSnapToTemplates(self, on)
        """

    def isSnappingToOtherObjects(self):
        """
        isSnappingToOtherObjects(self)
        """

    def setSnapToOtherObjects(self, on):
        """
        setSnapToOtherObjects(self, on)
        """

    def isDepthSnapping(self):
        """
        isDepthSnapping(self)
        """

    def setDepthSnapping(self, on):
        """
        setDepthSnapping(self, on)
        """

    def isOrientingOnSnap(self):
        """
        isOrientingOnSnap(self)
        """

    def setOrientOnSnap(self, on):
        """
        setOrientOnSnap(self, on)
        """

    def isPickingVisibleGeometry(self):
        """
        isPickingVisibleGeometry(self)

        Returns true if the viewer is configured to only pick visible components
        when performing an area-based selection. This option corresponds to the
        matching check box in the component selection button's context menu.
        """

    def setPickingVisibleGeometry(self, on):
        """
        setPickingVisibleGeometry(self, on)

        Turns on or off the option to select only visible components when
        performing area-based selections such as box or brush picking.
        """

    def isGroupPicking(self):
        """
        isGroupPicking(self)

        Returns true if group, attribute, or connectivity information will be
        used to automatically expand selections made in this viewer. This option
        corresponds to the matching check box in the component selection
        button's context menu.
        """

    def setGroupPicking(self, on):
        """
        setGroupPicking(self, on)

        Turns on or off the group, attribute, or connectivity based picking.
        When turned on, the group list gadget is automatically made visible.
        """

    def isWholeGeometryPicking(self):
        """
        isWholeGeometryPicking(self)

        Returns true if selections made in this viewer will automatically expand
        to include the whole geometry. This option corresponds to the matching
        check box in the component selection button's context menu.
        """

    def setWholeGeometryPicking(self, on):
        """
        setWholeGeometryPicking(self, on)

        Turns on or off the option to expand selections made in this viewer to
        include the entire geometry.
        """

    def isSecureSelection(self):
        """
        isSecureSelection(self)

        Returns true if secure selection is turned on in this viewer. This
        option corresponds to the secure selection option in the select tool's
        context menu.
        """

    def setSecureSelection(self, on):
        """
        setSecureSelection(self, on)

        Turns on or off the secure selection option in this viewer.
        """

    def isPickingCurrentNode(self):
        """
        isPickingCurrentNode(self)

        Returns true if selections made in this viewer will pick from the
        Current SOP. If not, the pick occurs on the Display SOP. This option
        corresponds to the current/display option in the component selection
        button's context menu.
        """

    def setPickingCurrentNode(self, on):
        """
        setPickingCurrentNode(self, on)

        Tells this viewer whether picks should be made on the Current SOP or on
        the Display SOP.
        """

    def pickGeometryType(self):
        """
        pickGeometryType(self)

        Returns the type of geometry that will be picked in this viewer. This
        option corresponds to the component types selectable in the component
        selection button's context menu.
        """

    def setPickGeometryType(self, geometry_type):
        """
        setPickGeometryType(self, geometry_type)

        Sets the type of geometry that will be picked in this viewer. This value
        can be changed at any time by the user, or when a selector is invoked.
        """

    def pickStyle(self):
        """
        pickStyle(self)

        Returns the style of area picking currently being used by this viewer.
        This option corresponds to the picking style specified in the select
        tool's context menu.
        """

    def setPickStyle(self, style):
        """
        setPickStyle(self, style)

        Sets the style of area picking to be used by this viewer.
        """

    def pickModifier(self):
        """
        pickModifier(self)

        Returns the manner in which additional selection are combined with the
        existing selection. This option corresponds to the picking modifier in
        the select tool context menu.
        """

    def setPickModifier(self, modifier):
        """
        setPickModifier(self, modifier)

        Sets the method used to modify the existing selection when a new
        selection is made. Modifier keys can still be used to alter this
        behavior. Only the default operation (with no modifier keys) is affected
        by this setting.
        """

    def pickFacing(self):
        """
        pickFacing(self)

        Returns a value indicating whether the user is able to pick front facing
        components, back facing components, or both. This option corresponds to
        the frant and back facing options in the component selection button's
        context menu.
        """

    def setPickFacing(self, facing):
        """
        setPickFacing(self, facing)

        Sets the option of whether to restrict selection to front facing, back
        facing, or either type of components.
        """

    def isGroupListVisible(self):
        """
        isGroupListVisible(self)

        Returns true if the group list gadget has been turned on for this
        viewer. This function only refers to the option to show the group list
        when not selecting groups in the viewer. In that case the group list
        will be visible, but this function may still return False.
        """

    def setGroupListVisible(self, on):
        """
        setGroupListVisible(self, on)

        Turns on or off the group list gadget for this viewer.
        """

    def isGroupListColoringGeometry(self):
        """
        isGroupListColoringGeometry(self)

        Returns true if the group list gadget is configured to color geometry in
        the viewer based on group membership or attribute value.
        """

    def setGroupListColoringGeometry(self, on):
        """
        setGroupListColoringGeometry(self, on)

        Turns on or off the group list gadget to coloring of geometry in the
        viewer based on group membership or attribute value.
        """

    def isGroupListShowingEmptyGroups(self): return
    def setGroupListShowingEmptyGroups(self): return
    def groupListSize(self):
        """
        groupListSize(self)

        Returns the width and height in inches of the group list gadget.
        """

    def setGroupListSize(self, width, height):
        """
        setGroupListSize(self, width, height)

        Sets the size in inches of the group list gadget.
        """

    def groupListType(self):
        """
        groupListType(self)

        Returns the type of component listed in the group list gadget.
        """

    def setGroupListType(self, group_list_type):
        """
        setGroupListType(self, group_list_type)

        Sets the type of component listed in the group list gadget. This can be
        set to a specific component type or to follow the current component
        selection type.
        """

    def groupListMask(self):
        """
        groupListMask(self)

        Returns true if the group list gadget has been turned on for this
        viewer.
        """

    def setGroupListMask(self, mask):
        """
        setGroupListMask(self, mask)

        Sets the mask value in the group list gadget for this viewer. This can
        be a filter applied to the comonent groups, or an attribute name
        (starting with an @ charater), or a connectivity type.
        """

    def constructionPlane(self):
        """
        constructionPlane(self) -> hou.ConstructionPlane

        Return the construction plane (or grid) in the perspective viewport of
        this viewer.

        See hou.ConstructionPlane for more information.
        """
        return ConstructionPlane()

class Selector(object):
    """
    hou.Selector

    Describes how Houdini should prompt the user to choose geometry in the
    viewport when creating a new SOP node instance.

    Use hou.SopNodeType.addSelector to create a selector and add it to a SOP
    node type.  When the user creates a new instance of a node type in the
    viewer, Houdini will invoke all of its selectors sequentially.  Each
    selector prompts the user to select geometry.  When all selectors have
    been invoked, Houdini creates the new node and each selector connects
    its input nodes and fills in any group parameters on the node to match
    what was selected.
    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def name(self):
        """
        name(self) -> str

        Return the name of this selector.  The name is unique within the node
        type it is attached to.
        """
        return ''

    def nodeType(self):
        """
        nodeType(self) -> hou.NodeType

        Return the node type that this selector is attached to.
        """
        return NodeType()

    def selectorType(self):
        """
        selectorType(self) -> str

        Return the name of the type of selector to use.  Different selectors
        have different behaviors.  For example "prims" will select only
        primitives and is used, for example, by the cookie SOP.  "points" will
        select only points, and is used by SOPs like the point SOP.
        "everything" will select any geometry, and is used for SOPs like
        "xform" and "blast".

        See hou.SopNodeType.selectors for example code that returns all the
        available selector types.
        """
        return ''

    def geometryTypes(self):
        """
        geometryTypes(self) -> tuple of hou.geometryType enum values

        Return a tuple of hou.geometryType enumeration values.  This tuple
        describes which geometry entities (e.g. points, primitives, edges, etc.)
        the selector allows.  Note that this list is a property of the selector
        type and you cannot specify it when creating a new selector. Instead,
        you must choose a selector type with the desired geometry types.

        See hou.SopNodeType.selectors for a function that returns a list of all
        the selector types.  The following function will return the geometry
        types for a particular selector type.
          def geometryTypesForSelectorType(selector_type):
              '''Given a selector type name, return the tuple of geometry types it
                 will select.'''
              # First find a node type that uses this selector.
              for node_type in hou.sopNodeTypeCategory().nodeTypes().values():
                  # Skip manager nodes, like shopnets, ropnets, etc.
                  if not isinstance(node_type, hou.SopNodeType):
                      continue

                  for selector in node_type.selectors():
                      if selector_type == selector.selectorType():
                          return selector.geometryTypes()

              # The selector type name is invalid.
              raise hou.OperationFailed("Invalid selector type")
        """
        return geometryType()

    def groupTypeParmValues(self):
        """
        groupTypeParmValues(self) -> tuple of int

        Return a tuple of indices mapping geometry types to indices on the
        geometry type parameter menu.

        Whether or not a selector is ordered is a property of the selector type,
        and you cannot specify it when creating a new selector.  Instead, you
        must choose the appropriate selector type.  For example, the
        "everything" selector can select primitives, primitive groups, points,
        point groups, edges, and breakpoints.  It sets a group type menu
        parameter to match the type of selection, and this menu must have the
        entries "Guess from Group", "Breakpoints", "Edges", "Points",
        and "Primitives".  For an "everything" selector, this method returns
        (4, 4, 3, 3, 2, 1), mapping the geometry element types to 0-based
        entries in the menu.  For example, if the user selects edges, the
        selector will look up the fifth element (2) and set the menu parameter
        to the item at index 2 ("Edges").

        The length of the tuple of ints is the same as len(self.geometryTypes).
        If this selector is not intended to work with a menu parameter, each
        value in the tuple will be -1.

        See also hou.Selector.geometryTypes.
        """
        return (0,)

    def ordered(self):
        """
        ordered(self) -> bool

        Return whether or not this selector preserves the order in which the
        user selected the geometry.

        For example, the selector is for points and the user clicks on points 1,
        0, and 2, in that order, an ordered selector will set the SOP's group
        parameter to "1 0 2", while an unordered selector will set it to
        "0-2".  For SOPs where the order of the group selector matters, use
        ordered selectors.

        Whether or not a selector is ordered is a property of the selector type,
        and you cannot specify it when creating a new selector.  Instead, you
        must choose the appropriate selector type.  For example, "prims" is an
        unordered selector type, but "ordered_prims" is ordered.  See
        hou.Selector.geometryTypes for a function that can be adapted to
        determine if a selector is ordered, and see hou.SopNodeType.selectors
        for a function to list all the selector types.
        """
        return True

    def prompt(self):
        """
        prompt(self) -> str

        A string to display at the bottom of the viewer to instruct the user
        what to select.
        """
        return ''

    def primitiveTypes(self):
        """
        primitiveTypes(self) -> tuple of hou.primType enum values

        Return a sequence of hou.primType enumeration values to specify what
        primitive types are allowed.

        Note that if you pass an empty sequence for the primitive_types
        parameter in hou.SopNodeType.addSelector and then call this method on
        the newly-created selector, this method will return a tuple of all
        primitive types.
        """
        return primType()

    def groupParmName(self):
        """
        groupParmName(self) -> str

        Return the name of the SOP node parameter containing the group field.
        The selector will set this parameter to the string representing the
        points, primitives, edges, etc. chosen by the user in the viewer. It is
        typically named "group".
        """
        return ''

    def groupTypeParmName(self):
        """
        groupTypeParmName(self) -> str

        Return the name of the SOP node parameter containing the menu of
        geometry types.  If the selector can select multiple geometry types
        (e.g. points or primitives), it will set this parameter to match the
        type of geometry the user chose.  The transform SOP, for example, has a
        Group Type parameter that tells it how to interpret the string in the
        Group parameter.  For such selectors, the parameter is typically named
        "grouptype".  For selectors that do not allow multiple geometry types,
        this parameter is usually "".
        """
        return ''

    def inputIndex(self):
        """
        inputIndex(self) -> int

        Return the index of the input connector on the SOP node where the
        selector should wire input SOPs.  A cookie SOP, for example, has two
        input connectors and one selector for each input connector.
        """
        return 0

    def inputRequired(self):
        """
        inputRequired(self) -> bool

        Return whether or not this input is required or optional.  If the user
        does not select any geometry and the input is not required, the selector
        will not connect anything to its input connector.
        """
        return True

    def allowDragging(self):
        """
        allowDragging(self) -> bool

        Return whether the user is allowed to select the geometry and begin
        manipulating the handles with a single mouse click.  A transform SOP,
        for example, lets you select the geometry and drag it right away.
        Dragging the geometry forces the selector to finish immediately, the
        selector connects the input and sets the group parameter, and subsequent
        mouse movements are passed to the handle which translates the geometry
        by changing parameter values.
        """
        return True

    def emptyStringSelectsAll(self):
        """
        emptyStringSelectsAll(self) -> bool

        Return whether or not use an empty string in the group parameter if the
        user selects all the geometry.  If False, Houdini will place an asterisk
        (*) in the group parameter when the user selects all the geometry.  Most
        SOPs use an empty string.
        """
        return True

    def extraInfo(self):
        """
        extraInfo(self) -> str

        Returns an optional extra info string that contains additional settings.
        """
        return ''

    def destroy(self):
        """
        destroy(self)

        Remove this selector from its node type.

        See also hou.SopNodeType.addSelector.

        REPLACES
            omsunbind command        """

class SeparatorParmTemplate(ParmTemplate):
    """
    hou.SeparatorParmTemplate

    Template for a separator parameter.  Separators are just lines between
    parameters and do not store any parameter values.


    """

    def __init__(self, name, is_hidden, tags):
        """
        __init__(self, name, is_hidden=False, tags={})

        Creates a new SeparatorParmTemplate instance.

        name
            See hou.ParmTemplate.name for more information.

        is_hidden
            See hou.ParmTemplate.isHidden for more information.

        tags
            See hou.ParmTemplate.tags for more information.
        """

class Shelf(ShelfElement):
    """
    hou.Shelf
    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def tools(self):
        """
        tools(self) -> tuple of Tools
        """
        return (Tool(),)

    def setTools(self, tools):
        """
        setTools(self, tools)
        """

    def destroy(self):
        """
        destroy(self)
        """

class ShelfDock(object):
    """
    hou.ShelfDock

    Represents the shelf area at the top of the screen, within which shelf
    sets and shelf tabs exist.

    The shelf docking area on any given desktop has space for any number of
    shelf sets, each of which may contain shelf tabs.

    RELATED
      * hou.Desktop
    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def shelfSets(self):
        """
        shelfSets(self) -> tuple of hou.ShelfSet

        Returns a list of the shelf sets in the current shelf dock.
        """
        return ShelfSet()

    def iconsize(self):
        """
        iconsize(self) -> (int, int)

        Returns the height and width, in pixels, of the icons in the shelf at
        the current "Display Tools As" setting.
        """
        return (0,0)

    def show(self, on):
        """
        show(self, on)

        Show or hide the shelf dock by uncollapsing or collapsing its stow bar.

        REPLACES
            shelfdock command        """

class ShelfSet(ShelfElement):
    """
    hou.ShelfSet
    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def shelves(self):
        """
        shelves(self) -> tuple of Shelf
        """
        return (Shelf(),)

    def setShelves(self, shelves):
        """
        setShelves(self, shelves)
        """

    def destroy(self):
        """
        destroy(self)
        """

class ShellIO(object):
    """
    hou.ShellIO
    """

    def __init__(self): raise AttributeError, "No constructor defined"

    def readline(*args):
        """
        readline(self, size=-1) -> string
        """
        return ''

    def addCloseCallback(self, callback):
        """
        addCloseCallback(callback)

        Register a Python callback to be called whenever the last Houdini Python
        Shell is closed.

        callback
            Any callable Python object that expects no parameters.  It could be
            a Python function, a bound method, or any object implementing
            __call__.

          def cleanup():
              # Here is where you would run your cleanup code when
              # the Python shell has closed.
              pass
          hou.ui.shellIO().addCloseCallback(cleanup)

        You might use this function to cleanly terminate any mechanisms that are
        dependent on the Python shell.  For example, you can register a callback
        which disables an object from logging output messages to the shell.
        """

    def removeCloseCallback(self,callback):
        """
        removeCloseCallback(callback)

        Remove a Python callback that was previously registered with
        hou.ShellIO.addCloseCallback.  See hou.ShellIO.addCloseCallback for more
        information.

        Raises hou.OperationFailed if the callback was not previously
        registered.
        """
        return _hou.ShellIO_removeCloseCallback(*args)

    def CloseCallbacks(self): return
    def addExitCallback(self): return
    def removeExitCallback(self): return
    def exitCallbacks(self): return
    def write(self, data):
        """
        write(self, data)
        """

    def getAndClearWrittenData(self):
        """
        getAndClearWrittenData(self) -> string
        """
        return ''

    def addDataForReading(self, data):
        """
        addDataForReading(self, data)
        """
        return

    def addEOFForReading(self):
        """
        addEOFForReading(self)
        """

    def interruptShellThread(self):
        """
        interruptShellThread(self)
        """

    def isWaitingForCommand(self):
        """
        isWaitingForCommand(self) -> bool
        """
        return True

    def setIsWaitingForCommand(self, on):
        """
        setIsWaitingForCommand(self, on)
        """

    def isatty(self):
        """
        isatty(self) -> bool

        Implemented as part of the "file-like object" interface.
        """
        return True

    def flush(self): return

class shelves(object):
    """
    hou.shelves
    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def shelfSets(self):
        """
        shelfSets() -> dict of str to hou.ShelfSet
        """
        return {"":ShelfSet()}

    def shelves(self):
        """
        shelves() -> dict of str to hou.Shelf
        """
        return {"":Shelf()}

    def tools(self):
        """
        tools() -> dict of str to hou.Tool
        """
        return {"":Tool()}

    def isToolDeleted(self): return True
    def loadFile(self,file_path):
        """
        loadFile(file_path)

        Read a shelf file and create shelves and tools defined in that file.

        file_path
            File to load.
        """

    def reloadShelfFiles(self):
        """
        reloadShelfFiles()

        Refresh the shelf definitions by reloading the shelf files found in the
        search path.
        """

    def runningTool(self):
        """
        runningTool() -> hou.Tool or None
        """
        return Tool()

    def newShelfSet(file_path=None, name=None, label=None):
        """
        newShelfSet(file_path=None, name=None, label=None) -> hou.ShelfSet
        """
        return ShelfSet()

    def newShelf(file_path=None, name=None, label=None):
        """
        newShelf(file_path=None, name=None, label=None) -> hou.Shelf
        """
        return Shelf()

    def newTool(file_path=None, name=None, label=None, script=None,
        language=hou.scriptLanguage.Python, icon=None, help=None, help_url=None,
        network_categories=(), viewer_categories=(), cop_viewer_categories=(),
        network_op_type=None, viewer_op_type=None, locations=()):
        """
        newTool(file_path=None, name=None, label=None, script=None,
        language=hou.scriptLanguage.Python, icon=None, help=None, help_url=None,
        network_categories=(), viewer_categories=(), cop_viewer_categories=(),
        network_op_type=None, viewer_op_type=None, locations=()) -> hou.Tool
        """
        return Tool()

    def _newAssetTool(*args, **kwargs): return
    def defaultFilePath(self):
        """
        defaultFilePath() -> str
        """
        return ''

    def defaultToolName(self): return

class ShopNode(Node):
    """
    hou.ShopNode

    The base class for all SHOP nodes in Houdini.  An instance of this class
    corresponds to exactly one instance of a node in Houdini.

    See hou.Node for more information.


    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def shaderString(self, render_type=None):
        """
        shaderString(self, render_type=None) -> str

        Return the shader string generated by this shader for the given render
        type. This string is written to the file that is read in by the
        renderer.

        render_type
            A string representing the renderer.  If this string is empty or is
            "*", Houdini uses the default render type for this shader.
            Possible render types include "VMantra" (Mantra), "RIB"
            (RenderMan),  "OGL" (OpenGL), "OGL2" (OpenGL 2), and "I3D"
            (Image 3D).

            You can use hou.ShopNodeType.renderMask to determine the render
            types supported by this SHOP's type. You can also use
            hou.ShopNodeTypeCategory.renderers to get all the possible render
            types. Note that some SHOP types, like the properties SHOP or the
            switch SHOP, have a render mask of "*" to indicate that they will
            work with any shader type.

        If you pass in an unknown or unsupported render type, this method
        returns an empty string.

          >>> for node_type_name in ("v_plastic", "ri_matte"):
          ...     hou.node("/shop").createNode(node_type_name)

          <hou.ShopNode of type v_plastic at /shop/v_plastic1>
          <hou.ShopNode of type ri_matte at /shop/ri_matte1>

          >>> for shop in hou.node("/shop").children():
          ...     for render_type in shop.type().renderMask().split():
          ...         print shop.name(), "supports", render_type
          ...         print "    shader_string:", shop.shaderString(render_type)
          ...         print
          v_plastic1 supports VMantra
              shader_string: opdef:/Shop/v_plastic

          v_plastic1 supports OGL
              shader_string: /shop/v_plastic1

          ri_matte1 supports RIB
              shader_string: "matte"

          ri_matte1 supports OGL
              shader_string: /shop/ri_matte1

        REPLACES
            shopstring function        """
        return ''

    def shaderCode(self): return
    def shaderName(self, as_otl_path=True, shader_type_name=None):
        """
        shaderName(self, as_otl_path=True, shader_type_name=None) -> str

        Return the name of the shader inside this SHOP.  If as_otl_path is True,
        returns an opdef: path to the SHOP type. The shader_type_name is a
        string indicating the shader context type to use; some nodes may provide
        several shader types, and each may have a different name. This is
        applicable only to multi-context shader nodes, such as a vopnet material
        shop.
        """
        return ''

    def supportedRenderers(self):
        """
        supportedRenderers(self) -> tuple of str

        Returns a list of strings describing the renderers this shader supports.
        """
        return ('',)

    def definingVopNetNode(self):
        """
        definingVopNetNode(self) -> hou.VopNetNode or None

        If this SHOP is defined by a VOP network, return the hou.VopNetNode that
        defines it.  Otherwise, return None.
        """
        return VopNetNode()

    def shaderType(self):
        """
        shaderType(self) -> hou.shaderType enum value

        Returns a hou.shaderType indicating the type of this shader.

        Note that this method is a shortcut for self.type().shaderType(), which
        calls hou.ShopNodeType.shaderType.
        """
        return shaderType()

    def coshaderNodes(self, parm_name):
        """
        coshaderNodes(self, parm_name) -> tuple of hou.ShopNode

        If this SHOP has a co-shader parameter given by parm_name it may also
        have an input corresponding to that parameter. This function will return
        the tuple of hou.ShopNode assigned as co-shaders to this SHOP node
        either via connected input or the operator node path specified in that
        parameter.

        If the parameter represents a single co-shader, the array will contain
        at most one element, however if the parameter refers to a co-shader
        array then the tuple may contain more than one element.

        parm_name
            Co-shader parameter name specifying the co-shader shop to return.
        """
        return (ShopNode(),)

class ShopNodeType(NodeType):
    """
    hou.ShopNodeType

    This kind of NodeType contains extra attributes specific to SHOP nodes.
    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def shaderType(self):
        """
        shaderType(self) -> [Hom:hou.shaderType] enum value

        Return the type of shader for this SHOP type.  For example, this shop
        type might be a surface shader or a displacement shader.  See
        hou.shaderType for the possible shader types.

        See also hou.ShopNode.shaderType.
        """
        return shaderType()

    def renderMask(self):
        """
        renderMask(self) -> string

        Return a string with space-separated names of the renderers that this
        SHOP type supports.  Note that some SHOP types, like the switch SHOP,
        return "*" to indicate that they support all renderers.

        See hou.ShopNode.shaderString for an example.
        """
        return ''

class SopNode(Node):
    """
    hou.SopNode

    Represents a surface node.

    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def geometry(self):
        """
        geometry(self) -> hou.Geometry

        Return the geometry computed by this SOP node.  If the SOP has not
        already cooked, this method will cook the SOP.

        The returned Geometry object is not frozen.  See hou.Geometry.freeze for
        more information on frozen Geometry objects.
        """
        return Geometry()

    def geometryAtFrame(self):
        """
        geometryAtFrame(self, frame) -> hou.Geometry

        Return the geometry computed by this SOP node cooked at the specified
        frame.  If the SOP has not already cooked, this method will cook the
        SOP.

        The returned Geometry object is frozen.  See hou.Geometry.freeze for
        more information on frozen Geometry objects.
        """
        return Geometry()
    def curPoint(self):
        """
        curPoint(self) -> Point

        Return this node's current point.  You would typically call this method
        from an expression on a node that iterates over a set of points and re-
        evaluates the parameter for each point.

        This method lets you implement the Python equivalent of Hscript's local
        variables.  Many of Houdini's SOPs iterate over a set of points, and for
        each point they store the current point and then evaluate a parameter.
        If the parameter contains a local variable, Houdini looks up the SOP's
        current point when evaluating that variable.  For example, the point SOP
        evaluates the t parameter for each point, and sets that point's position
        according to the value of the parameter.  If that parameter contains,
        say, the local variable $TX, it will evaluate to the x position of the
        current point.

        This method gives you access to the hou.Point representation of
        Houdini's current point.  Using this point you could evaluate the
        position, an attribute value, or do more complex operations like compute
        the distance from the point to the origin.

        Raises hou.OperationFailed if you call this method from outside a SOP
        parameter expression, or if the SOP does not support local variables.

        The following lists Python equivalents for some point-related Hscript
        expression local variables.  Note that you can also access local
        variables from Python using hou.lvar.
          # $PT (Hscript expression) or lvar('PT') (Python):
          pwd().curPoint().number()

          # $NPT (Hscript expression) or lvar('NPT') (Python):
          len(pwd().geometry().iterPoints())

          # $TX (Hscript expression) or lvar('TX') (Python):
          pwd().curPoint().position()[0]

          # $WEIGHT (Hscript expression) or lvar('WEIGHT`) (Python):
          pwd().curPoint().position()[3]

          # $CR (Hscript expression) or lvar('CR') (Python):
          pwd().curPoint().attribValue("Cd")[0]

          # $ID (Hscript expression) or lvar('ID') (Python):
          pwd().curPoint().attribValue("id")

          # $LIFE (Hscript expression) or lvar('LIFE') (Python):
          pwd().curPoint().attribValue("life")

          # $VX (Hscript expression) or lvar('VX') (Python):
          pwd().curPoint().attribValue("v")[0]
        """
        return Point()

    def setCurPoint(self, point_or_none):
        """
        setCurPoint(self, point_or_none)

        Set this node's current point.  You can only call this method from a
        Python-defined SOP.

        See hou.SopNode.curPoint for an explanation of a SOP's current point.
        You would use this method to set the current point from inside a SOP
        written in Python, before you evaluate a parameter containing a local
        variable referring to the current point.  See hou.Geometry.globPoints
        for an example.

        Note that you can set the current point to None.  In this case,
        subsequent calls to hou.SopNode.curPoint will raise hou.OperationFailed.
        After a Python SOP is done cooking, Houdini will automatically set the
        current point back to None.

        Raises hou.OperationFailed if called from outside a Python-defined SOP.
        """

    def curPrim(self):
        """
        curPrim(self) -> Prim

        Return this node's current primitive.  You would typically call this
        method from an expression on a node that iterates over a set of
        primitives and re-evaluates the parameter for each primitive.

        See hou.SopNode.curPoint for more information.

        The following lists Python equivalents for some primitive-related
        Hscript expression local variables.  Note that you can also access local
        variables from Python using hou.lvar.
          # $PR (Hscript expression) or lvar('PR') (Python):
          pwd().curPrim().number()

          # $NPR (Hscript expression) or lvar('NPR') (Python):
          len(pwd().geometry().iterPrims())

          # $NX (Hscript expression) or lvar('NX') (Python):
          pwd().curPrim().attribValue("N")[0]
          pwd().curPrim().normal()[0]

          # $CR (Hscript expression) or lvar('CR') (Python):
          pwd().curPrim().attribValue("Cd")[0]
        """
        return Prim()

    def setCurPrim(self, prim_or_none):
        """
        setCurPrim(self, prim_or_none)

        Set this node's current primitive.  You can only call this method from a
        Python-defined SOP.  See hou.SopNode.setCurPoint for more information.
        """

    def curVertex(self):
        """
        curVertex(self) -> Vertex

        Return this node's current vertex.  You would typically call this method
        from an expression on a node that iterates over a set of primitive
        vertices and re-evaluates the parameter for each vertex.

        See hou.SopNode.curPoint for more information.

        Note that hou.SopNode.curPrim returns the primitive containing this
        vertex returned by this method.

        The following lists Python equivalents for some vertex-related Hscript
        expression local variables.  Note that you can also access local
        variables from Python using hou.lvar.
          # $VTX (Hscript expression) or lvar('VTX') (Python):
          pwd().curVertex().number()

          # $NVTX (Hscript expression) or lvar('NVTX') (Python):
          pwd().curPrim().numVertices()
        """
        return Vertex()

    def setCurVertex(self, vertex_or_none):
        """
        setCurVertex(self, vertex_or_none)

        Set this node's current primitive.  You can only call this method from a
        Python-defined SOP.  See hou.SopNode.setCurPoint for more information.

        Note that setting the current vertex will also set the current primitive
        to the primitive containing the vertex.
        """

    def isBypassed(self):
        """
        isBypassed(self) -> bool

        Return whether this node's bypass flag is on.

        REPLACES
            opflag function
            opget command        """
        return True

    def bypass(self, on):
        """
        bypass(self, on)

        Turn this node's bypass flag on or off, making this node have no effect.

        REPLACES        """

    def isDisplayFlagSet(self):
        """
        isDisplayFlagSet(self) -> bool

        Return whether this node's display flag is on.

        REPLACES
            opflag function
            opget command        """
        return True

    def setDisplayFlag(self, on):
        """
        setDisplayFlag(self, on)

        Turn this node's display flag on or off.

        REPLACES        """

    def isRenderFlagSet(self):
        """
        isRenderFlagSet(self) -> bool

        Return whether this node's render flag is on.

        REPLACES
            opflag function
            opget command        """
        return True

    def setRenderFlag(self, on):
        """
        setRenderFlag(self, on)

        Turns this node's render flag on or off.

        REPLACES        """

    def isTemplateFlagSet(self):
        """
        isTemplateFlagSet(self) -> bool

        Returns whether this node's template flag is on.  Templated SOPs are
        display as wireframe in the viewport, and you cannot select geometry
        from them.

        REPLACES
            opflag function
            opget command        """
        return True

    def setTemplateFlag(self, on):
        """
        setTemplateFlag(self, on)

        Turns this node's template flag on or off.

        REPLACES        """

    def isSelectableTemplateFlagSet(self):
        """
        isSelectableTemplateFlagSet(self) -> bool

        Return whether this node's selectable template flag is on.  A selectable
        template displays like the display SOP in the viewport, and you can
        select it when choosing points, primitives, etc.  Note that only the
        display SOP will be included in the containing geometry object or SOP
        subnet, however, so selectable templates are only visible while working
        inside their SOP network.

        REPLACES
            opflag function
            opget command        """

    def setSelectableTemplateFlag(self, on):
        """
        setSelectableTemplateFlag(self, on)

        Turn this node's selectable template flag on or off.

        REPLACES        """

    def isHighlightFlagSet(self):
        """
        isHighlightFlagSet(self) -> bool

        Return whether this node's highlight flag is on.  When this flag is
        turned on, Houdini displays portions of the geometry in yellow in the
        viewport, to indicate the operations performed by this SOP.

        REPLACES
            opflag function
            opget command        """
        return True

    def setHighlightFlag(self, on):
        """
        setHighlightFlag(self, on)

        Turn this node's highlight flag on or off.

        REPLACES        """

    def isSoftLocked(self):
        """
        isSoftLocked(self) -> bool

        Return whether this node is soft-locked.  A soft-locked node stores
        position delta information , preventing all but a small set of manual
        modeling changes from being made.

        REPLACES
            opflag function
            opget command        """
        return True

    def setSoftLocked(self, on):
        """
        setSoftLocked(self, on)

        Turns this node's soft-lock flag on or off, allowing a subset of manual
        modeling changes to be made to the locked node.

        REPLACES        """

    def isHardLocked(self):
        """
        isHardLocked(self) -> bool

        Return whether this node is hard-locked.  A hard-locked node stores its
        data inside the node, and no longer responds to parameter or input node
        changes.

        REPLACES
            opflag function
            opget command        """
        return True

    def setHardLocked(self, on):
        """
        setHardLocked(self, on)

        Turn this node's hard-lock flag on or off.  Locking a node saves its
        current cooked geometry into the node.  If you unlock a hard-locked
        node, it will discard its locked geometry data and recook, computing its
        geometry from its inputs and parameters.

        REPLACES        """

    def isUnloadFlagSet(self):
        """
        isUnloadFlagSet(self) -> bool

        Returns whether this node's unload flag is on.

        REPLACES
            opflag function
            opget command        """

    def setUnloadFlag(self, on):
        """
        setUnloadFlag(self, on)

        Turns this node's unload flag on or off.

        REPLACES        """

    def displayNode(self):
        """
        displayNode(self) -> Node

        If this is a subnet SOP, return the SOP inside the subnet with its
        display flag on.  Otherwise, return None.
        """
        return Node()

    def renderNode(self):
        """
        renderNode(self) -> hou.Node

        If this is a subnet SOP, return the SOP inside the subnet with its
        render flag on.  Otherwise, return None.
        """
        return Node()

class SopNodeType(NodeType):
    """
    hou.SopNodeType

    This kind of NodeType contains extra attributes specific to SOP nodes.
    """
    def __init__(self): raise AttributeError, "No constructor defined"
    def selectors(self, selector_indices=()):
        """
        selectors(self, selector_indices=()) -> tuple of hou.Selector

        Return all the selectors for this node type.  See
        hou.SopNodeType.addSelector and hou.Selector for more information.

          def sopSelectorTypes():
              '''Return a list of all the SOP selector type names.'''
              selector_types = []
              for node_type in hou.sopNodeTypeCategory().nodeTypes().values():
                  # Skip manager nodes, like shopnets, ropnets, etc.
                  if not isinstance(node_type, hou.SopNodeType):
                      continue

                  for selector in node_type.selectors():
                      selector_type = selector.selectorType()
                      if selector_type not in selector_types:
                          selector_types.append(selector_type)
              selector_types.sort()
              return selector_types

          def sopTypeNamesUsingSelector(selector_type):
              '''Given the name of a selector type, return a list of all the SOP
                 node types using that selector.'''
              node_types = []
              for node_type in hou.sopNodeTypeCategory().nodeTypes().values():
                  # Skip manager nodes, like shopnets, ropnets, etc.
                  if not isinstance(node_type, hou.SopNodeType):
                      continue

                  for selector in node_type.selectors():
                      if selector.selectorType() == selector_type:
                          node_types.append(node_type)

              result = [node_type.name() for node_type in node_types]
              result.sort()
              return result

        REPLACES
            omsbindinfo command
            omsls command
            omswhere command        """
        return (Selector(),)

    def addSelector(self, name, selector_type, prompt='Select components',
        primitive_types=(), group_parm_name=None, group_type_parm_name=None,
        input_index=0, input_required=True, allow_dragging=False,
        empty_string_selects_all=True):
        """
        addSelector(self, name, selector_type, prompt='Select components',
        primitive_types=(), group_parm_name=None, group_type_parm_name=None,
        input_index=0, input_required=True, allow_dragging=False,
        empty_string_selects_all=True) -> hou.Selector

        Add a selector to this SOP node type.  When the user creates a new
        instance of this SOP in the viewer, Houdini will invoke all the
        selectors, wait for the user to select geometry, and then connect input
        SOPs and fill in group parameters to match what was selected.

        name
            A name to give this selector.  The name must be unique within this
            node type.

        selector_type
            The name of the type of selector to use.  Different selectors have
            different behaviors.  For example "prims" will select only
            primitives and is used, for example, by the cookie SOP.  "points"
            will select only points, and is used by SOPs like the point SOP.
            "everything" will select any geometry, and is used for SOPs like
            "xform" and "blast".

        prompt
            A string to display at the bottom of the viewer to instruct the user
            what to select.

        primitive_types
            A sequence of hou.primType enumeration values to specify what
            primitive types are allowed.  This parameter has no effect if the
            selector does not select primitives.  If this sequence is empty, all
            primitive types will be allowed.

        group_parm_name
            The name of the SOP node parameter containing the group field. The
            selector will set this parameter to the string representing the
            points, primitives, edges, etc. chosen by the user in the viewer. If
            None, the selector will look for a parameter named "group".

        group_type_parm_name
            The name of the SOP node parameter containing the menu of geometry
            types.  If the selector can select multiple geometry types (e.g.
            points or primitives), it will set this parameter to match the type
            of geometry the user chose.  The transform SOP, for example, has a
            Group Type parameter that tells it how to interpret the string in
            the Group parameter.  If None, the selector will look for a
            parameter named "grouptype".

        input_index
            The index of the input connector on the SOP node where the selector
            should wire input SOPs.  A cookie SOP, for example, has two input
            connectors.  It has two selectors, one for each input connector.

        input_required
            Whether or not this input is required or optional.  If the user does
            not select any geometry and the input is not required, the selector
            will not wire anything to its input connector.

        allow_dragging
            Whether the user is allowed to select the geometry and begin
            manipulating the handles with a single mouse drag.  A transform SOP,
            for example, lets you select the geometry and drag it right away to
            transform it.  Dragging the geometry forces the selector to finish
            immediately, the selector connects the input and sets the group
            parameter, and subsequent mouse movements are passed to the handle
            which translates the geometry by changing parameter values.

        empty_string_selects_all
            Whether or not to use an empty string in the group parameter if the
            user selects all the geometry.  If False, Houdini will place an
            asterisk (*) in the group parameter when the user selects all the
            geometry.  Most SOPs use an empty string.

        You would typically call this method from the shelf tool script of a
        digital asset.  For example, you might put the following in the Tools
        script section of a Python sop that transforms points (having a
        parameter named group):

          hou.sopNodeTypeCategory().nodeTypes()['$HDA_NAME'].addSelector(
              "Points to Transform",
              "points",
              prompt="Select the points to transform and press Enter to complete",
              group_parm_name="group")

        See also hou.Geometry.globPoints and hou.Geometry.globPrims for
        information on how to parse the strings the selector puts in the group
        field.

        See also hou.Selector.

        REPLACES
            omsbind command        """

class StringKeyframe(BaseKeyframe):
    """
    hou.StringKeyframe


    """

    def __init__(self, *args):
        """
        hou.StringKeyframe
        """
    def evaluatedType(self):
        """
        evaluatedType(self) -> hou.parmData enum value
        """
        return parmData()

class StringParmTemplate(ParmTemplate):
    """
    hou.StringParmTemplate

    Describes a parameter tuple containing string values.  These values can
    be arbitrary strings or references to files or nodes

    Note that string parameters may also be menu parameters.  String
    parameters with menus are different from hou.MenuParmTemplate objects
    because menu parm templates evaluate to integers.


    """

    def __init__(self, name, label, num_components, default_value=(),
        naming_scheme=hou.parmNamingScheme.Base1,
        string_type=hou.stringParmType.Regular, file_type=hou.fileType.Any,
        menu_items=(), menu_labels=(), icon_names=(),
        item_generator_script=None, item_generator_script_language=None,
        menu_type=hou.menuType.Normal, disable_when=None, is_hidden=False,
        is_label_hidden=False, join_with_next=False, help=None,
        script_callback=None,
        script_callback_language=hou.scriptLanguage.Hscript, tags={},
        default_expression=(), default_expression_language=()):
        """
        __init__(self, name, label, num_components, default_value=(),
        naming_scheme=hou.parmNamingScheme.Base1,
        string_type=hou.stringParmType.Regular, file_type=hou.fileType.Any,
        menu_items=(), menu_labels=(), icon_names=(),
        item_generator_script=None, item_generator_script_language=None,
        menu_type=hou.menuType.Normal, disable_when=None, is_hidden=False,
        is_label_hidden=False, join_with_next=False, help=None,
        script_callback=None,
        script_callback_language=hou.scriptLanguage.Hscript, tags={},
        default_expression=(), default_expression_language=())

        Construct a new StringParmTemplate.

        name
            See hou.ParmTemplate.name for more information.

        label
            See hou.ParmTemplate.label for more information.

        num_components
            See hou.ParmTemplate.numComponents for more information.

        default_value
            See the defaultValue method for more information.

        string_type
            See the stringType method for more information.  This parameter
            determines whether the parm template is for arbitrary strings, node
            references, or file references.

        file_type
            See the fileType method for more information.  This parameter
            determines the file type when string_type is
            hou.stringParmType.FileReference.

        look
            See hou.ParmTemplate.look for more information.

        naming_scheme
            See hou.ParmTemplate.namingScheme for more information.

        menu_items
            See the menuItems method for more information.  Note that
            num_components must be 1 if menu items are supplied.

        menu_labels
            See the menuLabels method for more information.

            If this parameter is not given, it defaults to the value of the
            menu_items parameter.

        icon_names
            See the iconNames method for more information.

            If this parameter is an empty tuple, the menu will not contain
            icons.

        item_generator_script
            See the itemGeneratorScript method for more information.  for more
            information.  Note that num_components must be 1 if a script is
            given.

        item_generator_script_language
            See the itemGeneratorScriptLanguage method for more information.  If
            this parameter is None it defaults to hou.scriptLanguage.Python.

        menu_type
            See the menuType method for more information.

        disable_when
            See hou.ParmTemplate.disableWhen for more information.

        is_hidden
            See hou.ParmTemplate.isHidden for more information.

        is_label_hidden
            See hou.ParmTemplate.isLabelHidden for more information.

        join_with_next
            See hou.ParmTemplate.joinsWithNext for more information.

        help
            See hou.ParmTemplate.help for more information.

        script_callback
            See hou.ParmTemplate.scriptCallback for more information.

        script_callback_language
            See hou.ParmTemplate.scriptCallbackLanguage for more information.

        tags
            See hou.ParmTemplate.tags for more information.

        default_expression
            See the defaultExpression method for more information.

        default_expression_language
            See the defaultExpressionLanguage method for more information.
        """
    def stringType(self):
        """
        stringType(self) -> hou.stringParmType enum value

        Return the type of this string parameter.  This type determines whether
        the parameter has special selection controls to choose a file path or
        the paths to one or more nodes.

        See hou.stringParmType for more information.
        """
        return stringParmType()

    def setStringType(self, string_type):
        """
        setStringType(self, string_type)

        Set the type of this string parameter to a hou.stringParmType enum
        value.

        See the stringType method for more information.
        """

    def fileType(self):
        """
        fileType(self) -> hou.fileType enum value

        Return the file type of this string parameter.  The file type applies
        only when stringType() == hou.stringParmType.FileReference.  Only
        hou.fileType.Any, hou.fileType.Image, and hou.fileType.Geometry are
        supported by dialog scripts.

        See hou.fileType for more information.
        """
        return fileType()

    def setFileType(self, file_type):
        """
        setFileType(self, file_type)

        Set the type of this string parameter to a hou.fileType enum value.

        See the fileType method for more information.
        """

    def defaultValue(self):
        """
        defaultValue(self) -> tuple of str

        Return the default value for new parameter instances.

        The number of strings in the return value is the same as the number of
        components in the parm template.
        """
        return ('',)

    def setDefaultValue(self, default_value):
        """
        setDefaultValue(self, default_value)

        Set the default value for new parameter instances to a sequence of
        strings.

        See the defaultValue method for more information.  Note that if the
        number of strings in the sequence is different from the number of
        components in the parm template, any extra values will be discarded and
        any missing values will become the last value in the sequence or an
        empty string if the sequence is empty.
        """

    def defaultExpression(self):
        """
        defaultExpression(self) -> tuple of strings

        Return the default expression for new parameter instances.

        The default expression takes precendence over the default value. If a
        component has no default expression (i.e. an empty string), then the
        default value is used for new parameter instances.

        Note that the default expression language is needed to interpret the
        meaning of the default expression.
        """
        return ('',)

    def setDefaultExpression(self, default_expression):
        """
        setDefaultExpression(self, default_expression)

        Set the default expression for new parameter instances to a sequence  of
        strings.

        See the hou.StringParmTemplate.defaultExpression method  for more
        information.  Note that if the number of strings in the sequence  is
        different from the number of components in the parm template,  any extra
        values will be discarded and any missing expressions will become the
        empty string.
        """

    def defaultExpressionLanguage(self):
        """
        defaultExpressionLanguage(self) -> tuple of hou.scriptLanguage

        Return the default expression language for new parameter instances.

        The default expression language only applies if the default expression
        is set.  If the default expression of a component is not set, then the
        expression language is set to hou.scriptLanguage.Hscript.
        """
        return (scriptLanguage(),)

    def setDefaultExpressionLanguage(self, default_expression_language):
        """
        setDefaultExpressionLanguage(self, default_expression_language)

        Set the default expression language for new parameter instances  to a
        sequence of hou.scriptLanguage values.

        See the defaultExpressionLanguage method for more information.   Note
        that if the number of hou.scriptLanguage values in the sequence  is
        different from the number of components in the parm template,  any extra
        values will be discarded and any missing expression languages  will
        become hou.scriptLanguage.Hscript.
        """

    def menuItems(self):
        """
        menuItems(self) -> tuple of str

        Return the tuple of internal menu names.  If this string does not use a
        menu, returns an empty tuple.

        These internal menu names are not displayed in the UI, but they can be
        passed to hou.Parm.set and will be returned by  hou.Parm.evalAsString
        for menu parameters.
        """
        return ('',)

    def setMenuItems(self, menu_items):
        """
        setMenuItems(self, menu_items)

        Set the internal menu names to the given sequence of strings.

        See the menuItems method for more information.

        If the new number of menu items is less than the old number, the menu
        labels will be shortened and the default value will be modified if it is
        out of range.
        """

    def menuLabels(self):
        """
        menuLabels(self) -> tuple of str

        Return the tuple of menu labels displayed in the UI.
        """
        return ('',)

    def setMenuLabels(self): return
    def iconNames(self):
        """
        iconNames(self) -> tuple of str

        Return the tuple of icons corresponding to the menu items. If there are
        no icons, returns a tuple of empty strings.

        These icons are used when this parm template uses a menu.
        """
        return ('',)

    def setIconNames(self, icon_names):
        """
        setIconNames(self, icon_names)

        Set the icon names to the given sequence of strings.
        """

    def itemGeneratorScript(self):
        """
        itemGeneratorScriptLanguage(self) -> hou.scriptLanguage enum value

        Return the script used to generate menu items, or an empty string if
        there is no such script.
        """
        return scriptLanguage()

    def setItemGeneratorScript(self, item_generator_script):
        """
        setItemGeneratorScript(self, item_generator_script)

        Set the script used to generate menu items.

        See the itemGeneratorScript method for more information.
        """

    def itemGeneratorScriptLanguage(self): return
    def setItemGeneratorScriptLanguage(self, language):
        """
        setItemGeneratorScriptLanguage(self, language)

        Set the script language used to generate menu items to a
        hou.scriptLanguage enum value.

        See the itemGeneratorScriptLanguage method for more information.
        """

    def menuType(self):
        """
        menuType(self) -> hou.menuType enum value

        Return the type of menu.  See hou.menuType for more information.
        """
        return menuType()

    def setMenuType(self, menu_type):
        """
        setMenuType(self, menu_type)

        Set the type of menu to a hou.menuType enum value.

        See the menuType method for more information.
        """

class SubnetIndirectInput(object):
    """
    hou.SubnetIndirectInput

    A node-like square that appears inside subnets and corresponds to the
    node wired into the subnet.

    For example, suppose you have a font SOP, polyextrude SOP, and facet SOP
    connected together in a chain.  If you collapse the polyextrude and
    facet SOPs into a subnet, you're left with a font SOP connected to a
    subnet SOP. Inside the subnet SOP is subnet indirect input #1 connected
    to a polyextrude SOP, which is connected to the facet SOP.

    Each subnet indirect input is numbered starting from 1 and corresponds
    to an input connector on the subnet.  (See hou.NodeConnection for more
    information on input connectors.)

    The names of the subnet indirect inputs in the network pane correspond
    to the contents of the Input #n Label parameters on the subnet node,
    where n is the number.


    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def number(self):
        """
        number(self) -> int

        Return the number of the corresponding input connector on the subnet.
        Note that the first input corresponds to the number 1, not 0.
        """
        return 0

    def parent(self):
        """
        parent(self) -> hou.Node

        Return the subnet node containing this indirect input.  Nodes inside the
        subnet and this object share the same parent node.
        """
        return Node()

    def outputs(self):
        """
        outputs(self) -> tuple of hou.Node

        Return the nodes that have one of their inputs connected to the output
        of this object.
        """
        return (Node(),)

class Surface(Prim):
    """
    hou.Surface

    A Surface is a kind of geometry primitive (Prim object) that contains a
    two dimensional grid of vertices (Vertex objects).  How these vertices
    are used depends on the type of surface: meshes, for example, use the
    vertices to define a quadrilateral mesh, while NURBS surfaces use them
    as control points.

    A hou.Face, on the other hand, stores a sequence of vertices, and might
    be a polygon or NURBS curve.
    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def numRows(self):
        """
        numRows(self)

        Return the number of rows in the 2D array of vertices.
        """
        return 0

    def numCols(self):
        """
        numCols(self)

        Return the number of columns in the 2D array of vertices.
        """
        return 0

    def vertex(self, u_index, v_index):
        """
        vertex(self, u_index, v_index)

        Return an element in the 2D array of vertices, given the u (column) and
        v (row) indices into the array.

        Negative indices are allowed, in which case Houdini will index starting
        from the last vertex.

        For non-negative indices, this method is roughly equivalent to writing
        surf.vertices()[v_index * surf.numCols() + u_index].

        Raises hou.OperationFailed if the u or v indices are invalid.

          # Use a grid SOP to create a NURBS grid with 3 rows and 2 columns.
          geo = hou.node("/obj").createNode("geo").createNode("grid").geometry()
          grid_node = geo.sopNode()
          grid_node.setDisplayFlag(True)
          for name, value in ("type", "nurbs"), ("rows", 5), ("cols", 4):
              grid_node.parm(name).set(value)

          # Print out the x positions of all the vertices in the surface.
          surf = geo.iterPrims()[0]
          for v_index in surf.numRows():
              for u_index in surf.numCols():
                  print surf.vertex(u_index, v_index).point().position()[0],
              print

        See also:

        * hou.Prim.vertices
        * hou.Surface.verticesInCol
        * hou.Surface.verticesInRow
        * hou.Geometry.iterPrims        """

    def verticesInRow(self, v_index):
        """
        verticesInRow(self, v_index)

        Given a v (i.e. row) index, return a tuple containing all the vertices
        in that row.

        See also hou.Prim.vertices.
        """

    def verticesInCol(self): return
    def isClosedInU(self):
        """
        isClosedInU(self)

        Return whether the first and last columns of vertices are connected.

        A grid, for example, is open in both U and V.  A tube is open in one of
        U or V and closed in the other.  A torus is closed in both U and V.

        REPLACES
            iswrapu function        """

    def isClosedInV(self):
        """
        isClosedInV(self)

        Return whether the first and last rows of vertices are connected.

        See hou.Surface.isClosedInU for more information.

        REPLACES
            iswrapv function        """

    def positionAt(self, u, v):
        """
        positionAt(self, u, v) -> hou.Vector3

        Given normalized (i.e. from 0 to 1) u and v values, returns the position
        of the surface at that parametric location.

        See the surface_wires cookbook example for an example.

        REPLACES
            primuv function        """
        return Vector3()

    def normalAt(self, u, v):
        """
        normalAt(self, u, v) -> Vector3

        Given normalized (i.e. from 0 to 1) u and v values, returns the normal
        of the surface at that parametric location.  The normal is a vector that
        is perpendicular to the surface at that location.

        The normal vector is normalized (i.e. it is a unit vector, so its length
        is 1).

        See the surface_wires cookbook example for an example.

        REPLACES
            normal function        """
        return Vector3()

    def attribValueAt(self, attrib_or_name, u, v, du=0, dv=0):
        """
        attribValueAt(self, attrib_or_name, u, v, du=0, dv=0) -> int, float, str
        or tuple

        Return an attribute value at a normalized (u, v) parametric position on
        the surface.  If du and dv are both 0, returns the interpolated
        attribute value; otherwise, returns the (partial) derivative of the
        attribute value.

        Raises hou.OperationFailed if the attribute is not a point or vertex
        attribute.  If you want a primitive attribute value, it doesn't vary
        across the surface, so use hou.Prim.attribValue.

        REPLACES
            primuv function
            primduv function        """

    def addRow(self, after=-1):
        """
        addRow(self, after=-1)

        Add a row of vertices after the given v (i.e. row) index.  The new
        vertices are located at the origin until you move them.  You would
        typically call this method from the code of a Python-defined SOP.

        See hou.Surface.addCol for more information.
        """

    def addCol(self, after=-1):
        """
        addCol(self, after=-1)

        Add a column of vertices after the given u (i.e. column) index.  You
        would typically call this method from the code of a Python-defined SOP.

        This method also adds one point per vertex added.  The new points are
        located at the origin until you move them.

        The u (i.e. column) index after may be negative, in which case the
        indexing starts from the end.  By default, after is -1, meaning that the
        new column will go after the last column.  Raises hou.OperationFailed if
        the after index is invalid.


          # This code will work from inside a Python SOP, but not from the Python
          # shell.
          def vertexPos(vertex):
              return hou.Vector3(vertex.point().position())

          # Build a NURBS surface.
          geo = hou.pwd().geometry()
          surf = geo.createNURBSSurface(10, 10)

          # Add a new column, and set the new point positions to the average of
          # the adjacent point positions.
          surf.addCol(after=7)
          for v_index in range(surf.numRows()):
              vertex_before = surf.vertex(7, v_index)
              vertex_after = surf.vertex(9, v_index)
              surf.vertex(8, v_index).point().setPosition(
                  (vertexPos(vertex_before) + vertexPos(vertex_after)) * 0.5)
        """

class ToggleParmTemplate(ParmTemplate):
    """
    hou.ToggleParmTemplate

    Describes a parameter tuple containing a checkbox.
    """

    def __init__(self, name, label, default_value=False, disable_when=None,
        is_hidden=False, is_label_hidden=False, join_with_next=False, help=None,
        script_callback=None,
        script_callback_language=hou.scriptLanguage.Hscript, tags={},
        default_expression="",
        default_expression_language=hou.scriptLanguage.Hscript):
        """
        __init__(self, name, label, default_value=False, disable_when=None,
        is_hidden=False, is_label_hidden=False, join_with_next=False, help=None,
        script_callback=None,
        script_callback_language=hou.scriptLanguage.Hscript, tags={},
        default_expression="",
        default_expression_language=hou.scriptLanguage.Hscript)

        Creates a new ToggleParmTemplate instance.

        name
            See hou.ParmTemplate.name for more information.

        label
            See hou.ParmTemplate.label for more information. See the
            defaultValue method for more information.

        disable_when
            See hou.ParmTemplate.disableWhen for more information.

        is_hidden
            See hou.ParmTemplate.isHidden for more information.

        is_label_hidden
            See hou.ParmTemplate.isLabelHidden for more information.

        join_with_next
            See hou.ParmTemplate.joinsWithNext for more information.

        help
            See hou.ParmTemplate.help for more information.

        script_callback
            See hou.ParmTemplate.scriptCallback for more information.

        script_callback_language
            See hou.ParmTemplate.scriptCallbackLanguage for more information.

        tags
            See hou.ParmTemplate.tags for more information.

        default_expression
            See the defaultExpression method for more information.

        default_expression_language
            See the defaultExpressionLanguage method for more information.

        Note that ToggleParmTemplates have only one component.  Unlike float,
        integer, and string parm templates, the default value is a single bool
        and not a tuple.
        """
    def defaultValue(self):
        """
        defaultValue(self) -> bool

        Returns the default value for new parameter instances.

        Note that ToggleParmTemplates have only one component.  Unlike float,
        integer, and string parm templates, the default value is a single bool
        and not a tuple.
        """
        return True

    def setDefaultValue(self, default_value):
        """
        setDefaultValue(self, default_value)

        Set the default value for new parameter instances.
        """

    def defaultExpression(self):
        """
        defaultExpression(self) -> string

        Return the expression, which when evaluated, returns the initial value
        of the toggle.

        The default expression takes precendence  over the default value.  If
        the default expression is not set  (i.e. an empty string), then the
        default value is used instead.

        Note that the default expression language is needed to interpret the
        meaning of the default expression.
        """
        return ''

    def setDefaultExpression(self, default_expression):
        """
        setDefaultExpression(self, default_expression)

        Set the default expression, which when evaluated, returns the initial
        value of the toggle.

        If default_expression is the empty string, then the default expression
        is unset.
        """

    def defaultExpressionLanguage(self):
        """
        defaultExpressionLanguage(self) -> tuple of hou.scriptLanguage

        Return the default expression language.

        The default expression language only applies if the default expression
        is set.  If the default expression is not set, then the expression
        language is set to hou.scriptLanguage.Hscript.
        """
        return (scriptLanguage(),)

    def setDefaultExpressionLanguage(self, default_expression_language):
        """
        setDefaultExpressionLanguage(self, default_expression_language)

        Set the default expression language.

        See the defaultExpressionLanguage method for more information.
        """

class Tool(ShelfElement):
    """
    hou.Tool
    """
    def __init__(self): raise AttributeError, "No constructor defined"
    def script(self):
        """
        script(self) -> str
        """
        return ''

    def setScript(self, script):
        """
        setScript(self, script)
        """

    def language(self):
        """
        language(self) -> hou.scriptLanguage enum value
        """
        return scriptLanguage()

    def setLanguage(self, language):
        """
        setLanguage(self, language)
        """
        return _hou.Tool_setLanguage(*args)

    def icon(self):
        """
        icon(self) -> str
        """
        return ''

    def setIcon(self, icon):
        """
        setIcon(self, icon)
        """

    def help(self):
        """
        help(self) -> str
        """
        return ''

    def setHelp(self, help):
        """
        setHelp(self, help)
        """

    def helpURL(self):
        """
        helpURL(self) -> str
        """
        return ''

    def setHelpURL(self, help_url):
        """
        setHelpURL(self, help_url)
        """

    def toolMenuCategories(self, pane_type):
        """
        toolMenuCategories(self, pane_type) -> tuple of hou.NodeTypeCategory
        """
        return (NodeTypeCategory(),)

    def setToolMenuCategories(self, pane_type, categories):
        """
        setToolMenuCategories(self, pane_type, categories)
        """

    def toolMenuOpType(self, pane_type):
        """
        toolMenuOpType(self, pane_type) -> str
        """
        return ''

    def setToolMenuOpType(self, pane_type, op_type):
        """
        setToolMenuOpType(self, pane_type, op_type)
        """

    def toolMenuLocations(self):
        """
        toolMenuLocations(self) -> tuple of str
        """
        return ('',)

    def setToolLocations(self, locations):
        """
        setToolLocations(self, locations)
        """

    def keywords(self): return
    def setKeywords(self): return
    def setData(self, script='', language=hou.scriptLanguage.Python, icon='',
        help='', help_url='', network_categories=(), viewer_categories=(),
        cop_viewer_categories=(), network_op_type='', viewer_op_type='',
        locations=()):
        """
        setData(self, script='', language=hou.scriptLanguage.Python, icon='',
        help='', help_url='', network_categories=(), viewer_categories=(),
        cop_viewer_categories=(), network_op_type='', viewer_op_type='',
        locations=())
        """

    def destroy(self):
        """
        destroy(self)
        """

class Track(object):
    """
    hou.Track

    Each hou.ChopNode contains its data in one or more tracks. A track
    contains a sequence of floating point samples over time. Each track has
    a unique name in its containing CHOP.

    REPLACES
      * chop
      * chopcf
      * chopci
      * chopct
      * chopf
      * chopi
      * chopl
      * chopstr
      * chopt


    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def chopNode(self):
        """
        chopNode(self) -> hou.ChopNode

        Returns the hou.ChopNode owner of this track.
        """
        return ChopNode()

    def name(self):
        """
        name(self) -> str

        Returns the name of this track (each track in a CHOP has a unique name).
        """
        return ''

    def eval(self):
        """
        eval(self) -> double

        Returns the value of this track at the current time.
        """
        return 0.0

    def evalAtTime(self):
        """
        evalAtTime(self, time) -> double

        Returns the value of this track at a given time.
        """
        return 0.0

    def evalAtFrame(self):
        """
        evalAtFrame(self, frame) -> double

        Returns the value of this track at a given frame.
        """
        return  0.0

    def evalAtSample(self):
        """
        evalAtSample(self, sample) -> double

        Returns the value of the track at a given sample value.
        """
        return 0.0

    def numSamples(self):
        """
        numSamples(self) -> int

        Return the number of samples in this track.
        """
        return 0

    def allSamples(self):
        """
        allSamples(self) -> tuple of double

        Returns all the sample values in this track.
        """
        return (0.0,)

    def _asVoidPointer(self): return
    def evalAtSampleIndex(self, index):
        """
        evalAtSampleIndex(self, index) -> double

        This method is deprecated in favor of evalAtSample.
        """
        return 0.0

class ui(object):
    """
    hou.ui

    Module containing user interface related functions.
    """

    def __init__(self): raise AttributeError, "No constructor defined"
    @staticmethod
    def shellIO():
        """
        shellIO() -> hou.ShellIO

        Return the hou.ShellIO object used to implement Houdini's graphical
        Python shell.  This function is used internally by Houdini, and you
        shouldn't need to access the ShellIO directly.
        """
        return ShellIO()
    @staticmethod
    def curDesktop():
        """
        curDesktop() -> hou.Desktop

        Return the current desktop.

        REPLACES
            desk command        """
        return Desktop()
    @staticmethod
    def desktops():
        """
        desktops() -> tuple of hou.Desktop

        Return all the desktops.

        See hou.Desktop.setAsCurrent for an example.

        REPLACES
            desk command        """
        return (Desktop(),)
    @staticmethod
    def paneTabs():
        """
        paneTabs(self) -> tuple of hou.PaneTab

        Return a tuple of all visible pane tabs, including those in all floating
        windows.

        See also hou.Desktop.paneTabs.
        """
        return (PaneTab(),)
    @staticmethod
    def paneTabOfType( type, index=0):
        """
        paneTabOfType(self, type, index=0) -> hou.PaneTab or None

        Find and return the pane tab with the desired type.  If no such tab
        exists, return None.

        type
            A hou.paneTabType enumerated variable.

        index
            If there are multiple tabs with the desired type, this parameter
            determines which one is returned.  Use index=0 to return the first
            found tab, index=1 to return the second found tab, etc.  By default,
            index is 0.

        See also hou.Desktop.paneTabOfType.
        """
        return PaneTab()
    @staticmethod
    def findPaneTab(name):
        """
        findPaneTab(self, name) -> hou.PaneTab or None

        Return the pane tab with the given name, or None if no such tab exists.

        The name may optionally be prefixed by the desktop name and a period.

        See also hou.Desktop.findPaneTab.
        """
        return PaneTab()
    @staticmethod
    def floatingPaneTabs():
        """
        floatingPaneTabs(self) -> tuple of hou.PaneTab

        Return all the pane tabs in floating panels.

        See also hou.Desktop.floatingPaneTabs.
        """
        return PaneTab()
    @staticmethod
    def floatingPanels():
        """
        floatingPanels(self) -> tuple of hou.FloatingPanel

        Return all the visible floating panels.

        See also hou.Desktop.floatingPanels.
        """
        return FloatingPanel()
    @staticmethod
    def orientationUpAxis():
        """
        orientationUpAxis(self) -> hou.orientUpAxis enum value

        Return a hou.orientUpAxis indicating the current orientation mode's up
        axis.
        """
        return orientUpAxis()
    @staticmethod
    def displayMessage(text, buttons=('OK',), severity=hou.severityType.Message,
        default_choice=0, close_choice=None, help=None, title=None,
        details=None,  details_expanded=False):
        """
        displayMessage(text, buttons=('OK',), severity=hou.severityType.Message,
        default_choice=0, close_choice=None, help=None, title=None,
        details=None,  details_expanded=False) -> int

        Pop up a small window with a message and one or more buttons and wait
        for the user to press a button.  Return the index of the button the user
        pressed.

        text
            The message to display.

        buttons
            A sequence of strings containing the names of the buttons.  By
            default the message window contains a single OK button.

        severity
            A hou.severityType value that determines which icon to display on
            the dialog.  Note that using hou.severityType.Fatal will exit
            Houdini after the user closes the dialog.

        default_choice
            The index of the button that is selected if the user presses enter.

        close_choice
            The index of the button that is selected if the user presses Escape
            or closes the dialog.

        help
            Additional help information to display below the main message.

        title
            The window's title.  If None, the title is "Houdini".

        details
            A string containing extra messages that is not visible unless the
            user clicks "Show Details".

        details_expanded
            A boolean, if true then the text area where the detail messages
            appear is always shown and cannot be collapsed. If false, the detail
            message area is initially folded when the message box is popped up
            and the user can expand to read the details.

          def saveIfNeeded():
              '''Prompt the user if they want to save, and save the hip file if they choose Yes.'''
              if hou.ui.displayMessage("Save the current hip file?", buttons=("Yes", "No")) == 0:
                  hou.hipFile.save()

        REPLACES
            message command        """
    @staticmethod
    def readInput(message, buttons=('OK',), severity=hou.severityType.Message,
        default_choice=0, close_choice=None, help=None, title=None,
        initial_contents=None):
        """
        readInput(message, buttons=('OK',), severity=hou.severityType.Message,
        default_choice=0, close_choice=None, help=None, title=None,
        initial_contents=None) -> (int, str)

        Pop up a small window with a textbox and wait for the user to enter a
        line of text.  Return a tuple containing an integer and the text they
        entered. The integer is the index of the pressed button.  If
        close_choice is not None and the user closed the dialog by clicking on
        its close button or by pressing Escape, then the returned integer is set
        to close_choice.

        message
            The message to display above the text field.

        buttons
            A sequence of strings containing the names of the buttons.  By
            default the message window contains a single OK button.

        severity
            A hou.severityType value that determines which icon to display on
            the dialog.  Note that using hou.severityType.Fatal will exit
            Houdini after the user closes the dialog.

        default_choice
            The index of the button that is selected if the user presses enter.

        close_choice
            The index of the button that is selected if the user presses Escape
            or clicks on the dialog's close button.  If there is more than one
            button and close_choice is None, then the user cannot close the
            dialog with Escape or the dialog's close button.  If there is only
            one button and close_choice is None, then the user can close the
            dialog with Escape or the dialog's close button, and the button's
            index is returned.

        help
            Additional help information to display below the main message.

        title
            The window's title.  If None, the title is "Houdini".

        initial_contents
            The initial contents of the text field.  If None, the text field is
            initially empty.

        See also hou.ui.readMultiInput
        """
        return (0, '')
    @staticmethod
    def readMultiInput(message, input_labels, password_input_indices=(),
        buttons=('OK',), severity=hou.severityType.Message, default_choice=0,
        close_choice=None, help=None, title=None, initial_contents=(0,)):
        """
        -> (int, tuple of str):
        readMultiInput(message, input_labels, password_input_indices=(),
        buttons=('OK',), severity=hou.severityType.Message, default_choice=0,
        close_choice=None, help=None, title=None, initial_contents=(0,)) ->
        (int, tuple of str)

        Pop up a small window with a textbox and wait for the user to enter a
        text into several input fields. Return a tuple containing an integer and
        the tuple of strings they entered, one for each input field. The integer
        is the index of the pressed button.  If close_choice is not None and the
        user closed the dialog by clicking on its close button or by pressing
        Escape, then the returned integer is set to close_choice.

        message
            The message to display above the text field.

        input_labels
            A sequence of labels to appear in front of each input field. The
            length of the sequence determines the number of input fields that
            will appear in the window.

        password_input_indices
            A sequence of indices of which input fields are password fields.
            Fields whose index is not in this sequence will not be password
            fields.

        buttons
            A sequence of strings containing the names of the buttons.  By
            default the message window contains a single OK button.

        severity
            A hou.severityType value that determines which icon to display on
            the dialog.  Note that using hou.severityType.Fatal will exit
            Houdini after the user closes the dialog.

        default_choice
            The index of the button that is selected if the user presses enter.

        close_choice
            The index of the button that is selected if the user presses Escape
            or clicks on the dialog's close button.  If there is more than one
            button and close_choice is None, then the user cannot close the
            dialog with Escape or the dialog's close button.  If there is only
            one button and close_choice is None, then the user can close the
            dialog with Escape or the dialog's close button, and the button's
            index is returned.

        help
            Additional help information to display below the main message.

        title
            The window's title.  If None, the title is "Houdini".

        initial_contents
            The list that specifies the initial contents of each of the text
            field. The length of the list does not need to be the same as the
            number of the input fields. If it is shorter, then initially the
            remaining input fields will be empty.

        See also hou.ui.readInput
        """
        return (0, ('',))
    @staticmethod
    def selectFromList(hoices, default_choices=(0,), exclusive=False,
        message=None, title=None, column_header=None, num_visible_rows=10):
        """
        selectFromList(choices, default_choices=(0,), exclusive=False,
        message=None, title=None, column_header=None, num_visible_rows=10) ->
        tuple of int

        Pop up a window with a set of choices in a list box and prompt the user
        to choose zero or more of them.

        choices
            A sequence of strings containing the possible choices.

        default_choices
            A sequence of integers containing the indices of the choices that
            are initially selected.

        exclusive
            Whether or not the user must choose exactly one of the possible
            choices.

        message
            The message to display above the list box.

        title
            The window's title.  If None, the title is "Houdini".

        column_header

        The column header for the list of choices.  Users can click this header
        label to sort the list.  If None, the header is "Choices".  Note that
        the tuple of integers represents the original order of items, regardless
        of the displayed sort order.

        num_visible_rows
            The number of rows of entries that are visible at a time.  If there
            are more possible choices than visible rows, Houdini will use a
            scrollbar.

        REPLACES
            listchooser command        """
        return (0,)
    @staticmethod
    def selectFromTree(choices, picked=(), exclusive=False, message=None,
        title=None):
        """
        selectFromTree(choices, picked=(), exclusive=False, message=None,
        title=None) -> tuple of str

        Pop up a window with a set of choices in a tree chooser and prompt the
        user to choose zero or more of them.  The choices are arranged into a
        tree using a forward slash as a path separator.

        choices
            A sequence of strings containing the possible choices.

        picked
            A sequence of strings containing the items that should be initially
            selected.

        exclusive
            Whether or not the user must choose exactly one of the possible
            choices.

        message
            The message to display above the list box.

        title
            The window's title.  If None, the title is "Make Selection".

        REPLACES
            treechooser command        """
        return ('',)
    @staticmethod
    def selectFile(start_directory=None, title=None, collapse_sequences=False,
        file_type=hou.fileType.None, pattern=None, default_value=None,
        multiple_select=False, image_chooser=False,
        chooser_mode=hou.fileChooserMode.ReadAndWrite):
        """
        selectFile(start_directory=None, title=None, collapse_sequences=False,
        file_type=hou.fileType.None, pattern=None, default_value=None,
        multiple_select=False, image_chooser=False,
        chooser_mode=hou.fileChooserMode.ReadAndWrite) -> str

        Pop up a window with a file chooser dialog and wait for the user to
        choose a file name.  Return the path to the file that was selected.

        start_directory
            The directory the dialog should initially start in.

        title
            The window title for the dialog.

        collapse_sequences
            Whether sequences of files with common numeric patterns should be
            collapsed into patterns containing $F.

        file_type
            A hou.fileType enumerated value to say what type of file to select.
            The set of visible files is determined by this file type and the
            pattern.

        pattern
            Only files matching this pattern (and anything restricted by the
            file type) will be listed.  By default, everything matches the
            pattern.

        default_value
            The default contents of the file name field in the dialog.

        multiple_select
            Whether the user may select multiple files.

        image_chooser
            Whether the dialog shows image thumbnails.

        chooser_mode
            A hou.fileChooserMode enumeration value to say if the user is being
            prompted for a file to read from, write to, or either.

        REPLACES
            filechooser command        """
        return ''
    @staticmethod
    def selectNode(relative_to_node=None, initial_node=None,
        node_type_filter=None):
        """
        selectNode(relative_to_node=None, initial_node=None,
        node_type_filter=None) -> str or None

        Pop up a window with a node tree view and prompt the user to choose a
        node.

        If the user selects a node, returns a string containing the path to the
        node.  If the user presses clear, returns an empty string.  If the user
        presses cancel, returns None.

        relative_to_node
            A hou.Node for relative paths, or None if relative paths are not
            supported.  Passing in a node enables the Use Relative Paths
            checkbox.

            If this parameter is supplied and the user checks the Use Relative
            Paths checkbox, this function returns a relative path to the node.

        initial_node
            The hou.Node that is initially selected.

        node_type_filter
            An optional hou.nodeTypeFilter enumerated value that determines
            which types of nodes appear in the tree view.

        The following function takes a hou.Parm, prompts the user to choose a
        node, and sets the value of the parameter as long as the user does not
        click cancel.
          def setParmOnNode(parm, node_type_filter=None):
              path = hou.ui.selectNode(relative_to_node=parm.node(), node_type_filter=node_type_filter)
              if path is not None:
                  parm.set(path)


        You might call this function as follows:
          >>> setParmOnNode(hou.parm("/obj/box_object1/shop_materialpath"), hou.nodeTypeFilter.Shop)
        """
        return ''
    @staticmethod
    def displayFileDependencyDialog(rop_node=None, uploaded_files=(),
        forced_unselected_patterns=(), project_dir_variable='HIP',
        is_standalone=true):
        """
        displayFileDependencyDialog(rop_node=None, uploaded_files=(),
        forced_unselected_patterns=(), project_dir_variable='HIP',
        is_standalone=true) -> (bool, tuple of str)
        """
        return (True, ('',))
    @staticmethod
    def displayNodeHelp(node_type):
        """
        displayNodeHelp(node_type)

        Display the help for the specified node type.  If no help browser is
        open, this function will create a new one.

        If you want to display the help for a node instance, it is easy to
        access the hou.NodeType from the node, as illustrated in this example:
          def displayHelpForNode(node):
              '''Given a hou.Node, display its help.'''
              hou.ui.displayNodeHelp(node.type())


        REPLACES
            ophelp command        """
    @staticmethod
    def openTypePropertiesDialog(node_or_node_type, promote_spare_parms=False,
        immediately_save=False):
        """
        openTypePropertiesDialog(node_or_node_type, promote_spare_parms=False,
        immediately_save=False)

        Given a hou.Node or hou.NodeType instance, open the spare properties
        dialog.

        promote_spare_parms
            If this parameter is True and you passed in a node instance,
            automatically promote any spare parameters on the node into
            parameters on the node type.

        immediately_save
            When true, immediately save the current state of the node type, as
            if you clicked "Apply" in the type properties dialog.

        REPLACES
            otedit command
            propertyedit command        """
    @staticmethod
    def updateMode():
        """
        updateMode() -> hou.updateMode enum value

        This method is deprecated in favor of hou.updateModeSetting.
        """
        return updateMode()
    @staticmethod
    def setUpdateMode(mode):
        """
        setUpdateMode(mode)

        This method is deprecated in favor of hou.setUpdateMode.
        """
    @staticmethod
    def triggerUpdate():
        """
        reloadViewportColorSchemes()

        Reloads all 3DSceneColors configuration files (in $HFS/houdini/config).
        You must cause the viewport to redraw (for example, by tumbling) to see
        the new colors.

        This function may be useful if you are implementing a new color scheme:
        you can map to a hotkey or call it in the Python console so you can
        check your changes.
        """
    @staticmethod
    def reloadViewportColorSchemes(): return
    def _getTabMenuIconSize(self):
        """
        _getTabMenuIconSize() -> (int, int)

        Used internally by Houdini to get the current icon size in the tab menu.
        """
        return (0,0)
    @staticmethod
    def createDialog(ui_file_name):
        """
        createDialog(ui_file_name) -> hou.Dialog

        Parse the given .ui file and return the dialog defined in the file.

        The dialog must be written with Houdini's User Interface Script
        Language. An overview of the language can be found in the Houdini
        Development Kit (HDK) documentation, specifically in the "Houdini User
        Interface -> The .ui Script Language" section.

        ui_file_name is the basename of the .ui file.  The file must be located
        in a directory registered with the HOUDINI_UI_APP_PATH search path.  For
        a list of HOUDINI_UI_APP_PATH search directories, run hconfig -ap from a
        terminal.

        Raises hou.OperationFailed if the .ui file contains errors and the
        dialog could not be created. Raises hou.TypeError if ui_file_name is
        None.
        """
        return Dialog()
    @staticmethod
    def findDialog(ui_file_name):
        """
        findDialog(ui_file_name) -> hou.Dialog

        Return the dialog defined by the given .ui file name and created by
        hou.ui.createDialog.

        Return None if no dialog has been created with hou.ui.createDialog for
        the specified .ui file.

        Raises hou.TypeError if ui_file_name is None.
        """
        return Dialog()
    @staticmethod
    def dialogs():
        """
        dialogs() -> tuple of hou.Dialog

        Return all dialogs created by hou.ui.createDialog.
        """
        return (Dialog(),)
    @staticmethod
    def opaqueWaitUntil(): return
    @staticmethod
    def writePythonShellHistoryFile(filename=None):
        """
        writePythonShellHistoryFile(filename=None)

        Save the command history from the current Python Shell to disk. If
        filename is None, then the history is written to
        $HOME/houdiniX.X/pyshell.history.  If this function is invoked outside
        of a Python Shell, then the history is taken from the  last active shell
        (i.e. the last shell that was opened or accepted input).

        Raises hou.OperationFailed if no Python Shell has been opened. Raises
        hou.OperationFailed if filename cannot be created.
        """
    @staticmethod
    def readPythonShellHistoryFile(filename=None):
        """
        readPythonShellHistoryFile(filename=None)

        Load the contents from the specified file into the command history of
        the Python Shell.  If filename is None, then the history is read from
        $HOME/houdiniX.X/pyshell.history.  If this function is invoked outside
        of a Python Shell, then the history is loaded into the the last active
        shell (i.e. the last shell that was opened  or accepted input).

        Raises hou.OperationFailed if no Python Shell has been opened. Raises
        hou.OperationFailed if filename does not exist or cannot be read.
        """
    @staticmethod
    def setStatusMessage(message, severity=hou.severityType.Message):
        """
        setStatusMessage(message, severity=hou.severityType.Message)

        Display a message in Houdini's status bar.

        severity
            A hou.severityType enum value that determines the background color
            of the message.

        To clear the status bar, call hou.ui.setStatusMessage("").
        """
    @staticmethod
    def openAssetUploadDialog(): return
    @staticmethod
    def openAssetDependenciesDialog(): return
    @staticmethod
    def hasDragSourceData(label, index):
        """
        getDragSourceData(label, index)

        Query the current drag source to obtain the dragged data.  Returns None
        when the specified data in unavailable (or unsupported by HOM).

        Raises hou.NotAvailable if no drag operation is currently active.
        """
        return True
    @staticmethod
    def getDragSourceData(): return
    @staticmethod
    def createQtIcon(name, width=32, height=32):
        """
        createQtIcon(name, width=32, height=32)

        Returns a QIcon instance from an icon in the Houdini search path. If the
        icon is an .svg file the width and height parameters determine the icon
        size. Otherwise, the size of the icon image file is used.

        For example:
          help_icon = hou.ui.createQtIcon("BUTTONS_help", 32, 32)
          help_button.setIcon(icon)
        """
        return QIcon()
    @staticmethod
    def qtStyleSheet():
        """
        qtStyleSheet()

        Returns the style sheet that Houdini is using to style Qt widgets.
        """
        return ''
    @staticmethod
    def addEventLoopCallback(callback):
        """
        addEventLoopCallback(callback)

        Register a Python callback to be called whenever Houdini's event loop is
        idle.  This callback is called approximately every 50ms, unless Houdini
        is busy processing events.

        callback
            Any callable Python object that expects no parameters.  It could be
            a Python function, a bound method, or any object implementing
            __call__.

          def checkForAndProcessEvents():
              # Here is where you would check for and process any events.
              pass
          hou.ui.addEventLoopCallback(checkForAndProcessEvents)

        You might use this function to integrate another user interface toolkit
        into Houdini's event loop.  See the PyQt and wxPython cookbook examples
        for example usages.
        """
    @staticmethod
    def removeEventLoopCallback(callback):
        """
        removeEventLoopCallback(callback)

        Remove a Python callback that was previously registered with
        hou.ui.addEventLoopCallback.  See hou.ui.addEventLoopCallback for more
        information.

        Raises hou.OperationFailed if the callback was not previously
        registered.
        """
    @staticmethod
    def eventLoopCallbacks():
        """
        eventLoopCallbacks() -> tuple of callback

        Return a tuple of all the Python callbacks that have been registered
        with hou.ui.addEventLoopCallback.
        """
        return (object,)
    @staticmethod
    def waitUntil(condition_callback):
        """
        waitUntil(condition_callback)

        Keep calling the supplied callback until it returns True.  In the
        meantime, Houdini will continue to be responsive, allowing you to
        continue to interact with it.

        For example, start a blank Houdini session and put the following in a
        shelf tool.  It will wait until you create an object node before
        finishing running the tool.
          print "waiting until you create an object..."
          hou.ui.waitUntil(lambda: len(hou.node("/obj").children()) > 0)
          print "you created", hou.node("/obj").children()


        If you find that your callback is being called too often, you can use
        this function instead of hou.ui.waitUntil to control how often Houdini
        invokes the callback:
          import time

          def wait_until(callback, poll_time_in_s):
              '''This function is like hou.ui.waitUntil, except it waits the specified
              poll time before calling the callback again.
              '''
              global _last_check_time
              _last_check_time = 0.0

              def wrapper_callback():
                  global _last_check_time
                  if time.time() < _last_check_time + poll_time_in_s:
                      return False
                  _last_check_time = time.time()
                  return callback()

              hou.ui.waitUntil(wrapper_callback)
        """
    @staticmethod
    def mainQtWindow():
        """
        Return a QWidget instance representing the main Houdini window.
        This method is useful for when you want to parent a PySide or PyQt dialog to the main window.
        Parenting to the main window keeps the dialog alive for the lifetime of the window so that the dialog
        is not destroyed prematurely by Python. Parenting also causes the dialog to inherit the Houdini styles
        set on the main window.
        """
        from PySide.QtGui import QWidget
        return QWidget


class undos(object):
    """
    hou.undos

    REPLACES
      * undoctrl
    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def areEnabled(self):
        """
        areEnabled() -> bool

        Returns True is undos are currently enabled.
        """
        return True

    def disabler(self):
        """
        disabler() -> hou.UndosDisabler

        This method returns a hou.UndosDisabler object for disabling undos using
        the with statement. For example:
          with hou.undos.disabler():
              #
              # All commands inside this block will not be recorded.
              #
        """
        return UndosDisabler()

    def group(self):
        """
        group(label) -> hou.UndosGroup

        This method returns a hou.UndosGroup object for grouping multiple
        commands into a single undoable action using the with statement.  Undo
        groups can be nested and the outermost group will encapsulate all within
        it as a single action.

        For example:
          with hou.undos.group("Action"):
              #
              # Commands that would normally put several actions on the undo stack
              #



        This has no effect when run inside parameter callback scripts because
        those are already executed within an undo group.
        """
        return UndosGroup()

    def clear(self):
        """
        clear()

        Clear all undo and redo information.
        """

    def memoryUsage(self):
        """
        memoryUsage() -> int

        The current memory used (in bytes) for undos.
        """
        return 0

    def memoryUsageLimit(self):
        """
        memoryUsageLimit() -> int

        The maximum allowed memory usage size (in bytes) for undos.
        """
        return -0

    def performUndo(self):
        """
        performUndo()

        Undo the last action.
        """

    def performRedo(self):
        """
        performRedo()

        Redo the last undoed action.
        """

    def undoLabels(self):
        """
        undoLabels() -> tuple of str

        Provides a tuple of the undo operations currently on the stack. Note
        that the first item (ie. undoLabels()0) is the next operation that will
        be undone.
        """
        return ('',)

    def redoLabels(self):
        """
        redoLabels() -> tuple of str

        Provides a tuple of the redo operations currently on the stack. Note
        that the first item (ie. redoLabels()0) is the next operation that will
        be redone.
        """
        return ('',)

class UndosDisabler(object):
    """
    hou.UndosDisabler

    Use this class to disable undos within a Python code block.
    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def __enter__(self): return
    def __exit__(self): return

class UndosGroup(object):
    """
    hou.UndosGroup

    Used to group all undos within a Python code block into a single action.
    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def label(self):
        """
        label(self)

        Returns the group label.
        """
        return ''

    def __enter__(self): return
    def __exit__(self): return

class VDB(Prim):
    """
    hou.VDB

    A VDB is a kind geometry primitive (Prim object) that stores data in a
    three dimensional grid of voxels.
    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def sample(self, position):
        """
        sample(self, position) -> float

        Given a sequence of three floats containing a 3D position, return the
        value of the volume at that position.  If the position is not in the
        middle of a voxel, Houdini will interpolate using values from
        surrounding voxels.

        See also hou.VDB.voxel and hou.VDB.posToIndex.
        """
        return 0

    def gradient(self, position):
        """
        gradient(self, position) -> hou.Vector3

        Given a sequence of three floats containing a 3D position, return a
        vector which points in the direction of the greatest rate of increase of
        the volume's value.

        See Wikipedia's gradient page for more information.
        """
        return Vector3()

    def voxel(self, index):
        """
        voxel(self, index) -> float

        Given a sequence of three integers containing a voxel index, return the
        value of the corresponding voxel.
        """
        return 0

    def resolution(self):
        """
        resolution(self) -> hou.Vector3

        Return the x, y, and z dimensions of hou.VDB.activeVoxelBoundingBox.
        Since VDB volumes are sparse, this represents the virtual resolution of
        all the voxels which have data (or are "active").
        """
        return Vector3()

    def indexToPos(self, index):
        """
        indexToPos(self, index) -> hou.Vector3

        Given a sequence of three ints containing an index into the voxel array,
        return the corresponding 3D position of the middle of that voxel.
        """
        return Vector3()

    def posToIndex(self, position):
        """
        posToIndex(self, position) -> tuple of int

        Given a sequence of three floats containing a 3D position, return a
        tuple of three ints containing the corresponding index into the voxel
        array.
        """
        return (0,)

    def isSDF(self):
        """
        isSDF(self) -> bool

        Return whether or not the volume should be semantically treated as a
        signed distance field. If true, the volume can be thought of as
        representing a closed surface, where the negative voxel values are
        inside, the positive voxel values are outside, and voxels on the surace
        are zero.

        For VDB volumes, there is typically only a 3 voxel radius around the
        surface where there exists data.
        """
        return True

    def transform(self):
        """
        transform(self) -> hou.Matrix3

        Return a 3x3 matrix containing the scale and rotation transformations
        for this volume.

        Note that the position information for the volume can be obtained by
        calling volume.vertex(0).point().position().

        The following function returns a 4x4 transformation matrix for the
        volume that includes the translation:
          def fullTransform(volume):
              return (hou.Matrix4(volume.transform()) *
                  hou.hmath.buildTranslate(volume.vertex(0).point().position()))



        You need to get the object node's transform to get to worldspace.
        """
        return Matrix3()

    def taper(self):
        """
        taper(self) -> int

        Returns the taper value of the volume's transform. For untapered
        transforms, this value will be 1.
        """
        return 0

    def vertex(self):
        """
        vertex(self, index) -> hou.Vertex

        A shortcut for self.vertices()[index].  You probably don't need to call
        this method.

        This method supports negative indices to index from the end, just like
        self.vertices()[index] would.  Also, like Python's indexing operator, it
        will raise IndexError when the index is out of range.
        """
        return Vertex()

    def isEmpty(self):
        """
        isEmpty(self) -> bool

        Returns whether the VDB volume has no data.
        """
        return True

    def activeVoxelCount(self):
        """
        activeVoxelCount(self) -> int

        Returns the number of active voxels in the volume.
        """
        return 0

    def activeVoxelBoundingBox(self):
        """
        activeVoxelBoundingBox(self) -> hou.BoundingBox

        Returns the smallest exclusive bounding box within the VDB volume that
        has active voxels.
        """
        return BoundingBox()

    def voxelSize(self):
        """
        voxelSize(self) -> hou.Vector3

        Returns the size of voxels within the VDB volume. All voxels will be of
        this size for untapered volumes. For tapered volumes, this size
        represents the size of voxel at the origin of the frustum.
        """
        return Vector3()
    def dataType(self):
        """
        dataType(self) -> hou.vdbData

        Returns the voxel data type within the VDB volume.
        """
        return vdbData()

    def voxelRangeAsBool(self): return
    def voxelRangeAsFloat(self): return
    def voxelRangeAsInt(self): return
    def voxelRangeAsVector3(self): return
    def voxelRange(self):
        """
        voxelRangeAsVector3(self, range) -> tuple of hou.Vector3

        Return a tuple containing the values of all voxels withing a bounding
        box range.  It is faster to call this method to retrieve all the voxels
        than it is to loop through the voxel array in Python.

        See help for hou.VDB.voxelRange for implementation details.
        """
        return (Vector3(),)

class Vector2(object):
    """
    hou.Vector2

    A sequence of 2 floating point values, with associated mathematical
    operations.

    A Vector2 might be used to represent a position in 2D space, a 2D
    direction and length, or the size of a rectangle.  For example,
    hou.Node.position returns a position and hou.Node.size returns the size
    of a rectangle.

    See also hou.Vector3 and hou.Vector4.


    """

    def __init__(self, *args):
        """
        __init__(self, values=(0.0, 0.0))

        Return a new Vector2 from a sequence of floats.  If this method is
        called without parameters, the resulting vector contains the values
        (0.0, 0.0).

        Raises InvalidSize if values is not 2 elements long, or TypeError if
        values is not a sequence of floats or ints.
        """
    def isAlmostEqual(self):
        """
        isAlmostEqual(self, vector2, tolerance=0.00001) -> bool

        Return whether this vector is equal to another, within a tolerance.
        Verifies that the difference between each component of this vector and
        the corresponding component of the other vector is within the tolerance.
        """
        return _hou.Vector2_isAlmostEqual(*args)

    def almostEqual(self): return True
    def __getitem__(self):
        """
        __getitem__(self, index) -> float

        Return the float component at the specified index.  This method makes
        vectors behave as sequences (so you can, for example, use a for loop on
        the elements of a vector, convert a vector to a tuple of floats, etc.)
        and lets you use square brackets to index into a vector.

          >>> v = hou.Vector2((1.0, 2.0))
          >>> v[-1]
          2.0
        """
        return 0.0

    def __setitem__(self, index, value):
        """
        __setitem__(self, index, value)

        This method lets you use square brackets to set a value on a vector.

          >>> v = hou.Vector2((1.5, 2.5))
          >>> v[0] = 0.5
          >>> print v
          [0.5, 2.5]
        """

    def __len__(self):
        """
        __len__(self) -> int

        Returns 2.  This method lets you call len() on a Vector2.
        """
        return 0

    def setTo(self, sequence):
        """
        setTo(self, sequence)

        Set the contents of this vector to a sequence of floats.

        Raises InvalidSize if values is not 2 elements long, or TypeError if
        values is not a sequence of floats or ints.
        """

    def __add__(self, vector2):
        """
        __add__(self, vector2) -> hou.Vector2

        Add two vectors, returning a new vector with each component equal to the
        sum of the corresponding components in the two vectors.  This method
        lets you write v1 + v2, where v1 and v2 are Vector2 objects.

        This method is equivalent to hou.Vector2(self[0] + vector2[0], self[1] +
        vector2[1]).
        """
        return Vector2()

    def __sub__(self, vector2):
        """
        __sub__(self, vector2) -> hou.Vector2

        Subtract a vector from another, returning a new vector with each
        component equal to the first vector's corresponding component minus the
        second vector's.  This method lets you write v1 - v2, where v1 and v2
        are Vector2 objects.

        This method is equivalent to hou.Vector2(self[0] - vector2[0], self[1] -
        vector2[1]).
        """
        return Vector2()

    def __neg__(self):
        """
        __neg__(self) -> hou.Vector2

        Return a vector whose components contain the negative values of this
        vector's components.  This method lets you write -v, where v is a
        Vector2 object.

        This method is equivalent to hou.Vector2(-self[0], -self[1]).
        """
        return Vector2()

    def __mul__(self, scalar):
        """
        __mul__(self, scalar) -> hou.Vector2

        Multiply a vector with a float scalar, returning a new vector.  This
        method lets you write v * s where v is a vector and s is a float.

        This method is equivalent to hou.Vector2(self[0] * scalar, self[1] *
        scalar).
        """
        return Vector2()

    def normalized(self):
        """
        normalized(self) -> hou.Vector2

        Interpreting this vector as a direction, return a vector with the same
        direction but with a length of 1.

        If the vector's length is 0 (or close to it), the result is the original
        vector.

        For vector's with non-zero lengths, this method is equivalent to self *
        (1.0/self.length()).
        """
        return Vector2()

    def length(self):
        """
        length(self) -> float

        Interpret this vector as a direction vector and return its length. The
        result is the same as math.sqrt(self[0]**2 + self[1]**2).
        """
        return 0.0

    def lengthSquared(self):
        """
        lengthSquared(self) -> float

        Interpret this vector as a direction vector and return the square of its
        length.  The result is the same as self[0]**2 + self[1]**2.
        """
        return 0.0

    def distanceTo(self, vector2):
        """
        distanceTo(self, vector2) -> float

        Interpret this vector and the argument as 2D positions, and return the
        distance between them.  The return value is equivalent to (self -
        vector2).length().
        """
        return 0.0

    def dot(self, vector2):
        """
        dot(self, vector2) -> float

        Return the dot product between this vector and the one in the parameter.

        See Wikipedia's dot product page.
        """
        return 0.0

    def _asVoidPointer(self): return

class Vector3(object):
    """
    hou.Vector3

    A sequence of 3 floating point values, with associated mathematical
    operations.

    A Vector3 might be used to represent a position in 3D space, or a 3D
    direction with a length.

    See also hou.Vector2 and hou.Vector4.


    """

    def __init__(self, values=(0.0, 0.0, 0.0)):
        """
        __init__(self, values=(0.0, 0.0, 0.0))

        Return a new Vector3 from a sequence of floats.  If this method is
        called without parameters, the resulting vector contains the values
        (0.0, 0.0, 0.0).

        You can also construct a Vector3 from a hou.Vector4.  The result
        contains the first 3 values in the Vector4.

        Raises InvalidSize if values is not 3 elements long, or TypeError if
        values is not a sequence of floats.
        """
    def isAlmostEqual(self, vector3, tolerance=0.00001):
        """
        isAlmostEqual(self, vector3, tolerance=0.00001) -> bool

        Return whether this vector is equal to another, within a tolerance.
        Verifies that the difference between each component of this vector and
        the corresponding component of the other vector is within the tolerance.
        """
        return True

    def almostEqual(self): return _hou.Vector3_almostEqual(*args)
    def __getitem__(self):
        """
        __getitem__(self, index) -> float

        Return the float component at the specified index.  This method makes
        vectors behave as sequences (so you can, for example, use a for loop on
        the elements of a vector, convert a vector to a tuple of floats, etc.)
        and lets you use square brackets to index into a vector.

          >>> v = hou.Vector3((1.0, 2.0, 3.0))
          >>> v[-1]
          3.0
        """
        return 0.0

    def __setitem__(self, index, value):
        """
        __setitem__(self, index, value)

        This method lets you use square brackets to set a value on a vector.

          >>> v = hou.Vector3((1.5, 2.5, 3.5))
          >>> v[1] = 0.5
          >>> print v
          [1.5, 0.5, 3.5]
        """

    def __len__(self):
        """
        __len__(self) -> int

        Returns 3.  This method lets you call len() on a Vector3.
        """
        return 0.0

    def setTo(self, sequence):
        """
        setTo(self, sequence)

        Set the contents of this vector to a sequence of floats.

        Raises InvalidSize if values is not 3 elements long, or TypeError if
        values is not a sequence of floats or ints.

        REPLACES
            vset function        """

    def __add__(self, vector3):
        """
        __add__(self, vector3) -> hou.Vector3

        Add two vectors, returning a new vector with each component equal to the
        sum of the corresponding components in the two vectors.  This method
        lets you write v1 + v2, where v1 and v2 are Vector3 objects.

        This method is equivalent to hou.Vector3(self[0] + vector3[0], self[1] +
        vector3[1], self[2] + vector3[2]).
        """
        return Vector3()

    def __sub__(self, vector3):
        """
        __sub__(self, vector3) -> hou.Vector3

        Subtract a vector from another, returning a new vector with each
        component equal to the first vector's corresponding component minus the
        second vector's.  This method lets you write v1 - v2, where v1 and v2
        are Vector3 objects.

        This method is equivalent to hou.Vector3(self[0] - vector3[0], self[1] -
        vector3[1], self[2] - vector3[2]).
        """
        return Vector3()

    def __neg__(self):
        """
        __neg__(self) -> hou.Vector3

        Return a vector whose components contain the negative values of this
        vector's components.  This method lets you write -v, where v is a
        Vector3 object.

        This method is equivalent to hou.Vector3(-self[0], -self[1], -self[2]).
        """
        return Vector3()

    def __rmul__(self, scalar):
        """
        __rmul__(self, scalar) -> hou.Vector3

        Multiply this vector with a scalar, returning a new vector.  This method
        lets you write s * v, where v is a vector and s is a float scalar. See
        also hou.Vector3.__mul__, which lets you write v * s.

          >>> v = hou.Vector3(1, 2, 3)
          >>> v * 2
          <hou.Vector3 [2, 4, 6]>
          >>> 2 * v
          <hou.Vector3 [2, 4, 6]>

        REPLACES
            vscale function        """
        return Vector3()

    def __mul__(self, scalar_or_matrix4):
        """
        __mul__(self, scalar_or_matrix4) -> hou.Vector3

        Multiply this vector with a scalar or with a matrix, returning a new
        vector.  This method lets you write v * s or v * m where v is a vector,
        s is a float scalar, and m is a hou.Matrix4.

        When the parameter is a float scalar s, this method is equivalent to
        hou.Vector3(self[0] * s, self[1] * s, self[2] * s).

        In order multiply the Vector3 by a Matrix4, the Vector3 is converted to
        a Vector4 with the fourth component set to 1.0.  The effect is that the
        vector is treated as a position, so if the transformation matrix
        contains a translation component, the return value will be translated.
        If you would like to transform a vector (so translations are ignored but
        rotations, for example, apply), you'll need to transform a corresponding
        hou.Vector4 with the fourth component set to zero:
          # Build a transformation matrix that rotates 180 degrees about z and then translates by 1 in x.
          >>> matrix = hou.hmath.buildRotateAboutAxis((0, 0, 1), 180) * hou.hmath.buildTranslate((1, 0, 0))
          >>> position = hou.Vector3(0.0, 1.0, 0.0)

          # Rotate the point (0,1,0) to (0,-1,0), then translate to (1,-1,0).
          >>> position * matrix
          <hou.Vector3 [1, -1, 0]>

          # Rotate the vector (0,1,0) to (0,-1,0), ignoring the translation.
          >>> vector = hou.Vector4(tuple(position) + (0.0,))
          >>> vector
          <hou.Vector4 [0, 1, 0, 0]>
          >>> vector * matrix
          <hou.Vector4 [0, -1, 0, 0]>
          >>> hou.Vector3(vector * matrix)
          <hou.Vector3 [0, -1, 0]>

          # We could have wrapped the above in a function:
          >>> def transformAsVector(vector3):
          ...     return hou.Vector3(hou.Vector4(tuple(vector3) + (0.0,)) * matrix)
          >>> transformAsVector(position)
          <hou.Vector3 [0, -1, 0]>

          # Change the Vector4's last component to 1 to illustrate that it's transformed as a point again.
          >>> vector[-1] = 1.0
          >>> vector
          <hou.Vector4 [0, 1, 0, 1]>
          >>> vector * matrix
          <hou.Vector4 [1, -1, 0, 1]>


        See also hou.Matrix4.

        REPLACES
            vscale function        """
        return Vector3()

    def normalized(self):
        """
        normalized(self) -> hou.Vector3

        Interpret this vector as a direction and return a vector with the same
        direction but with a length of 1.

        If the vector's length is 0 (or close to it), the result is the original
        vector.

        For vectors with non-zero lengths, this method is equivalent to self *
        (1.0/self.length()).

        REPLACES
            normalize function        """
        return Vector3()

    def length(self):
        """
        length(self) -> float

        Interpret this vector as a direction vector and return its length. The
        result is the same as math.sqrt(self[0]**2 + self[1]**2 + self[2]**2).

        REPLACES
            vlength function
            length function        """
        return 0.0

    def lengthSquared(self):
        """
        lengthSquared(self) -> float

        Interpret this vector as a direction vector and return the square of its
        length.  The result is the same as self[0]**2 + self[1]**2 + self[2]**2.

        REPLACES
            vlength2 function        """
        return 0.0

    def matrixToRotateTo(self, vector3):
        """
        matrixToRotateTo(self, vector3) -> hou.Matrix4

        Return a matrix that rotates this vector onto vector3, rotating about
        the axis perpendicular to the two vectors.  If the two vectors have the
        same direction, return the identity matrix.

        REPLACES
            dihedral function        """
        return Matrix4()

    def distanceTo(self, vector3):
        """
        distanceTo(self, vector3) -> float

        Interpret this vector and the argument as 3D positions, and return the
        distance between them.  The return value is equivalent to (self -
        vector3).length().

        REPLACES
            distance function        """
        return 0.0

    def angleTo(self, vector3):
        """
        angleTo(self, vector3) -> float

        Interprets this Vector3 and the parameter as directions and returns the
        angle (in degrees) formed between the two vectors when you place the
        origins at the same location.

        REPLACES
            vangle function        """
        return 0.0
    def dot(self, vector3):
        """
        dot(self, vector3) -> float

        Return the dot product between this vector and the one in the parameter.
        This value is equal to self[0]*vector3[0] + self[1]*vector3[1] +
        self[2]*vector3[2], which is also equal to self.length() *
        vector3.length() * math.cos(hou.hmath.degToRad(self.angleTo(vector3)))

        See Wikipedia's dot product page.

        REPLACES
            dot function        """
        return 0.0

    def cross(self):
        """
        cross(self, vector3) -> hou.Vector3

        Return the cross product of this vector with another vector.  The return
        value is a vector that is perpendicular to both vectors, pointing in the
        direction defined by the right-hand rule, with length self.length() *
        vector3.length() *
        math.sin(hou.hmath.degToRad(self.angleTo(vector3))).

        See Wikipedia's cross product page.

        REPLACES
            cross function        """
        return Vector3()

    def _asVoidPointer(self): return

class Vector4(object):
    """
    hou.Vector4

    A sequence of 4 floating point values, with associated mathematical
    operations.

    A Vector4 could be used to represent a position or direction in 4D
    space. In 3D math, however, it is more commonly used to represent either
    a position or a vector, depending on the value of the fourth component.
    Positions have a fourth component of 1.0, and vectors have a fourth
    component of 0.0. Subtracting a position from another yields a vector,
    adding two vectors together yields a vector, and adding a point and a
    vector yields a point. Operations that yield a fourth component value
    other than 0 or 1, like adding two points together, are not valid.
    Similarly, is makes sense to speak about a vector's length but not a
    position's length.  The fourth component also affects how the
    position/vector is transformed; see hou.Vector3.__mul__ for more
    information.

    See also hou.Vector2 and hou.Vector3.
    """
    def __init__(self, values=(0.0, 0.0, 0.0, 0.0)):
        """
        __init__(self, values=(0.0, 0.0, 0.0, 0.0))

        Return a new Vector4 from a sequence of floats.  If this method is
        called without parameters, the resulting vector contains the values
        (0.0, 0.0, 0.0, 0.0).

        You can also construct a Vector4 from a hou.Vector3.  The new vector has
        its fourth component set to 1.0.

        Raises InvalidSize if values is not 4 elements long, or TypeError if
        values is not a sequence of floats or ints.
        """
    def isAlmostEqual(self, vector4, tolerance=0.00001):
        """
        isAlmostEqual(self, vector4, tolerance=0.00001) -> bool

        Return whether this vector is equal to another, within a tolerance.
        Verifies that the difference between each component of this vector and
        the corresponding component of the other vector is within the tolerance.
        """
        return True
    def almostEqual(self): return
    def __hash__(self): return
    def __str__(self): return
    def __repr__(self): return
    def __getitem__(self):
        """
        __getitem__(self, index) -> float

        Return the float component at the specified index.  This method makes
        vectors behave as sequences (so you can, for example, use a for loop on
        the elements of a vector, convert a vector to a tuple of floats, etc.)
        and lets you use square brackets to index into a vector.
        """
        return 0.0

    def __setitem__(self, index, value):
        """
        __setitem__(self, index, value)

        This method lets you use square brackets to set a value on a vector.
        """

    def __len__(self):
        """
        __len__(self) -> int

        Returns 4.  This method lets you call len() on a Vector4.
        """
        return 0

    def setTo(self, sequence):
        """
        setTo(self, sequence)

        Set the contents of this vector to a sequence of floats.

        Raises InvalidSize if values is not 4 elements long, or TypeError if
        values is not a sequence of floats or ints.
        """

    def __add__(self, vector4):
        """
        __add__(self, vector4) -> hou.Vector4

        Add two vectors, returning a new vector with each component (including
        the last one) equal to the sum of the corresponding components in the
        two vectors.  This method lets you write v1 + v2, where v1 and v2 are
        Vector4 objects.

        This method is equivalent to hou.Vector4(self[0] + vector4[0], self[1] +
        vector4[1], self[2] + vector4[2], self[3] + vector4[3]).
        """
        return Vector4()

    def __sub__(self):
        """
        __sub__(self, vector4) -> hou.Vector4

        Subtract a vector from another, returning a new vector with each
        component (including the last one) equal to the first vector's
        corresponding component minus the second vector's.  This method lets you
        write v1 - v2, where v1 and v2 are Vector4 objects.

        This method is equivalent to hou.Vector4(self[0] - vector4[0], self[1] -
        vector4[1], self[2] - vector4[2], self[3] - vector4[3]).
        """
        return Vector4()

    def __rmul__(self, scalar):
        """
        __rmul__(self, scalar) -> hou.Vector4

        Multiply this vector with a scalar, returning a new vector.  This method
        lets you write s * v, where v is a vector and s is a float scalar. See
        also hou.Vector4.__mul__, which lets you write v * s.

          >>> v = hou.Vector4(1, 2, 3, 4)
          >>> v * 2
          <hou.Vector3 [2, 4, 6, 8]>
          >>> 2 * v
          <hou.Vector3 [2, 4, 6, 8]>
        """
        return Vector4()

    def __mul__(self, scalar_or_matrix4):
        """
        __mul__(self, scalar_or_matrix4) -> hou.Vector4

        Multiply a vector with a scalar or with a matrix, returning a new
        vector. This method lets you write v * s or v * m where v is a vector, s
        is a float scalar, and m is a hou.Matrix4.

        See hou.Vector3.__mul__ for more information.
        """
        return Vector4()

    def normalized(self):
        """
        normalized(self) -> Vector4

        Interpret this vector as a 4D direction and return a vector with the
        same direction but with a length of 1.  If this vector being used to
        represent a 3D direction (so the fourth component is 0), the result is
        still meaningful, and represents the corresponding 3D direction.

        If the vector's length is 0 (or close to it), the result is the original
        vector.

        For vectors with non-zero lengths, this method is equivalent to self *
        (1.0/self.length()).
        """
        return Vector4()

    def length(self):
        """
        length(self) -> float

        Interpret this vector as a 4D direction vector and return its length.
        If this vector is representing a 3D direction (so the fourth component
        is 0), the result is the 3D length.

        The result is the same as math.sqrt(self[0]**2 + self[1]**2 + self[2]**2
        + self[3]**2).
        """
        return 0.0

    def lengthSquared(self):
        """
        lengthSquared(self) -> float

        Return the result of self.length()**2.  The result is the same as
        self[0]**2 + self[1]**2 + self[2]**2 + self[3]**2.
        """
        return 0.0

    def dot(self):
        """
        dot(self, vector4) -> float

        Return the dot product between this 4D vector and the one in the
        parameter. This value is equal to self[0]*vector4[0] +
        self[1]*vector4[1] + self[2]*vector4[2] + self[3]*vector4[3].
        """
        return 0.0

    def _asVoidPointer(self): return

class Vertex(object):
    """
    hou.Vertex

    Existing inside a Geometry object, a Vertex object is contained in
    exactly one Prim, and references exactly one Point.

    This setup allows points to be shared between primitives.  For example,
    a polygon contains its own list of vertices that are not shared with
    other primitives, but vertices in different polygons may refer to the
    same point. When that point moves, the corresponding vertices on all
    adjacent polygons will also move, preventing polygon edges from
    separating.

    Note that you can use hou.Vertex.point to retrieve a point from a
    vertex, but there is no method to retrieve all the vertices referring to
    a point. Houdini does not store this information internally, but you can
    derive it.  The best way to quickly retrieve this information is to
    build a dictionary mapping all points to sets of vertices, and then
    reuse this dictionary in your algorithm.


    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def geometry(self):
        """
        geometry(self) -> Geometry

        Return the hou.Geometry object containing this vertex.
        """
        return Geometry()
    def prim(self):
        """
        prim(self) -> hou.Prim

        Return the hou.Prim object containing this vertex.

        If the primitive is a face, use hou.Prim.vertices to access the other
        vertices in the primitive.  If it is a surface, use hou.Surface.vertex,
        hou.Surface.numRows, and hou.Surface.numCols.
        """
        return Prim()
    def point(self):
        """
        point(self) -> hou.Point

        Return the hou.Point object that this vertex refers to.  Each vertex
        refers to exactly one point.
        """
        return Point()

    def number(self):
        """
        number(self) -> int

        Return the number of this vertex.  Vertices in the same primitive are
        numbered sequentially starting from 0, and the vertices returned by
        hou.Prim.vertices are in order by their number.
        """
        return 0

    def attribType(self):
        """
        attribType(self) -> hou.attribType enum value

        Return the enumerated value hou.attribType.Vertex.  Points, primitives,
        vertices, and geometry support the same set of methods for querying
        their attributes, and this method is one of them.

        See also:

        * hou.Point.attribType
        * hou.Prim.attribType
        * hou.Geometry.attribType
        * hou.attribType        """
        return attribType()

    def floatAttribValue(self, name_or_attrib):
        """
        floatAttribValue(self, name_or_attrib) -> float

        Return the vertex attribute value for a particular floating point
        attribute.  The attribute may be specified by name or by hou.Attrib
        object.

        Raises hou.OperationFailed if no attribute exists with this name or the
        attribute is not float of size 1.

        In most cases, you'll just use hou.Vertex.attribValue to access
        attribute values.  Houdini uses this method internally to implement
        attribValue.
        """
        return 0.0

    def floatListAttribValue(self, name_or_attrib):
        """
        floatListAttribValue(self, name_or_attrib) -> tuple of float

        Return the vertex attribute value for a particular floating point
        attribute.  The attribute may be specified by name or by hou.Attrib
        object.  The return value is a tuple of floats.

        It is valid to call this method when the attribute's size is 1.  In this
        case, a tuple with one element is returned.

        See also hou.Vertex.attribValue.
        """
        return (0.0,)

    def intAttribValue(self):
        """
        intAttribValue(self, name_or_attrib) -> int

        Return the vertex attribute value for a particular integer attribute of
        size 1.  The attribute may be specified by name or by hou.Attrib object.
        See hou.Vertex.floatAttribValue for more information.
        """
        return 0

    def intListAttribValue(self, name_or_attrib):
        """
        intListAttribValue(self, name_or_attrib) -> tuple of int

        Return the vertex attribute value for a particular integer attribute.
        The attribute may be specified by name or by hou.Attrib object.  The
        return value is a tuple of ints.  See hou.Vertex.floatListAttribValue
        for more information.
        """
        return (0,)

    def stringAttribValue(self, name_or_attrib):
        """
        stringAttribValue(self, name_or_attrib) -> str

        Return the vertex attribute value for a particular string attribute.
        The attribute may be specified by name or by hou.Attrib object.  See
        hou.Vertex.floatAttribValue for more information.
        """
        return ''

    def stringListAttribValue(self, name_or_attrib):
        """
        stringListAttribValue(self, name_or_attrib) -> tuple of str

        Return the vertex attribute value for a particular string attribute.
        The attribute may be specified by name or by hou.Attrib object.  The
        return value is a tuple of strings.

        It is valid to call this method when the attribute's size is 1.  In this
        case, a tuple with one element is returned.

        See also hou.Vertex.attribValue.
        """
        return ('',)

    def setAttribValue(self, name_or_attrib, attrib_value):
        """
        setAttribValue(self, name_or_attrib, attrib_value)

        Store an attribute value in this vertex.  The attribute may be specified
        by name or by hou.Attrib object, and must be an existing vertex
        attribute in the geometry.  You would typically call this method from
        the code of a Python-defined SOP.

        Raises hou.OperationFailed if no attribute exists with this name or if
        the attribute's data type does not match the value passed in.  If the
        attribute's size is more than 1, the attribute value must be a sequence
        of integers/floats, and the size of the sequence must match the
        attribute's size.

        Raises hou.GeometryPermissionError if this geometry is not modifiable.
        """

    def attribValue(self, name_or_attrib):
        """
        attribValue(self, name_or_attrib) -> int, float, str or tuple

        Return the value store in this vertex for a particular attribute.  The
        attribute may be specified by name or by hou.Attrib object.

        Looking an attribute value using a hou.Attrib object is slightly faster
        than looking it up by name.  When looking up attribute values inside a
        loop, look up the hou.Attrib object outside the loop, and pass it into
        this method.

        Raises hou.OperationFailed if no attribute exists with this name.

        REPLACES
            vertex function
            vertexs function        """

class VexContext(object):
    """
    hou.VexContext

    REPLACES
      * vexinfo
    """
    def __init__(self): raise AttributeError, "No constructor defined"
    def name(self):
        """
        name(self) -> string
        """
        return ''

    def nodeTypeCategory(self):
        """
        nodeTypeCategory(self) -> NodeTypeCategory
        """
        return NodeTypeCategory()

    def shaderType(self):
        """
        shaderType(self) -> hou.shaderType enum value or None
        """
        return shaderType()

    def pathsToLoadedVexFunctions(self):
        """
        pathsToLoadedVexFunctions(self) -> dict of names to paths
        """
        return {'':''}

class ViewerState(object):
    """
    hou.ViewerState
    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def name(self):
        """
        name(self) -> string
        """
        return ''
    def description(self):
        """
        description(self) -> string
        """
        return ''

    def icon(self):
        """
        icon(self) -> string
        """
        return ''

    def categories(self):
        """
        categories(self) -> tuple of NodeTypeCategories
        """
        return (NodeTypeCategories(),)

    def nodeType(self):
        """
        nodeType(self) -> NodeType
        """
        return NodeType()

    def isHidden(self): return True

class Volume(Prim):
    """
    hou.Volume

    A Volume is a kind geometry primitive (Prim object) storing a three
    dimensional array of voxels.
    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def sample(self, position):
        """
        sample(self, position) -> float

        Given a sequence of three floats containing a 3D position, return the
        value of the volume at that position.  If the position is not in the
        middle of a voxel, Houdini will interpolate using values from
        surrounding voxels.

        See also hou.Volume.voxel and hou.Volume.posToIndex.
        """
        return 0.0

    def gradient(self, position):
        """
        gradient(self, position) -> hou.Vector3

        Given a sequence of three floats containing a 3D position, return a
        vector which points in the direction of the greatest rate of increase of
        the volume's value.

        See Wikipedia's gradient page for more information.
        """
        return Vector3()

    def voxel(self, index):
        """
        voxel(self, index) -> float

        Given a sequence of three integers containing a voxel index, return the
        value of the corresponding voxel.

          >>> volume_sop = hou.node("/obj").createNode("geo").createNode("volume")
          >>> volume_sop.parm("initialval1").set(0.3)
          >>> volume = volume_sop.geometry().prims()[0]
          >>> volume.resolution()
          (10, 10, 10)
          >>> volume.voxel((0, 0, 0))
          0.3
        """
        return 0.0

    def setVoxel(self, index, value):
        """
        setVoxel(self, index, value)

        Set the value of a voxel.  You would typically call this method from the
        code of a Python-defined SOP.

        index
            A sequence of three integers containing a voxel index.  Raises
            hou.OperationFailed if any of the values in index are out of range.

        value
            A float containing the voxel's new value.

        Raises hou.GeometryPermissionError if this geometry is not modifiable.
        """

    def allVoxels(self):
        """
        allVoxels(self) -> tuple of float

        Return a tuple of floats containing the values of all voxels.  It is
        faster to call this method to retrieve all the voxels than it is to loop
        through the voxel array in Python.

        You can, for example, use Python's Numpy library to perform operations
        on the voxel data and then store the result back into the volume from a
        Python SOP using hou.Volume.setAllVoxels.  Note that Numpy allows you to
        reshape the flat tuple of floats to behave like a 3D matrix of floats.

        This method can be approximately implemented as follows (though this
        Python implementation is much slower):
          def allVoxels(self):
              result = []
              xres, yres, zres = self.resolution()
              for z in range(zres):
                  for y in range(yres):
                      for x in range(xres):
                          result.append(self.voxel((x, y, z)))
              return tuple(result)


        See also hou.Volume.allVoxelsAsString,
        hou.Geometry.pointFloatAttribValues, and
        hou.Geometry.primFloatAttribValues.
        """
        return (0.0,)

    def allVoxelsAsString(self):
        """
        allVoxelsAsString(self) -> str

        Return a binary string representation of the floats containing all the
        values of all voxels.  This method is faster than hou.Volume.allVoxels,
        and you can use the array module to convert the string into a Python
        sequence.

        This method provides a faster implementation of the following:
          import array
          def allVoxelsAsString(self):
              return array.array("f", self.allVoxels()).tostring()


        You can convert the return value from this method to an array using the
        following method:
          import array
          def allVoxelsAsArray(volume):
              a = array.array("f")
              a.fromstring(volume.allVoxelsAsString())
              return a


        See hou.Volume.allVoxels for more information.
        """
        return ''

    def setAllVoxels(self, values):
        """
        setAllVoxels(self, values)

        Set the value of all voxels in this volume.  You would typically call
        this method from the code of a Python-defined SOP.

        Raises hou.OperationFailed if the sequence of values is not exactly the
        same as self.resolution()[0] * self.resolution()[1] *
        self.resolution()[2].

        Raises hou.GeometryPermissionError if this geometry is not modifiable.

        See also hou.Volume.allVoxels.
        """

    def setAllVoxelsFromString(self, values):
        """
        setAllVoxelsFromString(self, values)

        Set the value of all voxels in this volume from a string representation
        of a sequence of single precision float values.  This method is faster
        than hou.Volume.setAllVoxels.

        Note that this method can accept more types that just a string: it can
        receive any Python object that supports the buffer interface.  In
        particular, arrays from the array and numpy Python modules are
        supported, so there is no need to first construct strings from those
        arrays.

        Raises hou.OperationFailed if the length of the string is not exactly
        the same as self.resolution()[0] * self.resolution()[1] *
        self.resolution()[2] * 4.

        See hou.Volume.setAllVoxels and hou.Volume.allVoxelsAsString for more
        information.

        The following example function accepts an array.array("f") and sets
        the voxels to its contents:
          def setAllVoxelsFromArray(volume, arr):
              assert(arr.typecode == "f")
              volume.setAllVoxelsFromString(arr)
        """

    def voxelSlice(self, index):
        """
        voxelSlice(plane, index) -> tuple of float

        Return a tuple of floats containing the values of all voxels in a
        particular slice.  It is faster to call this method to retrieve a slice
        than it is to loop through the voxel array in Python.

        plane
            The plane corresponding to this slice.  This value must be either
            "xy", "xz", or "yz".

        index
            The index of this slice in the array.  For example, if the plane is
            "xy", this index is the z value and the result will contain all
            values in the voxel with this particular z value.

        This method can be approximately implemented as follows (though this
        Python implementation is much slower):
          def voxelSlice(self, plane, index):
              result = []

              start = [0] * 3
              stop = list(self.resolution())

              slice_axis = {"xy": 2, "xz": 1, "yz": 0}[plane]
              start[slice_axis] = index
              stop[slice_axis] = index + 1

              for z in range(start[2], stop[2]):
                  for y in range(start[1], stop[1]):
                      for x in range(start[0], stop[0]):
                          result.append(self.voxel((x, y, z)))
              return tuple(result)


        See also hou.Volume.voxelSliceAsString and hou.Volume.allVoxels.
        """
        return (0.0,)

    def voxelSliceAsString(self, index):
        """
        voxelSliceAsString(plane, index) -> str

        Return a binary string representation of the floats containing all the
        values of voxels in a particular slice.

        See hou.Volume.voxelSlice and hou.Volume.allVoxelsAsString for more
        information.
        """
        return ''

    def setVoxelSlice(self, values, plane, index):
        """
        setVoxelSliceFromString(self, values, plane, index)

        Set the value of the voxels in a particular slice of this volume.  You
        would typically call this method from the code of a Python-defined SOP.

        values
            A binary string representing of a sequence of floats containing the
            new values for the slice.

            Note that this method can accept more types that just a string: it
            can receive any Python object that supports the buffer interface.
            In particular, arrays from the array and numpy Python modules are
            supported, so there is no need to first construct strings from those
            arrays.

        plane
            The plane corresponding to this slice.  This value must be either
            "xy", "xz", or "yz".

        index
            The index of this slice in the array.

        See hou.Volume.setVoxelSlice for more information.

        The following example builds a volume from an compositing network
        sequence:
          def buildVolumeFromCopSequence(
                  cop_node, geo, voxel_depth, plane="C", component="r"):
              zres = int(cop_node.sequenceFrameLength())
              volume_bbox = hou.BoundingBox((
                  0, 0, 0,
                  cop_node.xRes(), cop_node.yRes(), zres) * voxel_depth)
              volume = geo.createVolume(
                  cop_node.xRes(), cop_node.yRes(), zres, volume_bbox)

              for z in range(zres):
                  pixels = cop_node.allPixelsAsString(
                      plane, component,
                      time=hou.frameToTime(z + cop_node.sequenceStartFrame()))
                  volume.setVoxelSliceFromString(pixels, "xy", z)
        """

    def setVoxelSliceFromString(self): return
    def resolution(self):
        """
        resolution(self) -> hou.Vector3

        Return the x, y, and z dimensions of the volume.  For example, a
        resolution of (10, 20, 30) means the volume is 10 voxels in x by 20
        voxels in y by 30 voxels in z.
        """
        return Vector3()

    def indexToPos(self, index):
        """
        indexToPos(self, index) -> hou.Vector3

        Given a sequence of three ints containing an index into the voxel array,
        return the corresponding 3D position of the middle of that voxel.
        """
        return Vector3()

    def posToIndex(self, position):
        """
        posToIndex(self, position) -> tuple of int

        Given a sequence of three floats containing a 3D position, return a
        tuple of three ints containing the corresponding index into the voxel
        array.

        Note that the returned index will be invalid if the position is outside
        the volume.  Use hou.Volume.isValidIndex to determine if the index is
        valid.
        """
        return (0,)

    def isValidIndex(self, index):
        """
        isValidIndex(self, index) -> bool

        Return whether or not a sequence of three ints containing an index into
        the voxel array is valid, ie, within the bounds of the array.

        This method can approximately be implemented as follows:
          def isValidIndex(self, index):
              for i, maximum in zip(index, self.resolution()):
                  if i < 0 or i >= maximum:
                      return False
              return True
        """
        return True

    def isSDF(self):
        """
        isSDF(self) -> bool

        Return whether or not the volume is flagged as a signed distance field.
        Such volumes have a special border condition where out of bound reads
        will add the distance to the bounding box to the streaked boundary
        condition. They are also best to be semantically treated as signed
        distance fields.
        """
        return True

    def volumeMax(self):
        """
        volumeMax(self) -> float

        Return the maximum value of all voxels.
        """
        return 0.0

    def volumeMin(self):
        """
        volumeMin(self) -> float

        Return the minimum value of all voxels.
        """
        return 0.0

    def volumeAverage(self):
        """
        volumeAverage(self) -> float

        Return the average value of all voxels.
        """
        return 0.0

    def transform(self):
        """
        transform(self) -> hou.Matrix3

        Return a 3x3 matrix containing the scale and rotation transformations
        for this volume.

        Note that the position information for the volume can be obtained by
        calling volume.vertex(0).point().position().

        The following function returns a 4x4 transformation matrix for the
        volume that includes the translation:
          def fullTransform(volume):
              return (hou.Matrix4(volume.transform()) *
                  hou.hmath.buildTranslate(volume.vertex(0).point().position()))



        You need to get the node transform to get to worldspace.
        """
        return Matrix3()

    def setTransform(self, matrix4):
        """
        setTransform(self, matrix4)

        Given a 4x4 matrix, set the position, rotation, and scale of this
        volume.

        Note that if you want to just set the translate portion of a volume to a
        hou.Vector3, you could just call
        volume.vertex(0).point().setPosition(position).
        """

    def taperX(self): return
    def taperY(self): return
    def vertex(self, index):
        """
        vertex(self, index) -> hou.Vertex

        A shortcut for self.vertices()[index].  You probably don't need to call
        this method.

        This method supports negative indices to index from the end, just like
        self.vertices()[index] would.  Also, like Python's indexing operator, it
        will raise IndexError when the index is out of range.
        """
        return Vertex()

class VopNetNode(Node):
    """
    hou.VopNetNode
    """

    def __init__(self): raise AttributeError, "No constructor defined"
    def definedType(self):
        """
        definedType(self) -> NodeType
        """
        return NodeType()

    def vexContext(self):
        """
        vexContext(self) -> VexContext
        """
        return VexContext()

    def shaderType(self):
        """
        shaderType(self) -> hou.shaderType enum value or None
        """
        return shaderType()

class VopNode(Node):
    """
    hou.VopNode
    Represents a VOP (VEX Operator) node.
    """
    def __init__(self): raise AttributeError, "No constructor defined"
    def insertParmGenerator(self, input_name, parm_gen_type,
        reference_input_defaults):
        """
        insertParmGenerator(self, input_name, parm_gen_type,
        reference_input_defaults) -> `hou.VopNode

        Creates a parameter or a constant node and wires it into an input
        specified by input_name on this node.  parm_gen_type must be a value of
        hou.vopParmGenType.  If reference_input_defaults is True, this node will
        reference the defaults of the newly created node.

        A resultant parameter or constant node is returned.
        """
        return _VopNode()

    def insertParmGeneratorsForAllInputs(self, parm_gen_type,
        reference_input_defaults):
        """
        insertParmGeneratorsForAllInputs(self, parm_gen_type,
        reference_input_defaults) -> dict of str to hou.VopNode

        Creates parameter or constant nodes and wires them into unconnected
        inputs on this node.  parm_gen_type must be a value of
        hou.vopParmGenType.  If reference_input_defaults is True, then this node
        will reference the defaults of the newly created nodes.

        A dictionary is returned with input names for keys and hou.VopNode
        objects for values.
        """
        return {'':VopNode()}

    def deleteIndependentInputNodes(self, input_index, make_parm_node,
        reference_input_defaults):
        """
        deleteIndependentInputNodes(self, input_index):, make_parm_node,
        reference_input_defaults) -> bool

        Deletes a chain of nodes wired into a particular input if and only if
        they are wired only into the specified input on this node. Returns true
        if nodes were deleted, false otherwise.
        """
        return True

    def dependsOnlyOn(self): return
    def setIsInputVisible(self, input_name, is_visible):
        """
        setIsInputVisible(self, input_name, is_visible)

        Shows or hides an input connector of this node. The input is specified
        by input_name. The connector is shown if is_visible is True, and hidden
        otherwise.
        """

    def isInputVisible(self, input_name):
        """
        isInputVisible(self, input_name) -> bool

        Returns True if the input connector specified by input_name on this node
        is visible, False otherwise.
        """
        return True

    def shaderString(self): return
    def shaderCode(self, shader_type=hou.shaderType.Surface):
        """
        shaderCode(self, shader_type=hou.shaderType.Surface) -> str

        Returns the generated VEX or RSL code for this VOP, using the given
        shader type to control output context. If the VOP is a subnet that can
        be  packaged up as an encapsulated shader, then the specific code to
        define an  encapsulated shader is output. Otherwise, the code generated
        for the  entire VOP network is output.
        """
        return ''

    def shaderName(self, as_otl_path=True, shader_type_name=None):
        """
        shaderName(self, as_otl_path=True, shader_type_name=None) -> str

        Return the name of the shader defined by this VOP (if it is an embedded
        shader) or the shader name defined by the shop in which this VOP
        resides.   If as_otl_path is True, returns an opdef: path to the SHOP
        type. The shader_type_name is a string indicating the shader context
        type to use; some nodes may provide several shader types, and each may
        have a different name. This is applicable only to multi-context shader
        nodes, such as a vopnet material shop.
        """
        return ''

    def shaderType(self):
        return
    def currentSignatureName(self):
        """
        currentSignatureName(self) -> str

        Returns the current signature name of this node. The HDA nodes may
        provide several valid signatures, and this function returns the name of
        the currently used signature. A signature is defined by a set of input
        types and each set is assigned a name.
        """
        return  ''

class Node(SopNode, ChopNode, CopNode, ShopNode, DopNode, PopNetNode, RopNode, SopNode, VopNode, VopNetNode, ObjNode):
# class Node(object):
    """
    hou.Node

    The base class for all nodes in Houdini (objects, SOPs, COPs, etc.)  An
    instance of this class corresponds to exactly one instance of a node in
    Houdini.

    Each node has a unique path that defines its location in the tree of
    nodes. The node path hierarchy is similar to the hierarchy of folders
    and files in a file system.  Some nodes, called networks, may contain
    other nodes inside them, much like a file folder would, while other
    nodes may not.  For example, an object node instance and a SOP
    subnetwork node instance may contain SOP nodes, but a box SOP instance
    may not.


    Be careful not to confuse nodes with node types.  A node is an instance
    of a node type.  For example suppose /obj/geo1/box1 is a box SOP.  It
    has its own unique name (box1) and its own copies of parameter values.
    It is an instance of the box SOP node type.  This node type defines what
    parameters are common to all box SOP node instances, as well as the
    algorithm that each BOX SOP performs.  The class that represents a node
    type is hou.NodeType.

    You cannot create instances of hou.Node using hou.Node.__init__.
    Instead, you look up Node objects corresponding to existing Houdini
    nodes with hou.node_.  To create a new Houdini node instance inside
    another node, use hou.Node.createNode.  To delete a Houdini node, use
    hou.Node.destroy.

    Note that a Node object internally stores a reference to the
    corresponding Houdini node, and that their lifetimes are different.  If
    a Python node object is deleted because its reference count in Python
    goes to zero, the Houdini node will be unaffected.  On the other hand,
    if you have a Node object in a Python variable and the Houdini node is
    deleted, the Python variable will still exist, and Python will not
    crash.  Instead, if you later call a method on that Python Node object,
    Houdini will raise a hou.ObjectWasDeleted exception.

    Be careful not to confuse this class with the function hou.node.


    """
    thisown=None
    this=None
    def __init__(self):
        super(Node, self).__init__()
        raise AttributeError, "No constructor defined"
    def _getArgumentAutoComplete(self, method_name, arguments):
        """
        _getArgumentAutoComplete(self, method_name, arguments) -> tuple of str

        This method is used internally by Houdini to perform autocompletion in
        the interactive Python shell.
        """
        return ('',)

    def path(self):
        """
        path(self) -> str

        Return the full path (i.e. starting with /) of this node in the network.

        REPLACES
            opfullpath function
            opinputpath function
            opoutputpath function        """
        return ''

    def relativePathTo(self, base_node):
        """
        relativePathTo(self, base_node) -> str

        Return a relative path to another node object from this node.

          >>> box1 = hou.node("/obj/box_object1/box1")
          >>> sphere1 = hou.node("/obj/sphere_object1/sphere1")
          >>> box1.relativePathTo(sphere1)
          '../../sphere_object1/sphere1'
          >>> hou.node("/obj").relativePathTo(box1)
          'box_object1/box1'
          >>> box1.relativePathTo(box1)
          '.'

        REPLACES
            oprelativepath function        """
        return ''

    def name(self):
        """
        name(self) -> str

        Return this node's name.  See also hou.Node.path.

        REPLACES
            opname command
            opname function
            optypeinfo function        """
        return ''

    def setName(self, name, unique_name=False):
        """
        setName(self, name, unique_name=False)

        Set the name of this node.  Raises hou.OperationFailed if the new name
        contains characters other than letters, numbers, periods, dashes, or
        underscores.  Raises hou.OperationFailed if the node could not be
        renamed (for example, another node already exists with the name, the
        node is the root node or top-level manager (e.g. /obj), or the node is
        inside a locked asset).  If the unique_name parameter is set to True,
        the supplied name may be changed to ensure that it doesn't match the
        name of any existing node.

        REPLACES
            opname command
            opname function        """

    def digitsInName(self):
        """
        digitsInName(self) -> int

        Return the value of the last set of digits inside the node's name, or 0
        if there are no digits.

        For example, the result is 102 for a node named geo102, and 34 for a
        node named light12to34.

        REPLACES
            opdigits function        """
        return 0

    def type(self):
        """
        type(self) -> hou.NodeType

        Return the hou.NodeType object for this node.

        For example, all camera node instances share the same node type.

        REPLACES
            optype command
            optype function        """
        return NodeType()

    def childTypeCategory(self):
        """
        childTypeCategory(self) -> hou.NodeTypeCategory

        Return the hou.NodeTypeCategory corresponding to the children of this
        node.  For example, if this node is a geometry object, the children are
        SOPs.  If it is an object subnet, the children are objects.
        """
        return NodeTypeCategory()

    def node(self, node_path):
        """
        node(self, node_path) -> hou.Node or None

        Return the node at the given path, or None if no such node exists.  If
        you pass in a relative path (i.e. the path does not start with /),
        searches are performed relative to this node.

        For example, to get the parent node of a node in the the variable n, use
        n.node(".."). To get a child node named geo5, use n.node("geo5"). To
        get a sibling node named light3, use n.node("../light3").

        Note that the return value may be an instance of a subclass of Node. For
        example, if the node being found is an object node, the return value
        will be a hou.ObjNode instance.

        If the path is an absolute path (i.e. it starts with /), this method is
        a shortcut for hou.node(node_path).  Otherwise, it is a shortcut for
        hou.node(self.path() + "/" + node_path).  See also hou.node_.

        REPLACES
            opfind command
            chsop function
            opexist function
            opfullpathfrom function        """
        return Node()

    def glob(self, pattern):
        """
        glob(self, pattern) -> tuple of hou.Node

        Return a tuple of children nodes name matches the pattern.

        The pattern may contain multiple pieces, separated by spaces.  An
        asterisk (*) in a pattern piece will match any character.  By default,
        Houdini will add the nodes from each pattern piece to those already
        matched. However, if the pattern piece begins with a caret (^), Houdini
        will remove the matches for that piece from the result.

        This method returns an empty tuple if you pass in an empty pattern.

          >>> obj = hou.node("/obj")
          >>> obj.createNode("geo", "geo1")
          <hou.ObjNode of type geo at /obj/geo1>
          >>> obj.createNode("geo", "geo2")
          <hou.ObjNode of type geo at /obj/geo2>
          >>> obj.createNode("geo", "grid")
          <hou.ObjNode of type geo at /obj/grid>
          >>> obj.createNode("geo", "garbage")
          <hou.ObjNode of type geo at /obj/garbage>
          >>> obj.createNode("geo", "box")
          <hou.ObjNode of type geo at /obj/box>

          >>> def names(nodes):
          ... return [node.name() for node in nodes]

          >>> names(obj.glob("g*"))
          ['geo1', 'geo2', 'grid', 'garbage']
          >>> names(obj.glob("ge* ga*"))
          ['geo1', 'geo2', 'garbage']
          >>> names(obj.glob("g* ^ga*"))
          ['geo1', 'geo2', 'grid']

        See also hou.Node.recursiveGlob.

        REPLACES
            opglob command
            opfind command        """
        return Node()

    def recursiveGlob(self, pattern, filter=hou.nodeTypeFilter.NoFilter):
        """
        recursiveGlob(self, pattern, filter=hou.nodeTypeFilter.NoFilter) ->
        tuple of hou.Node

        Like hou.Node.glob, return a tuple of children nodes whose name matches
        the pattern.  However, any matching child will have all its children
        added, recursively.  As well, the result may be filtered by node type.

        Houdini first matches children nodes against the pattern, then
        recursively adds the subchildren of matching children, and then applies
        the filter.

        pattern
            Child node names will be matched against this string pattern.  See
            hou.Node.glob and hou.NodeBundle for information about the pattern
            syntax.  Note that if a child node matches the pattern, all of its
            subchildren will be added to the result (subject to filtering),
            regardless of the pattern.

        filter
            A hou.nodeTypeFilter enumeration value to limit matched nodes to a
            particular type (e.g. object nodes, geometry object nodes, surface
            shader SHOPs, etc.).

        The pattern and filter behavior is very similar to that used by node
        bundles in Houdini.  See hou.NodeBundle for more information.

        Raises hou.OperationFailed if the pattern is invalid.

        REPLACES
            opglob command
            opfind command        """
        return (Node(),)

    def createInputNode(self, input_index, node_type_name, node_name=None, run_init_scripts=True, load_contents=True, exact_type_name=False):
        return Node()

    def createOutputNode(self, node_type_name, node_name=None, run_init_scripts=True, load_contents=True, exact_type_name=False):
        return Node()

    def createNode(self, node_type_name, node_name=None, run_init_scripts=True, load_contents=True, exact_type_name=False):
        """
        createNode(self, node_type_name, node_name=None, run_init_scripts=True,
        load_contents=True, exact_type_name=False) -> hou.Node

        Create a new node of type node_type_name as a child of this node.

        node_name
            The name of the new node. If not specified, Houdini appends a number
            to the node type name, incrementing that number until a unique node
            name is found.  If you specify a name and a node already exists with
            that name, Houdini will append a number to create a unique name.

        run_init_scripts
            If True, the initialization script associated with the node type
            will be run on the new node.

        load_contents
            If True, any subnet contents will be loaded for custom subnet
            operators.

        exact_type_name
            If True, the node's type name will be exactly as specified in the
            node_type_name. Otherwise, a preferred operator type that matches
            the given node_type_name may be used. For example, the given "hda"
            may match a newer version "hda::2.0", or if there are two
            available operators "namespaceA::hda" and "namespaceB::hda", and
            the "namespaceB" has precedence, then the created node will be of
            type "namespaceB::hda".

        Raises hou.OperationFailed if this node cannot contain children. Raises
        hou.PermissionError if this node is inside a locked asset.

          >>> obj = hou.node("/obj")

          # Let Houdini choose a name based on the node type name.
          >>> obj.createNode("geo")
          <hou.ObjNode of type geo at /obj/geo1>

          # Let Houdini choose a unique name.
          >>> obj.createNode("geo")
          <hou.ObjNode of type geo at /obj/geo2>

          # Give the node a specific name.
          >>> obj.createNode("geo", "foo")
          <hou.ObjNode of type geo at /obj/foo>

          # Let Houdini create a unique name from our suggested name.  Also, don't
          # run the geometry object init scripts so the contents are empty.
          >>> obj.createNode("geo", "geo1", run_init_scripts=False)
          <hou.ObjNode of type geo at /obj/geo3>
          >>> obj.node("geo1").children()
          (<hou.SopNode of type file at /obj/geo1/file1>,)
          >>> obj.node("geo3").children()
          ()

        REPLACES
            opadd command
        """
        return Node()

    def runInitScripts(self):
        """
        runInitScripts(self)

        Runs the initialization script associated with this node's type.
        """

    def setInput(self, input_index, node_to_become_input, output_index=0):
        """
        setInput(self, input_index, node_to_become_input, output_index=0)

        If node_to_become_input is not None, connect the output connector of
        another node to an input connector of this node.  Otherwise, disconnect
        anything connected to the input connector.

        input_index
            The index of this node's input connector.

        node_to_become_input
            If None this method disconnects everything from the input connector.
            If a hou.Node or a hou.SubnetIndirectInput, this method connects its
            output to this node's input connector.

        output_index
            The index of the other node's output connector.

        Raises hou.InvalidInput if output_index is invalid.  Raises
        hou.OperationFailed if node_to_become_input is not in the same network
        as this node.  Raises hou.PermissionError if the node is inside a locked
        asset.

        REPLACES
            opwire command
            opunwire command        """
        return Node()

    def setNamedInput(self, input_name, node_to_become_input,
        output_name_or_index):
        """
        setNamedInput(self, input_name, node_to_become_input,
        output_name_or_index)

        Connects an output on this node (specified by either an output name or
        an output index) to the input on the node_to_become_input specified by
        input_name.
        """

    def setFirstInput(self, node_to_become_input, output_index=0):
        """
        setFirstInput(self, node_to_become_input, output_index=0)

        A shortcut for self.setInput(node_to_become_input, 0).  See
        hou.Node.setInput for more information.

        REPLACES
            opwire command        """

    def setNextInput(self, node_to_become_input, output_index=0):
        """
        setNextInput(self, node_to_become_input, output_index=0)

        Connect the output connector from another node into the first
        unconnected input connector or a multi-input connector of this node.

        This method is roughly equivalent to:
          for input_index, conectors in enumerate(self.inputConnectors()):
              if len(connectors) == 0:
                  self.setInput(input_index, node_to_become_input, output_index)
              raise hou.InvalidInput("All inputs are connected")

        Raises hou.InvalidInput if all inputs are connected.  See
        hou.Node.setInput for more information.

        REPLACES
            opwire command        """

    def insertInput(self, input_index, node_to_become_input, output_index=0):
        """
        insertInput(self, input_index, node_to_become_input, output_index=0)

        Insert an input wire.  In other words, for each input connector after
        input_index, shift the contents of that input connector to the next one,
        and then call hou.Node.setInput.  See hou.Node.setInput for the meanings
        of the parameters.
        """

    def inputs(self):
        """
        inputs(self) -> tuple of hou.Node

        Return a tuple of the nodes connected to this node's inputs.

        This method is a shortcut for [connection.outputNode() for connection in
        self.inputConnections()].

        REPLACES
            opgetinput command
            opninputs function
            icl function
            icn function
            icr function
            ics function        """
        return (Node(),)

    def inputConnections(self):
        """
        inputConnections(self) -> tuple of hou.NodeConnection

        Return a tuple of NodeConnection objects for the connections coming into
        the top of this node.  If nothing is wired into this node, return an
        empty tuple.

        To get a list of the connected nodes themselves, use hou.Node.inputs.

        This method is a shortcut for [connectors[0] for connectors in
        self.inputConnectors() if len(connectors) != 0].

          >>> cookie = hou.node("/obj").createNode("geo").createNode("cookie")
          >>> cookie.setInput(1, cookie.parent().createNode("box"))
          >>> cookie.inputConnections()
          (<hou.NodeConnection from grid1 output 0 to cookie input 1>,)
          >>> cookie.inputConnectors()
          ((), (<hou.NodeConnection from grid1 output 0 to cookie input 1>,))

        See also hou.Node.inputConnectors.

        REPLACES
            opgetinput command        """
        return (NodeConnection(),)

    def inputConnectors(self, include_indirect_inputs=False):
        """
        inputConnectors(self, include_indirect_inputs=False) -> tuple of tuple
        of hou.NodeConnection

        Return a tuple of tuples of hou.NodeConnection objects.  The length of
        the result tuple is equal to the number of input connectors on this
        node.  Each subtuple contains exactly one node connection if something
        is wired into the connector; otherwise it is the empty tuple.

        By default, connections for subnet indirect inputs are not returned. To
        obtain a list of the connections with subnet indirect inputs, call with
        inputConnectors(True).  See hou.SubnetIndirectInput for information on
        subnet indirect inputs.

        See also hou.NodeConnection and hou.Node.inputConnections.

        REPLACES
            opdepend command
            opgetinput command
            opinput function        """
        return (NodeConnection(),)

    def inputAncestors(self, include_ref_inputs=True, follow_subnets=False):
        """
        inputAncestors(self, include_ref_inputs=True, follow_subnets=False) ->
        tuple of hou.Node

        Return a tuple of all input ancestors of this node.  If
        include_ref_inputs is False, then reference inputs are not traversed.
        If follow_subnets is True, then instead of treating subnetwork nodes as
        a single node, we also traverse its children starting with its display
        node.

        See also the inputs() method.
        """
        return Node()

    def inputNames(self):
        """
        inputNames(self) -> tuple of str

        Returns a tuple of all input names for this node. Names for input
        connectors that are hidden are also included.
        """
        return ('',)

    def outputNames(self):
        """
        outputNames(self) -> tuple of str

        Returns a tuple of all output names for this node.
        """
        return ('',)

    def outputs(self):
        """
        outputs(self) -> tuple of hou.Node

        Return a tuple of the nodes connected to this node's outputs.

        This method is a shortcut for [connection.inputNode() for connection in
        self.outputConnections()].

        REPLACES
            opoutput function
            opdepend command
            opnoutputs function        """
        return (Node(),)

    def outputConnections(self):
        """
        outputConnections(self) -> tuple of hou.NodeConnection

        Return a tuple of NodeConnection objects for the connections going out
        of the bottom of this node.  If nothing is wired into the output of this
        node, return an empty tuple.

        To get a list of the connected nodes themselves, use hou.Node.outputs.

        Note that this method is a shortcut for: reduce(lambda a, b: a+b,
        self.outputConnectors(), ()).  Since most nodes have only one output
        connector, though, this method is usually equivalent to
        self.outputConnectors()[0].

          >>> box = hou.node("/obj").createNode("geo").createNode("box")
          >>> box.parent().createNode("xform").setFirstInput(box)
          >>> box.parent().createNode("subdivide").setFirstInput(box)
          >>> box.outputConnections()
          (<hou.NodeConnection from box1 output 0 to xform1 output 0>, <hou.NodeConnection from box1 output 0 to subdivide1 input 0>)

        See also hou.node.outputConnectors.
        """
        return (NodeConnection(),)

    def outputConnectors(self):
        """
        outputConnectors(self) -> tuple of tuple of hou.NodeConnection

        Return a a tuple of tuples of hou.NodeConnection objects.  The length of
        the result tuple is equal to the number of output connectors on this
        node.  Each subtuple contains all the connections going out of that
        connector, and is empty if nothing is wired to that connector.

          >>> split = hou.node("/obj").createNode("dopnet").createNode("split")
          >>> split.parent().createNode("rbdsolver").setFirstInput(split)
          >>> split.parent().createNode("gravity").setFirstInput(split, 1)
          >>> split.parent().createNode("merge").setFirstInput(split, 1)
          >>> split.outputConnectors()
          ((<hou.NodeConnection from split1 output 0 to rbdsolver1 input 0>,), (<hou.NodeConnection from split1 output 1 to gravity2 input 0>, <hou.NodeConnection from split1 output 1 to merge1 input 0>), (), ())

        See also hou.NodeConnection and hou.Node.outputConnections.

        REPLACES
            opninputs function
            icl function
            icn function
            icr function
            ics function
            opdepend command        """
        return (NodeConnection(),)

    def children(self):
        """
        children(self) -> tuple of hou.Node

        Return a list of nodes that are children of this node.  Using the file
        system analogy, a node's children are like the contents of a
        folder/directory.

        To find the number of children nodes, use len(node.children()).

        The order of the children in the result is the same as the user defined
        ordering in Houdini.  To see this order, switch the network view pane
        into list mode, and ensure that the list order is set to user defined.
        To reorder nodes, drag and drop them in the list.

          def pc(node):
              '''Print the names of the children of a particular node.  This function
                 can be handy when working interactively in the Python shell.'''
              for child in node.children():
                  print child.name()

          def ls():
              '''Print the names of the nodes under the current node.'''
              pc(hou.pwd())

        The following expression evaluates to a list of children of a particular
        node type:
          [c for c in node.children() if c.type() == node_type]


        REPLACES
            opfind command
            opls command
            opnchildren function        """
        return (Node(),)

    def allSubChildren(self, top_down=True):
        """
        allSubChildren(self, top_down=True) -> tuple of hou.Node

        Recursively return all sub children of this node.  For example,
        hou.node("/").allSubChildren() will return all the nodes in the hip
        file.

        top_down
            If True, this function will do a top-down traversal, placing a node
            in the returned tuple before its children.  If False, it will do a
            bottom-up traversal, placing children before their parents.

        Note that a tuple is returned, not a generator.  This means that it is
        safe to delete or create nodes while looping through the return value.

        The following function deletes all children of a particular type that
        appear anywhere inside a given node:
          def removeSubChildrenOfType(node, node_type):
              '''Recursively delete all children of a particular type.'''
              for child in allSubChildren(node):
                  if child.type() == node_type:
                      child.destroy()


        This code, for example, removes all the visibility SOPs anywhere under
        /obj:
          >>> removeSubChildrenOfType(hou.node("/obj"), hou.sopNodeTypeCategory().nodeTypes()['visibility'])


        REPLACES
            oprmtype command
            opfind command        """
        return (Node(),)

    def selectedChildren(self, include_hidden=False):
        """
        selectedChildren(self, include_hidden=False) -> tuple of hou.Node

        Return a tuple containing the children of this node that are selected.
        Note that the last selected node has special meaning, and can also be
        retrieved with hou.Node.isCurrent.

        include_hidden
            If False, hidden nodes are not included in the result, even if they
            are selected.

        The following example will print the names of all selected objects in
        /obj:
          for n in hou.node("/obj").selectedChildren():
              print n.name()


        To find the total number of selected children nodes, use
        len(node.selectedChildren()).

        REPLACES
            opget command        """
        return (Node(),)

    def parent(self):
        """
        parent(self) -> hou.Node

        Return the node that contains this node.

        This method is a shortcut for self.node("..").  Note that this method
        returns None if the node is the root (i.e. /).

          >>> hou.node("/obj/box_object1").parent()
          <hou.Node at /obj>
          >>> print hou.node("/").parent()
          None
        """
        return Node()

    def creator(self):
        """
        isBuiltExplicitly(self) -> bool

        Return whether this node was built explicitly (defaults to True).  Most
        nodes are built explicitly, but some are implicitly created by Houdini.
        For example, if you select geometry from multiple SOPs and then perform
        an operation, Houdini will put down an implicit merge SOP before
        performing that operation.  When reselecting geometry in SOPs, Houdini
        will automatically delete any SOPs that were created implicitly.
        """
        return True

    def isInsideLockedHDA(self):
        """
        isInsideLockedHDA(self) -> bool

        Return whether this node is inside a locked digital asset.  If this node
        is not inside a locked HDA, the node may deviate from the OTL
        definition.
        """
        return True

    def isLocked(self):
        """
        isLocked(self) -> bool

        If this node is an instance of a digital asset, return whether or not it
        is locked.  Otherwise, return False.

        To differentiate between unlocked digital assets and nodes that are not
        instances of digital assets, check if the node's type has a definition:
          def isUnlockedAsset(node):
              return not node.isLocked() and node.type().definition() is not None


        See hou.HDADefinition.updateFromNode for an example of how to save and
        lock all unlocked digital asset instances.
        """
        return True

    def isCompiled(self): return

    def hdaModule(self):
        """
        hm(self) -> hou.HDAModule

        This method is a shortcut for self.hdaModule().

        See also hou.phm.
        """
        return HDAModule()

    def hm(self): return
    def size(self):
        """
        size(self) -> hou.Vector2

        Return the size of this node's tile in the network editor graph as a
        Vector2.
        """
        return Vector2()

    def position(self):
        """
        position(self) -> hou.Vector2

        Return the position of this node's tile in the network editor graph as a
        Vector2. See also move() and setPosition().

        REPLACES
            oplocate command        """
        return Vector2()

    def setPosition(self, vector2):
        """
        setPosition(self, vector2)

        Sets the position of this node's tile in the network editor graph.
        Raises hou.InvalidInput if the node cannot have the given position.

        REPLACES
            oplocate command        """

    def move(self, vector2):
        """
        move(self, vector2)

        Moves this node's tile in the network editor graph by the increments in
        the given hou.Vector2.

        To position a node absolutely, use setPosition().

        To get the node's current graph position, use position().

        Raises hou.InvalidInput if the node cannot move to the position
        specified.

        REPLACES
            oplocate command        """

    def moveToGoodPosition(self, relative_to_inputs=True, move_inputs=True,
        move_outputs=True, move_unconnected=True):
        """
        moveToGoodPosition(self, relative_to_inputs=True, move_inputs=True,
        move_outputs=True, move_unconnected=True) -> hou.Vector2

        Moves a node to a well-spaced position near its inputs or outputs and
        returns the new position of the node.

        REPLACES
            opautoplace command        """
        return Vector2()

    def layoutChildren(self, child_nodes=(), horizontal_spacing=-1.0,
        vertical_spacing=-1.0):
        """
        layoutChildren(self, child_nodes=(), horizontal_spacing=-1.0,
        vertical_spacing=-1.0)

        Automatically position all or some children of this node in the network
        editor.

        child_nodes
            A sequence of child nodes to position.  If this sequence is empty,
            this method will reposition all children of this node.

        horizontal_spacing
            A fraction of the width and height of a tile that affects the space
            between nodes with common inputs.  If this parameter is -1, Houdini
            uses the default spacing.

        vertical_spacing
            A fraction of the width and height of a tile that affects the space
            between a node and its output nodes.  If this parameter is -1,
            Houdini uses the default spacing.

        REPLACES
            oplayout command        """

    def isSelected(self):
        """
        isSelected(self) -> bool

        Return whether this node is selected.

        See also hou.selectedNodes.

        REPLACES
            opget command
            opflag function        """
        return True

    def setSelected(self, on, clear_all_selected=False,
        show_asset_if_selected=False):
        """
        setSelected(self, on, clear_all_selected=False,
        show_asset_if_selected=False)

        Select or deselect this node, optionally deselecting all other selected
        nodes in this network. If show_asset_if_selected is True, then the panes
        will show the top-level asset of the selected node instead.

        REPLACES
            opset command
            opselect function        """

    def isCurrent(self):
        """
        isCurrent(self) -> bool

        Return a boolean to indicate of the node is the last selected node in
        its network.

        Each network (i.e. node containing children) stores its own list of
        selected nodes, and the last selected node has special meaning.  For
        example, it is the node displayed in unpinned parameter panes.

        See also hou.selectedNodes to get a tuple of all the selected nodes in
        all networks in Houdini.  The last node in this list also has special
        meaning in Houdini, and corresponds to the global current node.

        REPLACES
            opget command
            opflag function        """
        return True

    def setCurrent(self, on, clear_all_selected=False):
        """
        setCurrent(self, on, clear_all_selected=False)

        Set or unset this node as the last selected one.

        Each network (i.e. node containing children) stores its own list of
        selected nodes, and the last selected node has special meaning.  For
        example, it is the node displayed in unpinned parameter panes.

        If on is True, this node will become the last selected node.  If it is
        False and this node was the last selected one, it will be unselected and
        the second-last selected node will become the last selected node.

        If clear_all_selected is true, Houdini will unselect every node in this
        network before performing the operation.

        See also hou.Node.setSelected and hou.selectedNodes.

        REPLACES
            opset command        """

    def isHidden(self):
        """
        isHidden(self)

        Return whether the node is hidden in the network editor.  Note that
        Houdini also uses the term "exposed" to refer to nodes that are not
        hidden.

        If a visible node is connected to a hidden node, the network editor will
        display dashed lines for the wire going from the visible node to the
        hidden node.

        See also hou.Node.hide.

        REPLACES
            opget command
            opflag function        """

    def hide(self, on):
        """
        hide(self, on)

        Hide or show a node in the network editor.  See hou.Node.isHidden for
        more information about hidden nodes.

        REPLACES
            opset command        """

    def comment(self):
        """
        comment(self) -> str

        Return the node's comment string.

        REPLACES
            opcomment command        """
        return ''

    def setComment(self, comment):
        """
        setComment(self, comment)

        Sets the comment associated with this node. See also appendComment().

        REPLACES
            opcomment command        """

    def appendComment(self, comment):
        """
        appendComment(self, comment)

        Appends the given text to the comment associated with this node.

        REPLACES
            opcomment command        """

    def creatorState(self):
        """
        creatorState(self) -> str

        This returns the name of the viewport tool that was used to be created.
        This name is not set by default and is usually the empty string.
        """
        return ''

    def setCreatorState(self, state):
        """
        setCreatorState(self, state)

        This sets the name of the tool that created this node. If you call this
        with a name that differs from the node type name, you should also call
        setBuiltExplicitly(False).
        """

    def isBuiltExplicitly(self): return
    def setBuiltExplicitly(self): return
    def color(self):
        """
        color(self) -> hou.Color

        Return the color of this node's tile in the network editor.

        REPLACES
            opcolor command        """
        return Color()

    def setColor(self, color):
        """
        setColor(self, color)

        Sets the color of this node's tile in the network editor to the given
        hou.Color.

        REPLACES
            opcolor command        """

    def expressionLanguage(self):
        """
        expressionLanguage(self) -> hou.exprLanguage enum value

        Return the node's default expression language.

        When you enter an expression in a parameter that does not already
        contain an expression, the node's expression language is used to
        determine how that expression should be evaluated.  You can change a
        node's expression language in the parameter dialog in the GUI.

        Changing the node's expression language will not change the language in
        parameters already containing expressions (i.e. parameters with
        keyframes).

        Note that if a parameter already contains an expression and you change
        that expression in the GUI, the expression language will not change,
        regardless of the value of the node's expression language. To change the
        language of an existing expression in a parameter from Python, use
        hou.Parm.setExpression, as in parm.setExpression(parm.expression(),
        language).
        """
        return exprLanguage()

    def setExpressionLanguage(self, language):
        """
        setExpressionLanguage(self, language)

        Set the node's default expression language. See expressionLanguage() for
        more information.
        """

    def parm(self, parm_path):
        """
        parm(self, parm_path) -> hou.Parm or None

        Return the parameter at the given path, or None if the parameter doesn't
        exist.

        REPLACES
            chexist function        """
        return Parm()

    def parmTuple(self, parm_path):
        """
        parmTuple(self, parm_path) -> hou.ParmTuple or None

        Return the parm tuple at the given path, or None if it doesn't exist.

        This method is similar to parm(), except it returns a hou.ParmTuple
        instead of a hou.Parm.
        """
        return ParmTuple()

    def parms(self):
        """
        parms(self) -> tuple of hou.Parm

        Return a list of the parameters on this node.

        REPLACES
            opparm command        """
        return (Parm(),)

    def parmsReferencingThis(self):
        """
        parmsReferencingThis(self) -> tuple of hou.Parm

        Return a list of the parameters that reference this node.
        """
        return (Parm(),)

    def parmTuples(self):
        """
        parmTuples(self) -> tuple of hou.ParmTuple

        Return a list of all parameter tuples on this node.

        This method is similar to parms(), except it returns a list of
        hou.ParmTuple instead of hou.Parm.
        """
        return (ParmTuple(),)

    def spareParms(self):
        """
        spareParms(self) -> tuple of hou.Parm

        Return a list of the spare (user-defined) parameters on this node.

        REPLACES
            opspare command        """
        return (Parm(),)

    def syncNodeVersionIfNeeded(self, from_version):
        """
        syncNodeVersionIfNeeded(self, from_version)

        Synchronize the node from the specified version to the current version
        of its HDA definition. See also hou.HDADefinition.version.
        """

    def setParmTemplateGroup(*args, **kwargs): return
    def parmTuplesInFolder(self, folder_names):
        """
        parmTuplesInFolder(self, folder_names) -> tuple of hou.ParmTuple

        Return a list of the parameter tuples in a folder on this node. This
        method is similar to parmsInFolder(), except it returns a list of
        hou.ParmTuple instead of hou.Parm. See parmsInFolder() above for
        information about the arguments.

        See also hou.Parm.containingFolders and
        hou.Parm.containingFolderSetParmTuples
        """
        return (ParmTuple(),)

    def parmsInFolder(self, folder_names, folder_style):
        """
        parmsInFolder(self, folder_names, folder_style) -> tuple of hou.Parm

        Return a list of parameters in a folder on this node.  Returns all
        parameters in the folder and its subfolders (if any).

        folder_names
            A sequence of folder name strings.  For example, to get a list of
            the parameters in the Shading folder of the Render folder, use
            ("Render", "Shading").

            If this sequence is empty, the method returns all parameters on the
            node, the same as if you called parms().

        folder_style
            A member of hou.folderType describing how the folder is rendered.

        Raises hou.OperationFailed if the folder specified by folder_names does
        not exist.

        See also hou.Parm.containingFolders and
        hou.Parm.containingFolderSetParmTuples
        """
        return Parm()

    def parmTemplateGroup(self): return ParmTemplateGroup()
    def isTimeDependent(self):
        """
        isTimeDependent(self) -> bool

        Return whether the node is time dependent.  A time dependent node is re-
        evaluated every time the frame changes.
        """
        return True

    def destroy(self):
        """
        destroy(self)

        Delete this node.

        If you call methods on a Node instance after it has been destroyed,
        Houdini will raise hou.ObjectWasDeleted.

        Raises hou.OperationFailed if you try to delete a node inside a locked
        asset.

        REPLACES
            oprm command        """

    def allowEditingOfContents(self, propagate=False):
        """
        allowEditingOfContents(self, propagate=False)

        Unlocks a digital asset so its contents can be edited.

        To use this function, you must have permission to modify the HDA.

        REPLACES
            otsync command        """

    def matchCurrentDefinition(self):
        """
        matchCurrentDefinition(self)

        If this node is an unlocked digital asset, change its contents to match
        what is stored in the definition and lock it.  The parameter values are
        unchanged.

        If this node is locked or is not a digital asset, this method has no
        effect.

        See also hou.Node.matchesCurrentDefinition and hou.Node.isLocked.

        REPLACES
            otsync command        """

    def matchesCurrentDefinition(self):
        """
        matchesCurrentDefinition(self) -> bool

        Return whether the contents of the node match its type definition.  A
        locked digital asset instance will always match its definition, but an
        unlocked one may not.

        REPLACES
            otsync command        """
        return True

    def parmAliases(*args, **kwargs):
        """
        parmAliases(self, recurse=False) -> dict of hou.Parm to str

        Return a dictionary of parameter aliases on the node's parameters.  The
        keys in the dictionary are the parameters that have aliases and the
        values are the alias names.

        recurse
            Return the parameter aliases for this node _and its children_.

        REPLACES
            chalias command        """
        return {Parm():''}

    def clearParmAliases(self):
        """
        clearParmAliases(self)

        Removes all alias names from parameters on the node.

        REPLACES
            chalias command        """

    def networkBoxes(self):
        """
        iterNetworkBoxes(self) -> generator of hou.NetworkBox

        Return a generator that iterates through all the network boxes inside
        this node.

        REPLACES
            nbls command        """
        return (NetworkBox(),)

    def iterNetworkBoxes(self): return
    def createNetworkBox(self, name=None):
        """
        createNetworkBox(self, name=None) -> hou.NetworkBox

        Creates a network box inside this network. Raises hou.OperationFailed if
        this node is not a network.

        If you don't specify a name, Houdini gives the box a default name.

        REPLACES
            nbadd command        """
        return NetworkBox()

    def copyNetworkBox(self, network_box_to_copy, new_name=None,
        channel_reference_original=False):
        """
        copyNetworkBox(self, network_box_to_copy, new_name=None,
        channel_reference_original=False) -> hou.NetworkBox

        Copies a network box and returns the copy.

        If new_name is given, the network box will be copied to a new network
        box named new_name (a different name will be generated if there is
        already a network box with that name).

        If channel_reference_original is True, all operators created by the copy
        will have their animatable parameters set to reference the original
        operators.

        Raises hou.OperationFailed if this node is not a network or if the node
        child type does not match the network box's node type.

        REPLACES
            nbcp command        """
        return NetworkBox()

    def findNetworkBox(self):
        """
        findNetworkBox(self, name) -> hou.NetworkBox

        Return a network box with the given name inside this node, or None if no
        network box with the given name exists.

        REPLACES
            nbls command        """
        return NetworkBox()

    def findNetworkBoxes(self, pattern):
        """
        findNetworkBoxes(self, pattern) -> tuple of hou.NetworkBox

        Return a list of network boxes inside this node whose names match a
        pattern.

        REPLACES
            nbglob command        """
        return (NetworkBox(),)

    def changeNodeType(self, new_node_type, keep_name=True, keep_parms=True,
        keep_network_contents=True, force_change_on_node_type_match=False):
        """
        changeNodeType(self, new_node_type, keep_name=True, keep_parms=True,
        keep_network_contents=True, force_change_on_node_type_match=False) ->
        hou.Node

        Changes the node to a new type (within the same context). new_node_type
        is the internal string name of the type you want to change to.

        Keep_name, keep_parms, and keep_network_contents indicate that the node
        should keep the same name, parameter values, and contents, respectively,
        after its type has changed.  force_change_on_node_type_match indicates
        whether to perform the change even when is already of the specified
        type.

        REPLACES
            opchangetype command        """
        return Node()

    def canCreateDigitalAsset(self):
        """
        canCreateDigitalAsset(self) -> bool

        Return True if hou.Node.createDigitalAsset can succeed.
        """
        return True

    def createDigitalAsset(self, name=None, hda_file_name=None,
        description=None, min_num_inputs=None, max_num_inputs=None,
        compress_contents=False, comment=None, version=None,
        save_as_embedded=False, ignore_external_references=False):
        """
        createDigitalAsset(self, name=None, hda_file_name=None,
        description=None, min_num_inputs=None, max_num_inputs=None,
        compress_contents=False, comment=None, version=None,
        save_as_embedded=False, ignore_external_references=False) -> Node

        Create a digital asset from this node.  You would typically call this
        method on subnet nodes.

        name
            The name of the node type that the new digital asset will define.

        hda_file_name
            The name of the otl file where Houdini will save the digital asset.
            If None Houdini will use $HOME/houdiniX.Y/otls/OPcustom.otl.

        description
            The name that will appear in the tab menu.  If None, Houdini will
            use the name for the description.

        min_num_inputs
            The minimum number of inputs that need to be wired into instances of
            the digital asset.  See hou.HDADefinition.minNumInputs for more
            information.

        max_num_inputs
            The number of input connectors available on instances of the digital
            asset for input connections.  See hou.HDADefinition.minNumInputs for
            more information.

        compress_contents
            Whether or not the contents of this digital asset are compressed
            inside the otl file.  See hou.HDAOptions.compressContents for more
            information.

        comment
            A user-defined comment string.  See hou.HDADefinition.comment for
            more information.

        version
            A user-defined version string.  See hou.HDADefinition.version for
            more information.

        save_as_embedded
            Whether or not the digital asset's definition will be saved with the
            hip file instead of an otl file.  When this parameter is True,
            Houdini ignores the hda_file_name parameter.  Setting this parameter
            to True is equivalent to setting this parameter to False and setting
            the hda_file_name parameter to "Embedded".

        ignore_external_references
            If True, Houdini will not generate warnings if the contents of this
            digital asset reference nodes outside the asset.
        """
        return Node()

    def createCompiledDigitalAsset(self, name=None, hda_file_name=None,
        description=None):
        """
        createCompiledDigitalAsset(self, name=None, hda_file_name=None,
        description=None)

        Create a compiled digital asset from this node.  You would typically
        call this method on vop network nodes, such as Material Shader Builder
        SHOP, Surface Shader Builder SHOP, or VEX Surface SHOP Type VOPNET. The
        digital asset does not have contents section, which means it does not
        have vop network inside, but instead relies on the saved VEX code
        sections to provide the shader code.

        After the creation of a compiled HDA, if its VEX code section is ever
        changed manually, the corresponding vex object code section can be
        recompiled using hou.HDADefinition.compileCodeSection.

        name
            The name of the node type that the new digital asset will define.

        hda_file_name
            The name of the otl file where Houdini will save the digital asset.
            If None Houdini will use $HOME/houdiniX.Y/otls/OPcustom.otl.

        description
            The name that will appear in the tab menu.  If None, Houdini will
            use the name for the description.

        REPLACES
            otcreatecompiledtypefrom command        """

    def collapseIntoSubnet(self, child_nodes, subnet_name=None):
        """
        collapseIntoSubnet(self, child_nodes, subnet_name=None) -> hou.Node

        Given a sequence of children nodes of this node, collapse them into a
        subnetwork.  In other words, create a subnet inside this node's network
        and move the specified children of this network inside that subnet.

        child_nodes
            The children nodes of this node that will go in the new subnet.

        subnet_name
            The name for the new subnet node, or None if you want Houdini to
            automatically choose a name.

        Raises hou.OperationFailed if a node inside child_nodes is not a child
        of this network, or if child_nodes is an empty sequence.

        This example function takes a single node and replaces it with a subnet,
        moving the node into the subnet..
          def collapseSingleNodeIntoSubnet(node, subnet_name=None):
              node.parent().collapseIntoSubnet((node,), subnet_name=None)


        REPLACES
            opcollapse command        """
        return Node()

    def extractAndDelete(self):
        """
        extractAndDelete(self)

        Move the children of this subnet node to become siblings of this node,
        and then delete this node.  The method is the opposite of
        collapseIntoSubnet().

        Raises hou.InvalidNodeType if this node is not a subnetwork.

        REPLACES
            opextract command        """

    def indirectInputs(self):
        """
        indirectInputs(self) -> tuple of hou.SubnetIndirectInput

        Return the hou.SubnetIndirectInput objects of a subnet.

        Raises hou.InvalidNodeType if this node is not a subnetwork.

        REPLACES
            opdepend command        """
        return (SubnetIndirectInput(),)

    def setUserData(self, name, value):
        """
        setUserData(self, name, value)

        Add/set a named string on this node instance.

        name
            A unique name (key) for the user-defined data.  By using different
            names, you can attach multiple pieces of user-defined data to a
            node.

        value
            The string to store.

        This name/value pair is stored with the hip file and is included in the
        output from opscript and hou.Node.asCode.

        The following example illustrates how to set, access, and delete user-
        defined data:

          >>> n = hou.node("/obj").createNode("geo")
          >>> n.setUserData("my data", "my data value")
          >>> n.userData("my data")
          'my data value'
          >>> n.userDataDict()
          {'my data': 'my data value'}
          >>> n.destroyUserData("my data")
          >>> n.userDataDict()
          {}
          >>> print n.userData("my data")
          None

        See per-node user-defined data for more information and examples.
        """

    def destroyUserData(self, name):
        """
        destroyUserData(self, name)

        Remove the user-defined data with this name.

        See hou.Node.setUserData for more information.

        Raises hou.OperationFailed if no user data with this name exists.
        """

    def userDataDict(self, name):
        """
        userDataDict(self, name) -> dict of str to str

        Return a dictionary containing all the user-defined name/string pairs
        for this node.

        See hou.Node.setUserData for more information.
        """
        return {'':''}

    def userData(self, name):
        """
        userData(self, name) -> str or None

        Return the user-defined data with this name, or None if no data with
        this name exists.

        See hou.Node.setUserData for more information.

        This method can be implemented as follows:
          def userData(self, name):
              return self.userDataDict().get(name)
        """
        return ''

    def destroyCachedUserData(self, name):
        """
        destroyCachedUserData(self, name)

        Remove the user-defined cached data with this name.

        See hou.Node.setCachedUserData for more information.

        Raises hou.OperationFailed if no user data with this name exists.
        """

    def cachedUserDataDict(self, name):
        """
        cachedUserDataDict(self, name) -> dict of str to str

        Return a dictionary containing all the user-defined name/string pairs
        for this node.

        See hou.Node.setCachedUserData for more information.
        """
        return {'':''}

    def setCachedUserData(self, name, value):
        """
        setCachedUserData(self, name, value)

        Add/set a named value on this node instance.  Unlike setUserData, values
        set using this method are not saved with the hip file.

        name
            A unique name (key) for the user-defined data.  By using different
            names, you can attach multiple pieces of user-defined data to a
            node.

        value
            The value to store.  Unlike setUserData, this value may be any
            Python object.

        This name/value pair is not stored with the hip file.  It is useful for
        nodes implemented in Python that want to save temporary values between
        cooks, to avoid recomputing them on subsequent cooks.

        The following example illustrates how to set, access, and delete cached
        user-defined data:

          >>> n = hou.node("/obj").createNode("geo")
          >>> n.setCachedUserData("my data", [1, 2, {"a": "b", "c": "d"}])
          >>> n.cachedUserData("my data")
          [1, 2, {'a': 'b', 'c': 'd'}]
          >>> n.cachedUserDataDict()
          {'my data': [1, 2, {'a': 'b', 'c': 'd'}]}
          >>> n.destroyCachedUserData("my data")
          >>> n.cachedUserDataDict()
          {}
          >>> print n.cachedUserData("my data")
          None

        See per-node user-defined data for more information and examples.
        """

    def cachedUserData(self, name):
        """
        cachedUserData(self, name) -> str or None

        Return the user-defined cached data with this name, or None if no data
        with this name exists.

        See hou.Node.setCachedUserData for more information.

        This method can be implemented as follows:
          def cachedUserData(self, name):
              return self.cachedUserDataDict().get(name)


        Note that None is a valid value for a key, so the most reliable way to
        check if a key is valid is to check if it is in the result of
        cachedUserDataDict:
          >>> n = hou.node("/obj").createNode("geo")
          >>> n.cachedUserDataDict()
          {}
          >>> print n.cachedUserData("foo")
          None
          >>> "foo" in n.cachedUserDataDict()
          False
          >>> n.setCachedUserData("foo", None)
          >>> n.cachedUserDataDict()
          {'foo': None}
          >>> print n.cachedUserData("foo")
          None
          >>> "foo" in n.cachedUserDataDict()
          True
        """
        return ''

    def asCode(self, brief=False, recurse=False, save_channels_only=False,
        save_creation_commands=False, save_keys_in_frames=False,
        save_outgoing_wires=False, save_parm_values_only=False,
        save_spare_parms=True, function_name=None):
        """
        asCode(self, brief=False, recurse=False, save_channels_only=False,
        save_creation_commands=False, save_keys_in_frames=False,
        save_outgoing_wires=False, save_parm_values_only=False,
        save_spare_parms=True, function_name=None) -> str

        Prints the Python code necessary to recreate a node.

        brief
            Do not set values if they are the parameter's default.  Applies to
            the contents of the node if either recurse or save_box_contents is
            True.

        recurse
            Recursively apply to the entire operator hierarchy.

        save_box_contents
            Script the contents of the node.

        save_channels_only
            Only output channels.  Applies to the contents of the node if either
            recurse or save_box_contents is True.

        save_creation_commands
            Generate a creation script for the node.  If set to False (the
            default), the generated script assumes that the network box already
            exists.  When set to True, the script will begin by creating the
            network box.

        save_keys_in_frames
            Output channel and key times in samples (frames) instead of seconds.
            Applies to the contents of the node if either recurse or
            save_box_contents is True.

        save_parm_values_only
            Evaluate parameters, saving their values instead of the expressions.
            Applies to the contents of the node if either recurse or
            save_box_contents is True.

        save_spare_parms
            Save spare parameters as well.  When save_creation_commands is True,
            commands for creating spare parameters will also be output.  Applies
            to the contents of the node if either recurse or save_box_contents
            is True.

        function_name
            If a function_name is specified, the output will be wrapped in a
            Python function.

        REPLACES
            opscript command        """
        return ''

    def saveCookCodeToFile(self, file_name, skip_header=False,
        context_name=None):
        """
        saveCookCodeToFile(self, file_name, skip_header=False,
        context_name=None)

        Saves VEX/RSL source code to a disk file (on nodes that support this).

        file_name
            The file path in which to save the generated code.

        skip_header
            If True, the method does not write a header comment at the beginning
            of the file containing the file name and node path from which the
            code was generated and a time stamp.

        context_name
            A string containing name of the shader context for the code. This
            option applies to nodes such as the Material Shader Builder which
            can generate code for multiple context types.

            For example, a Material network might contain both surface and
            displacement shaders, so you must specify which type of shader code
            to generate:

              node("/shop/vopmaterial1").saveCookCodeToFile("myfile.vfl", context_name="surface")

            On single-context nodes this argument is ignored.

            For VEX materials, possible values are surface, displacement, light,
            shadow, fog, image3d, photon, or cvex.

            For RSL materials, possible values are surface, displacement, light,
            volume, or imager.
        """

    def saveCodeToFile(self): return
    def saveCompiledCookCodeToFile(self, file_name, context_name=None):
        """
        saveCompiledCookCodeToFile(self, file_name, context_name=None)

        Saves compiled VEX code to a disk file (for nodes that support this).
        See hou.Node.saveCookCodeToFile for a description of the arguments.
        """

    def saveToCompiledVexFile(self): return
    def cook(self, force=False, frame_range=()):
        """
        cook(self, force=False, frame_range=())

        Asks or forces the node to re-cook.

        frame_range
            The frames at which to cook the object. This should be a tuple of 2
            or 3 ints giving the start frame, end frame, and optionally a frame
            increment, in that order. If you supply a two-tuple (start, end),
            the increment is 1.

        REPLACES
            opcook command        """

    def needsToCook(self, time=hou.time()):
        """
        needsToCook(self, time=hou.time()) -> bool

        Asks if the node needs to re-cook.
        """
        return True

    def cookCount(self):
        """
        cookCount(self) -> int

        Returns the number of times this node has cooked in the current session.
        """
        return 0

    def deleteScript(self):
        """
        deleteScript(self) -> str

        Return the script that will run when this node is deleted.

        REPLACES
            opdelscript command        """
        return ''

    def setDeleteScript(self, script_text, language=hou.scriptLanguage.Python):
        """
        setDeleteScript(self, script_text, language=hou.scriptLanguage.Python)

        Sets the script that will run when this node is deleted.
        """

    def createStickyNote(self, name=None):
        """
        createStickyNote(self, name=None) -> hou.StickyNote

        Creates a sticky note inside this network. Raises hou.OperationFailed if
        this node is not a network.

        If you don't specify a name, Houdini gives the note a default name.
        """
        return StickyNote()

    def stickyNotes(self):
        """
        iterStickyNotes(self) -> generator of hou.StickyNote

        Return a generator that iterates through all the sticky notes inside
        this node.
        """
        return (StickyNote(),)

    def iterStickyNotes(self): return
    def copyStickyNote(self, network_box_to_copy, new_name=None):
        """
        copyStickyNote(self, network_box_to_copy, new_name=None) ->
        hou.StickyNote

        Copies a sticky note and returns the copy.

        If new_name is given, the sticky note will be copied to a new sticky
        note named new_name (a different name will be generated if there is
        already a sticky note with that name).

        Raises hou.OperationFailed if this node is not a network or if the node
        child type does not match the sticky note's node type.
        """
        return (StickyNote(),)

    def findStickyNote(self, name):
        """
        findStickyNote(self, name) -> hou.StickyNote

        Return a sticky note with the given name inside this node, or None if no
        sticky note with the given name exists.
        """
        return StickyNote()

    def findStickyNotes(self, pattern):
        """
        findStickyNotes(self, pattern) -> tuple of hou.StickyNote

        Return a list of sticky notes inside this node whose names match a
        pattern.
        """
        return (StickyNote(),)

    def addNodeGroup(self, name=None):
        """
        addNodeGroup(self, name=None) -> hou.NodeGroup

        Add a node group to the node and return the new group.

        If a group of the given name already exists then this function simply
        returns the existing group without adding a new one. If the name of the
        group is None or an empty string, then a unique default name is
        automatically chosen.

        This function can only be called on nodes that are networks. If it is
        called on a node that is not a network, then it raises
        hou.OperationFailed.

        To remove a node group, use hou.NodeGroup.destroy.

        REPLACES
            opgadd command        """
        return NodeGroup()

    def nodeGroups(self):
        """
        nodeGroups(self) -> tuple of hou.NodeGroup

        Return the list of node groups in this node.

        REPLACES
            opgls command        """
        return (NodeGroup(),)

    def nodeGroup(self, name):
        """
        nodeGroup(self, name) -> hou.NodeGroup

        Return a node group contained by the node with the given name, or None
        if the group does not exist.

        REPLACES
            opgls command        """
        return NodeGroup()

    def errors(self):
        """
        errors(self) -> str

        Return the text of any errors from the last cook of this node, or the
        empty string ("") if there were no errors.
        """
        return ''

    def warnings(self):
        """
        warnings(self) -> str

        Return the text of any warnings from the last cook of this node, or the
        empty string ("") if there were no warnings.
        """
        return ''

    def messages(self):
        """
        messages(self) -> str

        Return the text of any messages from the last cook of this node, or the
        empty string ("") if there were no messages.
        """
        return ''

    def motionEffectsNetworkPath(self):
        """
        motionEffectsNetworkPath(self) -> str

        Return a node path representing the location for storing clips. This
        location may or may not exist. To find or create such a network, use
        hou.Node.findOrCreateMotionEffectsNetwork.
        """
        return ''

    def findOrCreateMotionEffectsNetwork(self, create=True):
        """
        findOrCreateMotionEffectsNetwork(self, create=True) ->
        hou.chopNetNodeTypeCategory

        Return a CHOP network node suitable for storing Motion Effects. By
        default, if the node doesn't exist, it will be created.

        See also hou.Parm.storeAsClip and hou.Node.motionEffectsNetworkPath.
        """
        return chopNetNodeTypeCategory()

    def saveChildrenToFile(self, nodes, network_boxes, file_name):
        """
        saveChildrenToFile(self, nodes, network_boxes, file_name)

        Given sequences of children nodes and network boxes, save a file
        containing those items.  You can load this file using
        hou.Node.loadChildrenFromFile.

        nodes
            A sequence of hou.Nodes that are children of this node.

        network_boxes
            A sequence of hou.NetworkBoxes that are contained in this node. Note
            that the contents of the network boxes are not automatically saved,
            so it is up to you to put them in the list of nodes.

        file_name
            The name of the file to write the contents to.  You can use any
            extension for this file name.

        Raises hou.OperationFailed if any of the nodes or network boxes are node
        children of this node, or if the file could not be written to. Raises
        hou.PermissionError if you do not have permission to read the contents
        of this node.

        REPLACES
            opwrite command        """

    def loadChildrenFromFile(self, file_name, ignore_load_warnings=False):
        """
        loadChildrenFromFile(self, file_name, ignore_load_warnings=False)

        Load the contents of a file saved with hou.Node.saveChildrenToFile into
        the contents of this node.

        Raises hou.OperationFailed if the file does not exist or it is not the
        correct type of file.  Raises hou.PermissionError if this node is a
        locked instance of a digital asset.  Raises hou.LoadWarning if the load
        succeeds but with warnings and ignore_load_warnings is False.

        REPLACES
            opread command        """

    def sessionId(self):
        """
        sessionId(self)

        REPLACES
            opid function        """

    def removeAllEventCallbacks(self):
        """
        removeAllEventCallbacks(self)

        Remove all event callbacks for all event types from this node.

        See hou.Node.addEventCallback for more information.
        """

    def stampValue(self, parm_name, default_value):
        """
        stampValue(self, parm_name, default_value)

        Return a copy stamping floating point or string value.  This node must
        be a downstream stamping operator, such as a Copy SOP, Cache SOP,
        LSystem SOP, or Copy CHOP.

        parm_name
            The name of the stamping variable.

        default_value
            The value that this function returns if Houdini is not currently
            performing stamping, or if parm_name is not a valid variable name.
            This value may be a float or a string.

        You might put the following expression in a Python parameter:
          node("../copy1").stampValue("sides", 5)


        REPLACES
            stamp function
            stamps function        """

    def _asVoidPointer(self): return
    def simulation(self): return
    def findNodesThatProcessedObject(self): return
    def __creationTime(self): return
    def __modificationTime(self): return
    def evalParm(self, parm_path):
        """
        evalParm(self, parm_path) -> int, float, or str

        Evaluates the specified parameter and returns the result.

        REPLACES
            ch function
            chs function        """
        return 0

    def evalParmTuple(self, parm_path):
        """
        evalParmTuple(self, parm_path) -> tuple of int, float, or str

        Evaluates the specified parameter tuple and returns the result.
        """
        return (0,)

    def addEventCallback(self, event_types, callback):
        """
        addEventCallback(self, event_types, callback)

        Register a Python callback that Houdini will call whenever a particular
        action, or event, occurs on this node.

        event_types
            A sequence of hou.nodeEventType enumeration values describing the
            event types that will cause the callback to be invoked.  See below
            for the meanings of the different event types.

        callback
            A callable Python object, such as a function or bound method, that
            Houdini will invoke whenever one of the desired event types occurs
            on this node.

            The callback will be invoked with different keyword arguments
            depending on the event type, so the callback should always use a
            **kwargs parameter (see the example below).  Keyword arguments named
            event_type and node are always passed to the callback, and contain
            the hou.nodeEventType enumerated value corresponding to the event
            type and the hou.Node object, respectively.

        The following table describes the meaning of the hou.nodeEventType
        enumeration values:

        BeingDeleted
            This node is about to be deleted.  The deletion cannot be canceled.

        NameChanged
            This node was renamed.  You can get the new name with
            kwargs["node"].name()

        FlagChanged
            One of the node's flags, such as the display flag, was changed.

        AppearanceChanged
            The appearance of this node changed in some way.  For example, any
            of the following can generate an appearance change event: the node's
            color changed, an error flag changed, the node was selected, the
            node was locked, the node was deleted, etc. kwargs["change_type"]
            contains the hou.appearanceChangeType corresponding to the specific
            change.

        PositionChanged
            The node's position in the network editor pane changed.  You can
            find the new position with kwargs["node"].position().

        InputRewired
            One of the node's inputs was wired in or unwired.  You can find the
            input connector index with kwargs["input_index"].

        InputDataChanged
            The data on one of the node's dependencies has changed. In the case
            of a parameter change, this notification will not be sent.

        ParmTupleChanged
            A parameter in the node changed.  kwargs["parm_tuple"] contains
            the hou.ParmTuple corresponding to the changed parameter.

            Note that there are cases where Houdini will send out notifications
            that all parms have changed.  In these circumstances,
            kwargs["parm_tuple"] will be None.

        ChildSelectionChanged
            The set of selected nodes for this network changed.  You can get the
            selected nodes with kwargs["node"].selectedChildren().

        ChildCreated
            A node was created inside this network.  kwargs["child_node"]
            contains the hou.Node that was created.

        ChildDeleted
            A node inside this network is about to be deleted.
            kwargs["child_node"] contains the hou.Node that will be deleted.

        ChildSwitched
            The current node, display node, or render node inside this network
            was changed.  kwargs["child_node"] contains the newly selected
            child hou.Node.


        If the callback has already been added for this node, this method simply
        updates the set of event types for the callback.  For example, suppose
        you had added a callback for NameChanged and FlagChanged events and you
        add the same callback for NameChanged and ParmTupleChanged events.  If a
        NameChanged event occurs, Houdini will run the callback once, not twice.
        Internally, Houdini updates the set of event types for your callback to
        NameChanged, FlagChanged, and ParmTupleChanged events.

        The following example shows how you can monitor all objects in Houdini
        for parameter changes:

          event_types = (
              hou.nodeEventType.ParmTupleChanged,
              hou.nodeEventType.ChildCreated)

          def setUpCallback(node):
              node.addEventCallback(event_types, onNodeChange)

          def onNodeChange(**kwargs):
              if kwargs["event_type"] == hou.nodeEventType.ParmTupleChanged:
                  # If all parameters effectively changed, kwargs["parm_tuple"] will
                  # be None.  We're only interested when individual parameters
                  # change.
                  if kwargs["parm_tuple"] is not None:
                      onParmTupleChange(kwargs["parm_tuple"])
              elif kwargs["event_type"] == hou.nodeEventType.ChildCreated:
                  setUpCallback(kwargs["child_node"])

          def onParmTupleChange(parm_tuple):
              # Add your code here to respond to a parameter change.
              print "Parameter changed:", parm_tuple

          def allSubChildren(node):
              yield node
              for child_node in node.children():
                  for n in allSubChildren(child_node):
                      yield n

          # Set up node callbacks for all existing nodes so we're notified when any
          # of their children get created.
          for node in allSubChildren(hou.node("/")):
              setUpCallback(node)

        If many parameters are changing, you may want to defer processing the
        updates until they're all finished.  The following code provides a new
        version of onParmTupleChange that queues parameter changes:
          import hdefereval

          _changed_parm_tuples = []

          def onParmTupleChange(parm_tuple):
              _changed_parm_tuples.append(parm_tuple)
              if len(_changed_parm_tuples) == 1:
                  hdefereval.executeDeferred(onProcessParmTupleChanges)

          def onProcessParmTupleChanges():
              # Add your code here to respond to deferred parameter changes.
              for parm_tuple in _changed_parm_tuples:
                  print "Parameter changed:", parm_tuple
              _changed_parm_tuples[:] = []


        See also hou.Node.removeEventCallback and
        hou.Node.removeAllEventCallbacks.
        """

    def removeEventCallback(self, event_types, callback):
        """
        removeEventCallback(self, event_types, callback)

        Given a callback that was previously added on this node and a sequence
        of hou.nodeEventType enumerated values, remove those event types from
        the set of event types for the callback.  If the remaining set of event
        types is empty, the callback will be removed entirely from this node.

        Raises hou.OperationFailed if the callback had not been previously
        added.

        See hou.Node.addEventCallback for more information.
        """

    def addSpareParmFolder(self):
        """
    Adds a folder to the spare parameters.
    Note that all the folders in a set correspond to one parameter. If this is the first folder to go in the set, parm_name will be used as the parameter name. Otherwise, parm_name will be ignored and the parameter name of the first folder in the set is used.
    If this is the first folder in the set and parm_name is None, it will default to 'sparefolder0'. If parm_name is already in use, a unique name will be automatically generated.
    If create_missing_folders is True, this method will create the folders in in_folder that dont exist. So, this method can be used to add spare folders and a spare parameter at the same time.
    Note that you can add folders by passing a hou.FolderParmTemplate to the addSpareParmTuple method, so this method is deprecated. Note also that addSpareParmTuple is deprecated in favor of setParmTemplateGroup.
    See also the removeSpareParmFolder and addSpareParmTuple methods.
    This method is deprecated in favor of setParmTemplateGroup.
        """
        return
    def addSpareParmTuple(self):
        """
    Add a spare parameter tuple to the end of the parameters on the node. If in_folder is not an empty sequence,
    this method adds the parameters to the end of the parameters in a particular folder.
    parm_template
    A hou.ParmTemplate subclass instance that specifies the type of parameter tuple, the default value, range, etc.
    in_folder
    A sequence of folder names specifying which folder will hold the parameter. If this parameter is an empty sequence
    (e.g. ()), Houdini will not put the parameter inside a folder. If it is, for example, ("Misc", "Controls"), Houdini
    puts it inside the Controls folder thats inside the Misc folder. If it is, for example, ("Misc",), Houdini puts
    it inside the Misc folder.
    create_missing_folders
    If True, and the folder location specified by in_folder does not exist, this method creates the missing containing
    folders.
    Note that this method can add a single folder by passing a hou.FolderParmTemplate for parm_template.
    See also the removeSpareParmTuple() and addSpareParmFolder() methods.
    This method is deprecated in favor of setParmTemplateGroup.
        """
        return ParmTuple()
    def allNodes(self):
        """
        Generator
        """
        return (Node(),)
    def allParms(self):
        """        """
        return (Parm(),)
    def creationTime(self):
        """Return the date and time when the node was created.
        """
        return 0
    def modificationTime(self):
        """Return the date and time when the node was last modified.
        """
        return 0
    def removeSpareParmFolder(self, folder):
        """    Removes an empty folder from the spare parameters.
folder is a sequence of folder names. So, to remove the Output folder, use ("Output",) instead of "Output".
See also addSpareParmFolder(), hou.ParmTemplateGroup.remove, and hou.ParmTemplateGroup.findFolder.
        """
        return
    def removeSpareParmTuple(self, parm_tuple):
        """    Removes the specified spare parameter tuple.
    See also addSpareParmTuple().
    This method is deprecated in favor of setParmTemplateGroup.
        """
        return
    def replaceSpareParmTuple(self, parm_tuple_name, parm_template):
        """    Replace an existing spare parameter tuple with a new one. The old parameter tuple is removed and the new one is added in its place.
    parm_tuple_name
    The name of the spare parameter tuple to replace. Raises hou.OperationFailed if no parameter tuple exists with this name, or if it is the name of a non-spare parameter.
    parm_template
    A hou.ParmTemplate describing the new parameter tuple.
    The new parameter tuple may or may not have the same name as the old one. By providing a parameter tuple with the same name, you can modify an existing spare parameter tuple.
    Note that you cannot replace non-spare parameter tuples. However, you can change the visibility of non-spare parameters using hou.ParmTuple.hide.
    To change a parameter for all instances of digital asset, use hou.HDADefinition.replaceParmTuple.
    This method is deprecated in favor of setParmTemplateGroup.
        """
        return
    def setParmExpressions(self, parm_dict, language=None, replace_expressions=True):
        """    Given a dictionary mapping parm names to expression strings, set each of the corresponding parms on this node to the given expression string in the dictionary.
    See hou.Parm.setExpression for a description of the language and replace_expressions parms.
    The following example expressions set the tx and sy parameters at once:
    >>> node = hou.node("/obj").createNode("geo")
    >>> node.setParmExpressions({"tx": 'ch("ty")', "sy": "sin($F)"})
    Raises hou.OperationFailed if any of the parameter names are not valid.
    See also the setParms method.
        """
        return
    def setParms(self, parm_dict):
        """    Given a dictionary mapping parm names to values, set each of the corresponding parms on this node to the given value in the dictionary.

    The following example sets the tx and sy parameters at once:

    >>> node = hou.node("/obj").createNode("geo")
    >>> node.setParms({"tx": 1, "sy": 3})

    Raises hou.OperationFailed if any of the parameter names are not valid.

    See also the setParmExpressions method.
setParmExpressions(self, parm_dict, language=None, replace_expressions=True)

    Given a dictionary mapping parm names to expression strings, set each of the corresponding parms on this node to the given expression string in the dictionary.

    See hou.Parm.setExpression for a description of the language and replace_expressions parms.

    The following example expressions set the tx and sy parameters at once:

    >>> node = hou.node("/obj").createNode("geo")
    >>> node.setParmExpressions({"tx": 'ch("ty")', "sy": "sin($F)"})

    Raises hou.OperationFailed if any of the parameter names are not valid.

    See also the setParms method.        """
        return
    def shiftPosition(self, delta):
        """Moves the position of this nodes tile in the network editor graph. Raises hou.InvalidInput if the node cannot have the given position.
delta

A tuple of two floats indicating how much the node should move. The first float indicates horizontal movement and the second indicates vertical movement.        """
        return
    def setDisplayFlag(self, val):
        pass
    def setRenderFlag(self, val):
        pass

class VexContext(object):
    def name(self):
        return ''
    def nodeTypeCategory(self):
        return  NodeTypeCategory()

    def pathsToLoadedVexFunctions(self):
        return {'':''}
    def shaderType(self):
        return shaderType()
# New in h15
class Selection(object):
    """
    hou.Selection

    A class that represents a geometry component selection.

    Component selections are not tied to any specific hou.Geometry.
    Therefore most method on this class must be passed a Geometry object to
    look up information about individual components. This explicit
    separation allows the selection class to be used as a utility class for
    processing geometry topology (growing the set of components, shrinking
    it, finding the boundary, etc.). This separation also avoids any
    expectations that changing the contents of a selection object might be
    expected to update the selection visible on some goemetry in the
    viewport. Setting the visible viewport selection must always be an
    explicit operation on a hou.SopNode in order for Houdini to be able to
    track changes properly.

    If a selection object is returned from a call to
    hou.Geometry.selection(), hou.GeometrySelection.selections(), or a
    hou.SopNode.selection(), the selection cannot be modified. A copy of the
    selection must be made first with the freeze() method. This new
    selection can be modified, and passed back into a
    hou.SopNode.setSelection() if desired. Because each SOP has a selection
    for each component type, when you set a new selection it will replace
    the existing selection of that component type. Note that this may not
    result in the visible selection in the viewport changing if the viewport
    is not currently configured to select that component type. The viewport
    selection type can be controlled with the class. A selection created by
    calling any of the hou.Selection() initializer methods are created in a
    modifiable state, so a call to freeze() is not required.

    A selection returned from a hou.Geometry or a hou.SopNode is a reference
    to the source selection, and so will change if the selection on the
    source geometry is changed. This seems like a departure from the
    separation of selection objects from any particular geometry, however it
    matches the behavior of the hou.Geometry class returned from a SOP node.
    This is because the underlying selection data is shared with the SOP
    rather than copied. The freeze() method can be used to force a copy of
    the selection data that is disconnected from any particular SOP (as well
    as allowing the selection contents to be modified).


    """
    thisown = False
    def __init__(self, *args):
        """
        Creates a new edge component selection from the passed in sequence of
        hou.Edge objects.
        """
        pass
    def __repr__(*args): pass
    def freeze(*args):
        """
        Returns a copy of the Selection object. This copy can be modified with
        any of the functions that alter the selection.
        """
        return Selection()

    def invert(self, geo):
        """
        Using the supplied hou.Geometry object for reference, inverts the
        current selection. The selection will contain only those components that
        were not in the selection before this method call.
        """
        pass

    def convert(self, geo, selection_type):
        """
        Using the supplied hou.Geometry object for reference, converts the
        current selection to the new .
        """
        pass

    def boundary(self, geo, uv_connectivity = False):
        """
        Using the supplied hou.Geometry object for reference, changes the
        selection to contain those components on the boundary of the current
        selection. The uv_connectivity parameter controls whether to use
        topology or uv attribute values to determine whether components are
        connected.
        """
        pass

    def grow(self, geo, uv_connectivity = False):
        """
        Using the supplied hou.Geometry object for reference, adds to the
        selection any components connected to the current selection. The
        uv_connectivity parameter controls whether to use topology or uv
        attribute values to determine whether components are connected.
        """
        pass

    def shrink(self, geo, uv_connectivity = False):
        """
        Using the supplied hou.Geometry object for reference, removes from the
        selection any components on the boundary of the current selection. The
        uv_connectivity parameter controls whether to use topology or uv
        attribute values to determine whether components are connected.
        """
        pass

    def combine(self, geo, selection, modifier):
        """
        Using the supplied hou.Geometry object for reference, combines this
        selection with another.
        geo
            A hou.Geometry object that is used when doing any selection
            conversions.
        selection
            A hou.Selection object that will be combined with the current
            selection. If this selection does not have the same component type
            as the current selection, an implicit conversion to the current
            component type is performed before combining the selections.
        modifier
            A value that controls how the selections will be combined. This lets
            you perform a union, intersection, or other operation on a pairs of
            selections.
        """
        pass

    def clear(*args):
        """
        Removes all components from the current selection.
        """
        return _hou.Selection_clear(*args)

    def selectionType(*args):
        """
        Returns a value indicating the type of component referenced by this
        selection.
        """
        pass

    def numSelected(*args):
        """
        Returns the number of components in the selection.
        """
        pass

    def prims(self, geo):
        """
        Returns a tuple of all primitives in the selection. If the selection
        does not contain primitives, an implicit conversion to primitives is
        performed to generate the return value.
        """
        return (Prim(),)

    def points(self, geo):
        """
        Returns a tuple of all points in the selection. If the selection does
        not contain points, an implicit conversion to points is performed to
        generate the return value.
        """
        return (Point(),)

    def vertices(self, geo):
        """
        Returns a tuple of all vertices in the selection. If the selection does
        not contain vertices, an implicit conversion to vertices is performed to
        generate the return value.
        """
        return (Vertex(),)

    def edges(self, geo):
        """
        Returns a tuple of all edges in the selection. If the selection does not
        contain edges, an implicit conversion to edges is performed to generate
        the return value.
        """
        return (Edge(),)

    def selectionString(self, geo, force_numeric = False, collapse_where_possible = True, asterisk_to_select_all = False):
        """
        Returns a string that specifies the selected components. The format of
        this string is appropriate for use in SOP Group parameter fields.
        geo
            A hou.Geometry object that is used when generating the selection
            string (such as determining if all components are selected).
        force_numeric
            Set this to True to force the generated string to contain only
            numeric ranges, even if the selection was constructed with group or
            attribute based selection.
        collapse_where_possible
            Set this to True to cause numeric ranges to be collapsed as much as
            possible, regardless of the selection order. So for example if the
            user selected primitive 3, then 2, then 1, the generated selection
            string would either be '3 2 1' or '1-3' depending on this parameter.
        asterisk_to_select_all
            When this parameter is set to False, if a selection contains all
            components in the supplied geometry, the resulting value is an empty
            string. This is appropriate when using the resulting string in a SOP
            node Group parameter. If this parameter is set to True, a full
            selection will return a value of '*' instead.


        """
        return ''


# Functions ############################################################################################################

def _addPreloadIcon(name, w, h):
  """
    _addPreloadIcon(name, w, h)

    Used internally by Houdini to preload icons for speed.
    """

def _getArgumentAutoComplete(method_name, arguments):
  """
    _getArgumentAutoComplete(method_name, arguments) -> tuple of strings

    This function is used internally by the Houdini Python shell for
    argument auto-completion on functions of the hou module.
    """
  return ('',)

def isUIAvailable():
  """
    isUIAvailable() -> bool

    Return whether or not the hou.ui module is available.

    The hou.ui module is not available in the command-line interpreter or in
    MPlay, and this function helps you to write scripts that will run in
    Houdini and command-line and/or MPlay.

    RELATED
      * hou.ui
    """
  return True

def exit(exit_code=0, suppress_save_prompt=False):
  """
    exit(exit_code=0, suppress_save_prompt=False)

    Exits Houdini, returning the exit code to the operating system. If
    suppress_save_prompt is false, this function asks the user if he/she
    wants to save. If the user presses "Cancel", the exit will be canceled
    and the next statement will execute.

    The exit confirmation prompt only appears if the session has unsaved
    changes. This function will not return until after the user has made a
    choice from the prompt. If this function is called from outside Houdini
    (e.g. MPlay or a non-graphical Python shell), the dialog is not
    displayed and suppress_save_prompt==True is implied.

    Note that if the user chose to exit, this function will raise a Python
    SystemExit exception to ensure the executing Python script terminates.
    This approach ensures that the next Python statement will not be
    executed, since Houdini may add events to its event queue that carry out
    the actual shutdown, or hou.exit() may be called from a different thread
    than the one executing the shutdown.

    Note that if you call sys.exit() from within the interactive Houdini
    Python shell, it will call hou.exit() with suppress_save_prompt=True.
    The Houdini Python shell does this by intercepting the SystemExit
    exception raised by sys.exit() and calling hou.exit(). Since both
    sys.exit() and hou.exit() both raise SystemExit exceptions, the shell
    calls hou._isExiting() to differentiate between the two.

    Avoid calling sys.exit() from any place other than the interactive
    Houdini Python shell, such as non-graphical Python shells, and instead
    call hou.exit(). Using hou.exit() ensures that Houdini shuts down
    cleanly.

    REPLACES
      * quit
    """

def _isExiting():
  """
    _isExiting() -> bool

    Returns whether Houdini is in the process of exiting. This function is
    called internally by the interactive Houdini Python shell.

    RELATED
      * hou.exit


    """
  return True

def applicationName():
  """
    applicationName() -> string

    Returns the application name.

    REPLACES
      * version

    RELATED
      * hou.applicationCompilationDate
      * hou.applicationVersion
      * hou.applicationVersionString
      * hou.applicationPlatformInfo
      * hou.licenseCategory
      * hou.isApprentice
    """
  return ''

def applicationCompilationDate():
  """
    applicationCompilationDate() -> string

    Returns the application's compilation date.

    If this method is executed in python, then it returns the date which the
    hou module was compiled on.

    REPLACES
      * version

    RELATED
      * hou.applicationName
      * hou.applicationVersion
      * hou.applicationVersionString
      * hou.applicationPlatformInfo
      * hou.licenseCategory
      * hou.isApprentice
    """
  return ''

def applicationPlatformInfo():
  """
    applicationPlatformInfo() -> string

    Returns a string containing information about the system that compiled
    this version of Houdini.

    Most of the time you can use Python's platform module to get information
    about the current operating system, processor type, etc.  However, this
    function can provide information not available through the platform
    module, such as the version of the compiler that compiled Houdini.

      >>> hou.applicationPlatformInfo()
      linux-x86_64-gcc4.4

    RELATED
      * hou.applicationCompilationDate
      * hou.applicationVersion
      * hou.applicationVersionString
      * hou.applicationName
      * hou.licenseCategory
      * hou.isApprentice
    """
  return ''

def licenseCategory():
  """
    licenseCategory() -> hou.licenseCategoryType enum value

    Return the category of license (Commercial, Apprentice, ApprenticeHD,
    etc.) in use.

    REPLACES
      * version

    RELATED
      * hou.licenseCategoryType
      * hou.applicationCompilationDate
      * hou.applicationName
      * hou.applicationVersion
      * hou.applicationVersionString
      * hou.isApprentice
    """
  return licenseCategoryType()

def isApprentice():
  """
    isApprentice() -> bool

    Return whether the application is an apprentice (non-commercial)
    version.

    Return whether the hou module is using an Apprentice license.  Note that
    this function returns True for both Apprentice and Apprentice HD.

    REPLACES
      * version

    RELATED
      * hou.licenseCategory
      * hou.applicationCompilationDate
      * hou.applicationName
      * hou.applicationVersion
      * hou.applicationVersionString
    """
  return True

def releaseLicense():
  """
    releaseLicense()

    Release the currently held Houdini license.

    When you import the hou module into a Python shell, it will acquire a
    Houdini license.  This function exists so you can release that license
    when you're done using the hou module.  This way, you can have a long
    running Python script that periodically uses Houdini without having to
    hold a Houdini license for the entire duration of the script.

    After you release the license, it will automatically be reacquired when
    you access functions and objects from the hou module.
    """

def maxThreads():
  """
    maxThreads() -> int

    Returns the number of threads used for processing.

    When Houdini/hython is started, it uses all available processors on  the
    machine for multi-threaded processing, unless overridden by the -j
    command line option or the hou.setMaxThreads function.

    This function returns that maximum number of threads that Houdini/hython
    will use.

    RELATED
      * hou.setMaxThreads
    """
  return 0

def setMaxThreads(max_threads):
  """
    setMaxThreads(max_threads)

    Sets the maximum number of threads to use for multi-processing.

    When Houdini/hython is started, it uses all available processors on  the
    machine for multi-threaded processing, unless overridden by the -j
    command line option.

    This function allows dynamically adjusting this setting at run-time.

    Note that this function may only be called from the main thread. If
    called from an expression that gets evaluated in a multi-threaded
    context, or during other processing, it will throw an exception.

    RELATED
      * hou.maxThreads


    """

def root():
  """
    root() -> hou.Node

    Return the root node (i.e. /).

    This function is a shortcut for writing hou.node("/").

    This function will raise hou.NotAvailable if you call it from MPlay.

    RELATED
      * hou.node_


    """
  return Node()

def pwd():
  """
    pwd() -> hou.Node

    If called from an evaluating parm, return the node containing the parm.
    Otherwise, return Houdini's global current node.  You can change this
    current node with hou.cd

    This function is a shortcut for writing hou.node(".").

    Note that Python and hscript both share the same global current node.
    So, if you change that node in hscript, the return value of pwd() will
    reflect that change, and vice versa.

    Note that if this function is called from an expression inside a node's
    parameter, Houdini will return the node containing the expression, not
    Houdini's current node.  This behavior permits relative parameter and
    node references from both Hscript and Python parameter expressions,
    since functions like hou.ch, ch, hou.evalParm, hou.parm_, and hou.node_
    are relative to the result of hou.pwd().

    This function will raise hou.NotAvailable if you call it from MPlay.

    RELATED
      * hou.cd
      * hou.parent

    REPLACES
      * oppwf
      * oppwf
      * oppwd
      * opfullpath


    """
  return Node()

def parent():
  """
    parent() -> hou.Node or None

    Return the parent of the current node.

    This function is a shortcut for writing hou.node("..").  It returns
    the parent of the current node (i.e. the node returned by hou.pwd).

    This function will raise hou.NotAvailable if you call it from MPlay.

    RELATED
      * hou.node_


    """
  return Node()

def setPwd():
  """
    setPwd(node)

    Make the given node Houdini's current node. This function is equivalent
    to hou.cd(node.path()).

    This function will raise hou.ObjectWasDeleted if the parameter refers to
    a node that no longer exists in Houdini.

    This function will raise hou.NotAvailable if you call it from mplay.

    RELATED
      * hou.pwd
      * hou.cd

    REPLACES
      * opcf


    """

def cd(path):
  """
    cd(path)

    Change the current node. Houdini has one current node, analogous to a
    current directory in a file system. If a relative path is given, it is
    relative to the node returned by hou.pwd().

    If no node exists at the path, this function raises hou.OperationFailed.

    Even though, when called from a parameter's expression, hou.pwd()
    returns the node containing the parameter and not Houdini's current
    node, hou.cd() will always change the current node.

    This function will raise hou.NotAvailable if you call it from MPlay.

    RELATED
      * hou.pwd
      * hou.setPwd

    REPLACES
      * opcf
    """

def phm():
  """
    phm() -> hou.HDAModule

    A shortcut for hou.pwd().hdaModule().

    This shortcut lets you write hou.phm() instead of hou.pwd().hdaModule().
    You are most likely to use this shortcut from event handlers, button
    callbacks, and menu generation scripts in digital assets.

    See hou.pwd and hou.Node.hdaModule for more information.


    """
  return HDAModule()

def currentDopNet():
  """
    currentDopNet() -> DopNetNode


    """
  return DopNetNode()

def setCurrentDopNet(dopnet):
  """
    setCurrentDopNet(dopnet)
    """

def simulationEnabled():
  """
    simulationEnabled() -> bool
    """
  return True

def setSimulationEnabled(enabled):
  """
    setSimulationEnabled(enabled)
    """

def node(path):
  """
    node(path) -> hou.Node or None

    Given a path string, return a Node object.  Return None if the path does
    not refer to a node.

    If the path starts with a /, Houdini will look for a node with that
    exact path.  Otherwise, the Houdini searches relative to the current
    path. See hou.pwd for more information about Houdini's current path.
    For each occurrence of .. in the path, Houdini will move up one node
    from the current location.

    Raises hou.NotAvailable if you call it from MPlay.

    Be careful not to confuse this function with the class hou.Node.

      >>> hou.node("/obj")
      <hou.Node at /obj>
      >>> hou.node("/obj").createNode("geo")
      <hou.ObjNode of type geo at /obj/geo1>
      >>> hou.node("/obj").createNode("geo")
      <hou.ObjNode of type geo at /obj/geo2>
      >>> hou.node("/obj/geo1")
      <hou.ObjNode of type geo at /obj/geo1>
      >>> hou.cd("/obj")
      >>> hou.node("geo1")
      <hou.ObjNode of type geo at /obj/geo1>
      >>> hou.cd("/obj/geo2")
      >>> hou.node("../geo1")
      <hou.ObjNode of type geo at /obj/geo1>
      >>> print hou.node("../geo3")
      None

    RELATED
      * hou.pwd
      * hou.parent
      * hou.root

    REPLACES
      * opfind
      * ch
      * chs
      * chsop
      * opexist


    """
  return Node()

def nodeBySessionId(session_id):
  """
    nodeBySessionId(session_id) -> hou.Node or None

    Given a node's session id, return a Node object.  Return None if the id
    does not correspond to a valid node (e.g. if the node was deleted).

    See hou.Node.sessionId for more information.

    Raises hou.NotAvailable if you call it from MPlay.

    REPLACES
      * opfind
      * ch
      * chs
      * chsop
      * opexist

    RELATED
      * hou.node_
      * hou.Node.sessionId


    """
  return Node()

def copyNodesToClipboard(nodes):
  """
    copyNodesToClipboard(nodes)

    Copy given nodes to clipboard.

    This function copies given nodes to clipboard.

    The nodes to be copied should be a sequence of hou.Node objects that
    have the same parent. Copying nodes from different networks at the same
    time is currently not supported.

    RELATED
      * hou.pasteNodesFromClipboard

    REPLACES
      * opcopy
    """

def pasteNodesFromClipboard(destination_node):
  """
    pasteNodesFromClipboard(destination_node)

    Paste previously copied nodes to a given network.

    This function pastes nodes from clipboard into the destination network.

    RELATED
      * hou.copyNodesToClipboard

    REPLACES
      * oppaste
    """

def parm(path):
  """
    parm(path) -> hou.Parm or None

    Given a path string, return a Parm object.  Return None if the path does
    not refer to a parameter.

    If the path starts with a /, Houdini will look for a parameter with that
    exact path.  Otherwise, the Houdini searches relative to the current
    node path.  For each occurrence of .. in the path, Houdini will move up
    one node from the current node location.

      >>> node = hou.node("/obj").createNode("geo")
      >>> node.path()
      '/obj/geo1'
      >>> hou.parmTuple("/obj/geo1/t")
      <hou.ParmTuple t in /obj/geo1>
      >>> hou.parmTuple("/obj/geo1/t")[0]
      <hou.Parm tx in /obj/geo1>
      >>> hou.parm("/obj/geo1/tx")
      <hou.Parm tx in /obj/geo1>
      >>> hou.setPwd(node)
      >>> hou.parm("t")
      <hou.Parm tx in /obj/geo1>

    Raises hou.NotAvailable if you call it from MPlay.

    RELATED
      * hou.Parm
      * hou.evalParm
      * hou.parmTuple_

    REPLACES
      * ch
      * chs
      * chexist
    """
  return Parm()

def parmTuple(path):
  """
    parmTuple(path) -> hou.ParmTuple or None

    Given a path string, return a ParmTuple object.  Return None if the path
    does not refer to a parameter tuple.

    If the path starts with a /, Houdini will look for a parameter tuple
    with that exact path.  Otherwise, the Houdini searches relative to the
    current node path.  For each occurrence of .. in the path, Houdini will
    move up one node from the current node location.

    When a parameter is evaluating, hou.pwd returns the node containing that
    parameter, so hou.parmTuple() can be used inside expressions to perform
    relative parameter references.

      >>> node = hou.node("/obj").createNode("geo")
      >>> node.path()
      '/obj/geo1'
      >>> hou.parmTuple("/obj/geo1/t")
      <hou.ParmTuple t in /obj/geo1>
      >>> hou.setPwd(node)
      >>> hou.parmTuple("tx")
      <hou.ParmTuple t in /obj/geo1>

    Raises hou.NotAvailable if you call it from MPlay.

    RELATED
      * hou.ParmTuple
      * hou.evalParmTuple
      * hou.parm_

    REPLACES
      * ch
      * chexist
      * chramp
      * chs


    """
  return ParmTuple()

def evaluatingParm(self):
  """
    evaluatingParm() -> hou.Parm

    Return the parameter that is currently evaluating.

    You can call this function from a parameter expression to determine
    which parameter is currently evaluating.  This function provides the
    Python equivalent of Hscript's $CH variable.


    """
  return Parm()

def parmClipboardContents():
  """
    parmClipboardContents() -> tuple of dictionaries

    Returns the contents of the parameter clipboard as a tuple of copied
    parameter dictionaries.

    Returns a tuple of dictionaries, one per copied hou.Parm. Each
    dictionary has the following keys.

    path
        The path of hou.Parm parameter when it was copied.

    value
        The evaluated value of the parameter when it was copied as a string.

    expression
        The expression of the parameter when it was copied as a string.

    expressionLanguage
        The expression language of the parameter when it was copied. This is
        a string. To convert to a hou.exprLanguage object, use
        getattr(hou.exprLanguage, expr_language_str).

    RELATED
      * hou.Parm.copyToParmClipboard
      * hou.ParmTuple.copyToParmClipboard


    """
  return ({},)

def evalParm(path):
  """
    evalParm(path) -> int, float, or string

    Evaluate a parameter, given either an absolute or a relative path to it.
    Relative path searches are done from the node returned by . This
    function is a shortcut for hou.parm(path).eval().

    The return type will depend on the type of the parameter.

    When a parameter is evaluating, hou.pwd returns the node containing that
    parameter, so hou.evalParm() can be used inside expressions to perform
    relative parameter references.

    This function throws a hou.NotAvailable exception if you call it from
    MPlay.

    RELATED
      * hou.evalParmTuple
      * hou.Parm
      * hou.ParmTuple

    REPLACES
      * ch
      * chs


    """
  return None

def evalParmTuple(path):
  """
    evalParmTuple(path) -> tuple of int, float, or str, or hou.Ramp

    Evaluate a parameter, given either an absolute or a relative path to it.
    Relative path searches are done from the node returned by . This
    function is a shortcut for hou.parmTuple(path).eval().

    The return type will depend on the type of the parameter.

    When a parameter is evaluating, hou.pwd returns the node containing that
    parameter, so hou.evalParmTuple() can be used inside expressions to
    perform relative parameter references.

    This function throws a hou.NotAvailable exception if you call it from
    MPlay.

    RELATED
      * hou.evalParm
      * hou.Parm
      * hou.ParmTuple

    REPLACES
      * ch
      * chramp
      * chs

    """
  return

def ch(path):
  """
    ch(path) -> int, float, or string

    The same as evalParm(). Provided for backward compatibility.

    RELATED
      * hou.evalParm
      * hou.evalParmTuple
      * hou.chsop
      * hou.parm
      * hou.parmTuple

    REPLACES
      * ch
      * chs


    """
  return

def hscriptExpression(expression_string):
  """
    hscriptExpression(expression_string) -> float, str, or tuple

    Evaluate an Hscript expression.

    Given an expression string, this function evaluates it as though it was
    an HScript expression on a parameter.  The return type depends on the
    expression.

    Raises hou.OperationFailed if the expression is invalid or generates an
    error occur during evaluation.

      >>> hou.hscriptExpression("$HIP")
      '/path/to/hip/directory'
      >>> hou.hscriptExpression("$F")
      1.0
      >>> hou.hscriptExpression('vector("[1, 2, 3]")')
      (1.0, 2.0, 3.0)
      >>> hou.hscriptExpression('matrix("[[1, 2][3, 4]]")')
      ((1.0, 2.0), (3.0, 4.0))
      >>> hou.hscriptExpression("hello")
      'hello'
      >>> hou.hscriptExpression("'hello'")
      'hello'
      >>> hou.hscriptExpression("'hello' + ' world'")
      'hello world'
      >>> hou.hscriptExpression('"$F"')
      '1'
      >>> hou.hscriptExpression("'$F'")
      '$F'

    This function is somewhat similar to hou.expandString, however,
    expandString will replace the portions of the string containing
    variables, leaving the rest of the string unchanged.  If the variable is
    unknown, it will not do any expansion.

      >>> hou.expandString("$HOME")
      '/home/me'
      >>> hou.expandString("HOME is $HOME")
      'HOME is /home/me'
      >>> hou.hscriptExpression("HOME is $HOME")
      Traceback (most recent call last):
        File "<console>", line 1, in <module>
        File "/opt/hfs10.5/houdini/python2.5libs/hou.py", line 19331, in hscriptExpression
          return _hou.hscriptExpression(*args)
      OperationFailed: The attempted operation failed.
      Syntax error - extra tokens detected in expression
      >>> hou.expandString("$F")
      '1'
      >>> hou.expandString('"$F"')
      '"1"'
      >>> hou.hscriptExpression("$GARBAGE")
      Traceback (most recent call last):
        File "<console>", line 1, in <module>
        File "/opt/hfs10.5/houdini/python2.5libs/hou.py", line 19331, in hscriptExpression
          return _hou.hscriptExpression(*args)
      OperationFailed: The attempted operation failed.
      Undefined variable
      >>> hou.expandString("$GARBAGE")
      '$GARBAGE'
      >>> hou.hscript("echo -n $GARBAGE")[0]
      ''
      >>> hou.expandString("")
      ''
      >>> hou.hscriptExpression("")
      Traceback (most recent call last):
        File "<console>", line 1, in <module>
        File "/opt/hfs10.5/houdini/python2.5libs/hou.py", line 19331, in hscriptExpression
          return _hou.hscriptExpression(*args)
      OperationFailed: The attempted operation failed.
      Invalid expression

    RELATED
      * hou.hscriptFloatExpression
      * hou.hscriptStringExpression
      * hou.hscriptVectorExpression
      * hou.hscriptMatrixExpression
      * hou.expandString
      * hou.expandStringAtFrame


    """
  return

def expressionGlobals():
  """
    expressionGlobals() -> dict

    Return the globals dictionary used by the parameter expression
    evaluation namespace.

    When Houdini evaluates a Python expression inside a parameter, it uses a
    separate namespace.  This way, Houdini can run from hou import * and
    from hou.session import * in that namespace, allowing you to drop the
    hou. and hou.session. prefixes in your expressions, and the global
    namespace does not get polluted.

    In Python, namespaces are stored as dictionaries.  This function returns
    the dictionary for the Python parameter expression namespace.  It is
    analogous to the builtin globals function, which returns you the
    dictionary for the current namespace.

    You might use this function from the pythonrc.py file to set up Python
    functions that can be called from any Python parameter expression.  For
    example, if you put your functions in a module called expr, you might
    put the following in pythonrc.py:

      import expr
      hou.expressionGlobals()['expr'] = expr

    Then, from a Python expression, you could write expr.foo(), where foo is
    a function defined in your expr module.

    You can also use this dictionary with Python's exec statement.  The
    following example also imports the expr module into the both the global
    and expression namespaces:

      code = compile("import expr", "<generated_code>", "exec")
      exec code
      exec code in hou.expressionGlobals()

    See Python Parameter Expressions for more information on using Python
    expressions in parameters.  See Session Independent Scripts for more
    information about pythonrc.py.


    """
  return {}

def loadCPIODataFromString(data):
  """
    loadCPIODataFromString(data) -> tuple of (str, str`)

    Given a string containing data in CPIO data format, decode the data and
    return a sequence of (name, value) pairs representing the data.

    CPIO data format stores an ordered sequence of (name, value) pairs.  The
    same name may occur multiple times.  Is most commonly used to store hip
    files and contents sections inside assets.  The other common file format
    used in Houdini is index file format.

    If the data is not in CPIO data format, this function returns an empty
    tuple.

    The inverse of this function is hou.saveCPIODataToString.

    RELATED
      * hou.saveCPIODataToString
      * hou.loadIndexDataFromString
      * hou.saveIndexDataToString
    """
  return ('','')

def loadIndexDataFromString(data):
  """
    loadIndexDataFromString(data) -> dict

    Given a string containing data in index data format, decode the data and
    return a dictionary representing the data.

    Index data format stores an unordered mapping of (key, value) pairs.  Is
    used to store otl files and asset definition sections, preset files,
    icon archives, and other files in Houdini.  The other common file format
    used in Houdini is CPIO.

    If the data is not in index data format, this function returns an empty
    dictionary.

    The inverse of this function is hou.saveIndexDataToString.

    RELATED
      * hou.saveIndexDataToString
      * hou.loadIndexDataFromFile
      * hou.saveIndexDataToFile
      * hou.loadCPIODataFromString
      * hou.saveCPIODataToString
    """
  return {}

def hscriptFloatExpression(expression):
  """
    hscriptFloatExpression(expression) -> float

    Evaluate an Hscript expression as a float.

    This function will force the return type to be a float.

    Most of the time, you want to use hou.hscriptExpression over this
    function.  See it for more examples.

    Raises hou.OperationFailed if the expression is invalid or generates an
    error occur during evaluation.

    If the expression contains variables, Houdini will attempt to evaluate
    them as floats, and use the value 0.0 if they cannot be converted to
    floats. However, if the expression definitely evaluates to a string that
    does not start with a number, this function raises hou.OperationFailed.

      >>> hou.hscriptFloatExpression("3")
      3.0
      >>> hou.hscriptFloatExpression("'3'")
      3.0
      >>> hou.hscriptFloatExpression("'3X'")
      3.0
      >>> hou.hscriptFloatExpression("'X3'")
      Traceback (most recent call last):
        File "<console>", line 1, in <module>
        File "/opt/hfs10.5/houdini/python2.5libs/hou.py", line 9359, in hscriptFloatExpression
          return _hou.hscriptFloatExpression(*args)
      OperationFailed: The attempted operation failed.
      Bad data type for function or operation
      >>> hou.hscriptFloatExpression("3X")
      Traceback (most recent call last):
        File "<console>", line 1, in <module>
        File "/opt/hfs10.5/houdini/python2.5libs/hou.py", line 9359, in hscriptFloatExpression
          return _hou.hscriptFloatExpression(*args)
      OperationFailed: The attempted operation failed.
      Syntax error - extra tokens detected in expression
      >>> hou.hscriptFloatExpression("$F")
      1.0
      >>> hou.hscriptFloatExpression('"$F"')
      1.0
      >>> hou.hscriptFloatExpression("$HOME")
      0.0
      >>> hou.hscriptFloatExpression('"$HOME"')
      Traceback (most recent call last):
        File "<console>", line 1, in <module>
        File "/opt/hfs10.5/houdini/python2.5libs/hou.py", line 9359, in hscriptFloatExpression
          return _hou.hscriptFloatExpression(*args)
      OperationFailed: The attempted operation failed.
      Bad data type for function or operation
      >>> hou.hscriptFloatExpression("'$F'")
      Traceback (most recent call last):
        File "<console>", line 1, in <module>
        File "/opt/hfs10.5/houdini/python2.5libs/hou.py", line 9359, in hscriptFloatExpression
          return _hou.hscriptFloatExpression(*args)
      OperationFailed: The attempted operation failed.
      Bad data type for function or operation

    RELATED
      * hou.hscriptExpression
      * hou.hscriptStringExpression
      * hou.hscriptVectorExpression
      * hou.hscriptMatrixExpression


    """
  return 0.0

def hscriptStringExpression(expression):
  """
    hscriptStringExpression(expression) -> string

    Evaluate an Hscript expression as a float.

    This function will force the return type to be a string.  If the
    expression does not evaluate to a string, this function returns its
    string representation.

    Most of the time, you want to use hou.hscriptExpression over this
    function.  See it for more examples.

    Raises hou.OperationFailed if the expression is invalid or generates an
    error occur during evaluation.

      >>> hou.hscriptStringExpression("3")
      '3'
      >>> hou.hscriptStringExpression('"3"')
      '3'
      >>> hou.hscriptStringExpression("$F")
      '1'
      >>> hou.hscriptStringExpression('vector("[1, 2, 3]")')
      '[1,2,3]'

    RELATED
      * hou.hscriptExpression
      * hou.hscriptFloatExpression
      * hou.hscriptVectorExpression
      * hou.hscriptMatrixExpression


    """
  return ''

def hscriptVectorExpression(expression):
  """
    hscriptVectorExpression(expression) -> tuple of floats

    Evaluate an Hscript expression as a vector.

    This function will force the return type to be an Hscript vector.
    Because Hscript vectors can be be of different lengths, the value is
    returned as a tuple of floats.  If you know the vector is a particular
    length, you can construct a Vector2/Vector3/Vector4 out of the return
    value.

    Most of the time, you want to use hou.hscriptExpression over this
    function.

      vector = hou.Vector3(hou.hscriptVectorExpression('vtorigin("/obj/geo1", "/obj/geo2")'))
      print vector.length()

    Raises hou.OperationFailed if the expression is invalid or generates an
    error occur during evaluation.

    RELATED
      * hou.hscriptExpression
      * hou.hscriptFloatExpression
      * hou.hscriptStringExpression
      * hou.hscriptMatrixExpression
      * hou.Vector2
      * hou.Vector3
      * hou.Vector4


    """
  return (0.0,)

def hscriptMatrixExpression(expression):
  """
    hscriptMatrixExpression(expression) -> tuple of tuple of floats

    Evaluate an Hscript expression as a vector.

    This function will force the return type to be an Hscript matrix.
    Because Hscript matrices can be be of different sizes, the value is
    returned as a tuple of tuples of floats.  If you know the matrix is a
    particular size, you can construct a Matrix3/Matrix4 out of the return
    value.

    Most of the time, you want to use hou.hscriptExpression over this
    function.

      xform = hou.Matrix4(hou.hscriptMatrixExpression('doptransform("/obj/dopnet1", "obj0", "Geometry")'))

    Raises hou.OperationFailed if the expression is invalid or generates an
    error during evaluation.

    RELATED
      * hou.hscriptExpression
      * hou.hscriptFloatExpression
      * hou.hscriptStringExpression
      * hou.hscriptVectorExpression
      * hou.Matrix3
      * hou.Matrix4


    """
  return ((0.0,),)

def expandString(str):
  """
    expandString(str) -> str

    Expands global variables and expressions in a string at the current
    frame.

    Expands global variables in the expression. For example, when Houdini is
    at  frame 10:

      >>> hou.expandStringAtFrame('$F')
      '10'

    Also expands HScript expressions in backticks, such as the channel
    reference  in this example. This returns the value of the translate X
    parameter for geo1  at the current frame as a string:

      hou.expandStringAtFrame('`ch("/obj/geo1/tx")`')

    This function evaluates the string as if it were the contents of a non-
    animated text parameter. To evaluate a straight HScript expression
    (without needing backticks), use hou.hscriptExpression.

    Raises hou.OperationFailed exception if the first argument is None.

      >>> hou.expandString("$HIP/file.geo")
      '/dir/containing/hip/file/file.geo'
      >>> hou.expandString("file`$F+1`.pic")
      'file2.pic'

    RELATED
      * hou.expandStringAtFrame
      * hou.hscriptExpression


    """
  return ''

def expandStringAtFrame(str, frame_number):
  """
    expandStringAtFrame(str, frame_number) -> str

    Expands global variables and expressions in a string at a given frame.

    Expands global variables in the expression. For example:

      >>> hou.expandStringAtFrame('$F', 10)
      '10'

    Also expands HScript expressions in back-ticks, such as the channel
    reference  in this example. This returns the value of the translate X
    parameter for geo1  at the current frame as a string:

      hou.expandStringAtFrame('`ch("/obj/geo1/tx")`', hou.frame())

    This function evaluates the string as if it were the contents of a non-
    animated text parameter. To evaluate a straight HScript expression
    (without  needing back-ticks), use hou.hscriptExpression.

    Raises hou.OperationFailed exception if the first argument is None.

    RELATED
      * hou.expandString
      * hou.hscriptExpression

    """
  return ''

def hscriptExpandString(str):
  """
    hscriptExpandString(str) -> string

    Deprecated: Use expandString.


    This is deprecated.  Use hou.expandString instead.

    RELATED
      * hou.expandString


    """
  return ''

def lvar(name):
  """
    lvar(name) -> float

    Return the value of a node's local variable.  Call this function from
    expressions inside node parameters.

    Many SOP and POP algorithms involve iterating over a series of points
    (or primitives or vertices, but we'll use points for the examples).
    These SOP and POP nodes evaluate their parameters for each point,
    setting a variable that you can access from an expression in that
    parameter to a value specific to that point.  For example, the TX
    variable is set to evaluate to the X value of the position of the
    current point.  These variables are called local variables because they
    are local to the expressions inside parameters in the node.

    In the Hscript expression language, you use $ to evaluate local
    variables, just like how you evaluate global variables.  In Python, you
    use the lvar function.  So, the Python equivalent of $TX is
    lvar("TX").


    Inside a parameter expression you can drop the hou. prefix from the call
    to lvar, since Houdini implicitly runs from hou import * when it
    evaluates expressions.

    If you call this function from outside a parameter expression it will
    raise hou.NotAvailable.  If you call it with an invalid variable name,
    it will raise hou.OperationFailed.  Note that you cannot use this
    function to evaluate Houdini global variables; instead use
    hou.expandString.

    Note that hou.SopNode.curPoint and similar methods on the hou.SopNode
    and hou.PopNode classes return the current point that the node is
    iterating over.  Using the point, you can evaluate attributes, etc, to
    perform the equivalent of a local variable.  You can also access
    information that may not be accessible through local variables.

    RELATED
      * hou.SopNode.curPoint
      * hou.SopNode.curPoint2
      * hou.SopNode.curPrim
      * hou.SopNode.curPrim2
      * hou.SopNode.curVertex
      * hou.SopNode.curVertex2
      * hou.PopNode.curPoint
      * hou.expandString
    """
  return 0

def putenv(name, value):
  """
    putenv(name, value)

    Set the value of the specified Houdini environment variable.

    Set the value of the specified Houdini environment variable.

    RELATED
      * hou.getenv
      * hou.unsetenv
    """

def unsetenv(name):
  """
    unsetenv(name)

    Unset the specified Houdini environment variable.

    Unset the specified Houdini environment variable.

    RELATED
      * hou.getenv
      * hou.putenv
    """

def allowEnvironmentToOverwriteVariable(name, onoff):
  """
    allowEnvironmentToOverwriteVariable(name, onoff)

    Allow (or disallow) an environment variable to overwrite the value of a
    global variable saved in a hip file.

    Note that you need to allow the variable to be overwritten from within
    Houdini/hython _before_ loading in the hip file.

    For example, suppose you set the JOB environment variable to
    /home/john/dyproject and created a hip file in
    /home/john/myproject/hip/scene.hip.  Your hip file could then reference
    files using a $JOB prefix.  If you then moved your project to
    /mnt/projects/myproject you cannot simply change the JOB environment
    variable because Houdini saved the old value of $JOB to the hip file.
    This function lets you override the value of $JOB before you load the
    hip file, as follows:
      import os
      os.environ["JOB"] = "/mnt/projects/myproject"
      hou.allowEnvironmentVariableToOverwriteVariable("JOB", True)
      hou.hipFile.load(os.path.expandvars("$JOB/hip/scene.hip"))
    """

def runVex(vex_file, inputs):
  """
    runVex(vex_file, inputs) -> dict of str to values

    Invoke VEX code, passing in arrays of inputs and receiving arrays of
    outputs.

    inputs
        A dictionary mapping VEX input names to values.  Each value may be a
        tuple or a single value; tuples of values become varying inputs and
        single values become uniform inputs.  If the input value is a tuple,
        all elements in the tuple must be the same type.

        Values may be single values or tuples of the following types: int,
        float, str, hou.Vector3, hou.Vector4, hou.Matrix3, or hou.Matrix4.

    return value
        A dictionary mapping VEX output names to values.  Like the inputs
        dictionary, values will be tuples if the output is varying and
        single values if it is uniform.

    For example, suppose you had the following VEX function and compiled it
    to the file code.vex using vcc:
      cvex add(float x=0 float y=0, export float out=0)
      {
          out = x + y;
      }


    You could then invoke it from Python using the following:
      >>> hou.runVex("code.vex", {"x":(1.0, 2.0, 3.0), "y":(7.1, 8.1, 9.1)})
      {"out": (8.1, 10.1, 12.1)}
      >>> hou.runVex("code.vex", {"x":(1.0, 2.0, 3.0), "y":0.5})
      {"out": (1.5, 2.5, 3.5)}
      >>> hou.runVex("code.vex", {"x":1.0, "y":0.5})
      {"out": 1.5}


    The following function shows how you can run VEX on the code created by
    a VOP network node, such as a CVEX VOP:
      import os
      import tempdir

      def runVexFromNode(vop_node, inputs):
          temp_file_path = tempfile.gettempdir() + "/%s.vex" % vop_node.name()
          vop_node.saveCompiledCookCodeToFile(temp_file_path)
          os.unlink(temp_file_path)

    """
  return {"":0}

def imageResolution(image_file_name):
  """
    imageResolution(image_file_name) -> tuple of int

    Return the resolution of an image in a file.

    Returns the width and height of an image stored in a file.

    Another way to get the resolution of an image is to load it into a file
    cop and retrieve it.  For example, this method could be approximately
    implemented as follows:

      def imageResolution(image_file_name):
          file_cop = hou.node("/img/comp1").createNode("file")
          file_cop.setParm("filename1", image_file_name)
          resolution = (file_cop.xRes(), file_cop.yRes())
          file_cop.destroy()
          return resolution

    Note, however, that this method is faster than loading the image into
    Houdini and retrieving the resolution because it is much less disk
    intensive.  It does not load the image data from disk, and instead only
    loads as much as necessary to retrieve the resolution.

    Raises hou.OperationFailed if the image file does not exist or if it's
    not an image file type supported by Houdini.

    The following example retrieves the resolution of the default.pic file
    that ships with Houdini.
      >>> hou.imageResolution(hou.findFile("pic/default.pic"))
      (512, 512)


    RELATED
      * hou.CopNode.xRes
      * hou.CopNode.yRes


    """
  return (0,)

def updateModeSetting():
  """
    updateModeSetting() -> hou.updateMode enum value

    Return Houdini's cook update mode (Auto Update/On Mouse Up/Manual) that
    is displayed in the status bar.

    Houdini's update mode determines when it will recook its nodes after you
    make parameter changes.  When it is Auto Update, it will recook whenever
    any parameter changes.  When it is On Mouse Up, it will not recook while
    you are tuning a parameter with a viewport or ladder handle until you
    release the mouse.  When it is Manual, it will only recook when you
    press the update button in the status bar.

    Note that this function is named updateModeSetting because
    hou.updateMode refers to the submodule containing enumeration values.
    This function used to be in the hou.ui submodule, but it was moved into
    the main hou module because it also applies to a non-graphical Houdini.

      >>> # Prevent Houdini from cooking any nodes.
      >>> hou.setUpdateMode(hou.updateMode.Manual)
      >>> hou.updateModeSetting()
      hou.updateMode.Manual

    RELATED
      * hou.setUpdateMode
      * hou.ui.triggerUpdate.


    """
  return updateMode()

def setUpdateMode():
  """
    updateModeSetting() -> hou.updateMode enum value

    Return Houdini's cook update mode (Auto Update/On Mouse Up/Manual) that
    is displayed in the status bar.

    Set Houdini's cook update mode to a hou.updateMode enumerated value. See
    hou.updateModeSetting for more information.


    """
  return updateMode()

def chsop(path):
  """
    chsop(path) -> string

    Evaluate a parameter that references a node, and return the absolute
    path to the node.

    RELATED
      * hou.evalParm

    REPLACES
      * chsop
    """
  return ''

def patternMatch(pattern_string, input_string):
  """
    patternMatch(pattern_string, input_string) -> int

    Matches a pattern in a string.

    This function is case-sensitive.  Returns 1 if any patterns in the
    pattern string matches the input string, or 0 if no patterns match.

    In order to match, a pattern must match the input string from beginning
    to end. Use wildcards (*) to match substrings, e.g.

      >>> hou.patternMatch("bar", "foobarbaz")
      0
      >>> hou.patternMatch("*bar*", "foobarbaz")
      1

    pattern is a space-separated list of one or more patterns. This can
    cause unintuitive behavior of this function. For example:

      >>> hou.patternMatch("foo bar", "foo bar")
      0

    ...will return 0, because the first argument consists of two patterns,
    foo and bar, and neither of those patterns match foo bar (since the
    pattern must match from beginning to end).

    Similarly,

      >>> hou.patternMatch("foo bar", "foo")
      1

    ...will return 1, because the string matches the first of the two
    arguments in the pattern (foo and bar).


    """
  return 0

def managerNodeTypeCategory():
  """
    managerNodeTypeCategory() -> NodeTypeCategory

    Return the NodeTypeCategory instance for Houdini manager nodes. The
    manager nodes are /obj, /out, /part, /ch, /shop, /img, and /vex.

    Note that some container node types, like the shop network node type,
    are called managers in Houdini. The node type category for an instance
    of those nodes will be the same as other nodes in that same network. For
    example, a shop network in objects will be in the objects node type
    category, while a shop network in a sop network will be in the geometry
    node type category.


    """
  return NodeTypeCategory()

def rootNodeTypeCategory():
  """
    rootNodeTypeCategory() -> NodeTypeCategory

    Return the NodeTypeCategory instance for Houdini root (/) node. There is
    only one instance of the root node, and it has its own node type
    category.


    """
  return NodeTypeCategory()

def nodeTypeCategories():
  """
    nodeTypeCategories() -> dict of str to hou.NodeTypeCategory

    Return a dictionary where the keys are the category names (e.g.
    "Object", "Sop") and the values are hou.NodeTypeCategory objects.


    """
  return {"":NodeTypeCategory()}

def copyNodesTo(nodes, destination_node):
  """
    copyNodesTo(nodes, destination_node) -> tuple of Nodes

    Copy all given nodes to a new place in node hierarchy.

    The nodes to be copied should be a sequence of hou.Node objects. The
    destination node will be the parent of new copied nodes. The type of all
    source nodes should match the destination node child type.

    This function returns a tuple of hou.Node objects corresponding to the
    copied nodes.

    Nodes will be copied to the destination in batches based on their
    parent. All the nodes in a batch will be copied at the same time. This
    way, any relative channel references between nodes with the same parent
    will be updated to reflect the copied node location. Batches themselves
    will be copied sequentially. Thus, channel references between nodes with
    different parents will not be updated in copies.

    For every copied node, if a node with the same name already exists at
    the destination, the copy will be renamed. Any relative channel
    references to the copy will be updated with the new copy name.

    This function will raise a hou.OperationFailed exception if any of the
    nodes to be copied are of invalid type, the destination node cannot be
    copied into, or source node type does not match the destination node
    child type.

    This function will raise hou.ObjectWasDeleted if any of source nodes or
    the destination node no longer exist in Houdini.

    All of the above issues with source and destination nodes will be
    reported before copying starts to avoid partial copy.

    After the function finishes execution, all the new nodes created by it
    will be selected.

    REPLACES
      * opcp


    """
  return (Node(),)

def moveNodesTo(nodes, destination_node):
  """
    moveNodesTo(nodes, destination_node) -> tuple of Nodes

    Move all given nodes to a new place in node hierarchy.

    The nodes to be moved should be a sequence of hou.Node objects. The
    destination node will be the parent of new copied nodes. The type of all
    source nodes should match the destination node child type.

    This function returns a tuple of hou.Node objects corresponding to the
    nodes at their new locations.  If you attempt to access the original
    hou.Node objects in the sequence you passed into this function, you will
    receive hou.ObjectWasDeleted exceptions.

    For every moved node, if a node with the same name already exists at the
    destination, the node will be renamed to a unique name.

    This function will raise a hou.OperationFailed exception if any of the
    nodes to be moved are of invalid type, the destination node cannot be
    copied into, or source node type does not match the destination node's
    child type.

    This function will raise hou.ObjectWasDeleted if any of source nodes or
    the destination node no longer exist in Houdini.

    All of the above issues with source and destination nodes will be
    reported before moving starts to avoid a partial move.

    After the function finishes execution, all the moved nodes by it will be
    selected.


    """
  return (Node(),)

def addNodeBundle(name):
  """
    addNodeBundle(name) -> hou.NodeBundle

    Create a new node bundle with the specified name.

    See hou.NodeBundle for more information about node bundles.

    Raises hou.OperationFailed if the name is not alphanumeric or a bundle
    with that name already exists.

    REPLACES
      * opbadd


    """
  return NodeBundle()

def nodeBundles():
  """
    nodeBundles() -> tuple of hou.NodeBundle

    Return a tuple containing all the node bundles in the current session.

    See hou.NodeBundle for more information.

    REPLACES
      * opbls


    """
  return (NodeBundle(),)

def selectedNodeBundles():
  """
    selectedNodeBundles() -> tuple of hou.NodeBundle

    Return a tuple containing all the node bundles that are selected in the
    bundle list pane.

    This function is a shortcut for [bundle for bundle in hou.nodeBundles()
    if bundle.isSelected].

    See hou.NodeBundle for more information about bundles.

    REPLACES
      * opbls


    """
  return (NodeBundle(),)

def nodeBundle(name):
  """
    nodeBundle(name) -> hou.NodeBundle or None

    Given a node bundle name, return the corresponding NodeBundle object, or
    None if there is not one with that name.

    See hou.NodeBundle for more information.

    REPLACES
      * opbls
      * opglob
    """
  return NodeBundle()

def time():
  """
    time() -> float

    Return the playbar's current time, in seconds of playback.

    Note that the time at frame 1 is 0s.

    RELATED
      * hou.setTime
      * hou.frame
      * hou.fps

    REPLACES
      * tcur
    """
  return 0.0

def setTime(time):
  """
    setTime(time)

    Set the playbar's time.

    RELATED
      * hou.time
      * hou.setFrame

    REPLACES
      * tcur
    """

def frame():
  """
    frame() -> float

    Return the playbar's current frame.  Note that Houdini can be on a
    fractional frame if fractional frames are enabled.

    Note that this function is equivalent to Hscript's $FF variable.  If you
    want hscript's $F variable, use hou.intFrame, which rounds the frame to
    the nearest integer.

    To enable fractional frames, turn off the Integer Frame Values in the
    Global Animation Options dialog.

    This function rounds its output to 3 decimal places, just like Hscript's
    $FF variable does.  Note, though, that because a Python float may not be
    able to precisely represent a floating point value, and because Python
    does not round numbers when it displays them, the frame number might end
    with 9999999999999 or 0000000000001 when you print it to the Python
    shell.  When you convert the number to a string, though, Python will
    round the value, so it will contain at most 3 decimal places.

      >>> 2.759
      2.7589999999999999
      >>> 2.757
      2.7570000000000001
      >>> str(2.759)
      '2.759'

    If Houdini is on a fractional frame and you do not want the rounded
    value, use hou.timeToFrame(hou.time()).

      >>> hou.setFrame(13.193)
      >>> hou.frame()
      13.193
      >>> hou.timeToFrame(hou.time())
      13.192999839782715
      >>> hou.setFrame(2.759)
      >>> hou.frame()
      2.7589999999999999
      >>> int(hou.frame())
      2
      >>> hou.intFrame()
      3

    RELATED
      * hou.intFrame
      * hou.setFrame
      * hou.time
      * hou.fps

    REPLACES
      * fcur
    """
  return 0.0

def intFrame(self):
  """
    intFrame() -> int

    Return the playbar's current frame, rounded to the nearest integer.

    Note that this function is equivalent to Hscript's $F variable.  If you
    want Hscript's $FF variable, use hou.frame.

    RELATED
      * hou.frame
      * hou.setFrame
      * hou.time
      * hou.fps

    REPLACES
      * fcur


    """
  return 0

def setFrame(frame):
  """
    setFrame(frame)

    Set the playbar's current frame. Note that the frame may be a fractional
    value.

    RELATED
      * hou.time
      * hou.setFrame

    REPLACES
      * tcur


    """
  return

def fps(self):
  """
    fps() -> float

    Return the number of frames per second.

    This value is used when converting between frames and time.

    RELATED
      * hou.setFps
      * hou.frame
      * hou.time

    REPLACES
      * fps


    """
  return 0.0

def setFps(fps):
  """
    setFps(fps)

    Set the number of frames per second.

    RELATED
      * hou.fps

    REPLACES
      * fps
    """

def timeToFrame(time):
  """
    timeToFrame(time) -> float

    Convert from a given time value to a frame value, rounding the result to
    a integer if it is close to an integer.

    Calling this function is the same as evaluating time * hou.fps() + 1.0,
    with rounding performed if the result is nearly an integer.

    RELATED
      * hou.fps
      * hou.frame
      * hou.time

    REPLACES
      * fps
    """
  return 0.0

def frameToTime(frame):
  """
    frameToTime(frame) -> float

    Convert from a given frame value to a time value.

    Calling this function is the same as evaluating (frame - 1.0) /
    hou.fps(). Unlike hou.timeToFrame(), no rounding is performed.

    RELATED
      * hou.fps
      * hou.time
      * hou.frame

    REPLACES
      * fps
    """
  return 0.0

def bezier():
  """
    bezier() -> float

    Evaluate a Bezier interpolation spline for an animated parameter using
    the left keyframe's outgoing value, tangent, and acceleration and the
    right keyframe's incoming value, tangent, and acceleration.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED
      * hou.constant
      * hou.cubic
      * hou.cycle
      * hou.cyclet
      * hou.ease
      * hou.easein
      * hou.easeinp
      * hou.easeout
      * hou.easeoutp
      * hou.easep
      * hou.linear
      * hou.match
      * hou.matchin
      * hou.matchout
      * hou.qlinear
      * hou.quintic
      * hou.repeat
      * hou.repeatt
      * hou.spline
      * hou.vmatch
      * hou.vmatchin
      * hou.vmatchout

    REPLACES
      * bezier
    """
  return 0.0

def constant():
  """
    constant() -> float

    Evaluate an animation function for an animated parameter. The return
    value is always the left keyframe's outgoing value.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED
      * hou.bezier
      * hou.cubic
      * hou.cycle
      * hou.cyclet
      * hou.ease
      * hou.easein
      * hou.easeinp
      * hou.easeout
      * hou.easeoutp
      * hou.easep
      * hou.linear
      * hou.match
      * hou.matchin
      * hou.matchout
      * hou.qlinear
      * hou.quintic
      * hou.repeat
      * hou.repeatt
      * hou.spline
      * hou.vmatch
      * hou.vmatchin
      * hou.vmatchout

    REPLACES
      * constant


    """
  return 0.0

def cubic(self):
  """
    cubic() -> float

    Smooth curve between the left keyframe's outgoing slope and the right's
    incoming slope.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED
      * hou.bezier
      * hou.constant
      * hou.cycle
      * hou.cyclet
      * hou.ease
      * hou.easein
      * hou.easeinp
      * hou.easeout
      * hou.easeoutp
      * hou.easep
      * hou.linear
      * hou.match
      * hou.matchin
      * hou.matchout
      * hou.qlinear
      * hou.quintic
      * hou.repeat
      * hou.repeatt
      * hou.spline
      * hou.vmatch
      * hou.vmatchin
      * hou.vmatchout

    REPLACES
      * cubic
    """
  return 0.0

def cycle(start_frame, end_frame):
  """
    cycle(start_frame, end_frame) -> float

    Repeats the motion between two times.

    The values within the range are repeated exactly. If you want to line up
    the values with the value of the previous keyframe, use
    hou.cycleoffset() instead.

    This function is the same as hou.cyclet() except hou.cyclet() accepts
    times instead of frames.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED
      * hou.bezier
      * hou.constant
      * hou.cubic
      * hou.cyclet
      * hou.cycleoffset
      * hou.cycleoffsett
      * hou.ease
      * hou.easein
      * hou.easeinp
      * hou.easeout
      * hou.easeoutp
      * hou.easep
      * hou.linear
      * hou.match
      * hou.matchin
      * hou.matchout
      * hou.qlinear
      * hou.quintic
      * hou.spline
      * hou.vmatch
      * hou.vmatchin
      * hou.vmatchout

    REPLACES
      * cycle


    """
  return 0.0

def cyclet(start_time, end_time):
  """
    cyclet(start_time, end_time) -> float

    Repeats the motion between two times.

    The values within the range are repeated exactly. If you want to line up
    the values with the value of the previous keyframe, use
    hou.cycleoffsett() instead.

    This function is the same as hou.cycle() except hou.cycle() it accepts
    frames instead of times.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED
      * hou.bezier
      * hou.constant
      * hou.cubic
      * hou.cycle
      * hou.cycleoffset
      * hou.cycleoffsett
      * hou.ease
      * hou.easein
      * hou.easeinp
      * hou.easeout
      * hou.easeoutp
      * hou.easep
      * hou.linear
      * hou.match
      * hou.matchin
      * hou.matchout
      * hou.qlinear
      * hou.quintic
      * hou.spline
      * hou.vmatch
      * hou.vmatchin
      * hou.vmatchout

    REPLACES
      * cyclet


    """
  return 0.0

def cycleoffset(start_frame, end_frame):
  """
    cycleoffset(start_frame, end_frame) -> float

    Repeats the motion between two frames, lining up the first repeated
    value with the left keyframe's value.

    The repeated values are shifted so that each repeated portion has its
    first value set to the last value of the previous cycle. If the start
    frame is less than the end frame, the animation will cycle forwards.
    Otherwise, it will cycle backwards.

    This function is the same as hou.cycleoffsett() except
    hou.cycleoffsett() accepts times instead of frames. If you want to
    repeat motion exactly, use the hou.cycle() function instead.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED
      * hou.bezier
      * hou.constant
      * hou.cubic
      * hou.cycle
      * hou.cyclet
      * hou.cycleoffsett
      * hou.ease
      * hou.easein
      * hou.easeinp
      * hou.easeout
      * hou.easeoutp
      * hou.easep
      * hou.linear
      * hou.match
      * hou.matchin
      * hou.matchout
      * hou.qlinear
      * hou.quintic
      * hou.spline
      * hou.vmatch
      * hou.vmatchin
      * hou.vmatchout

    REPLACES
      * cycleoffset


    """
  return 0.0

def cycleoffsett(start_time, end_time):
  """
    cycleoffsett(start_time, end_time) -> float

    Repeats the motion between two times, lining up the repeated values with
    the left keyframe's value.

    The repeated values are shifted so that each repeated portion has its
    first value set to the last value of the previous cycle. If the start
    frame is less than the end frame, the animation will cycle forwards.
    Otherwise, it will cycle backwards.

    This function is the same as hou.cycleoffset() except hou.cycleoffset()
    accepts frames instead of times. If you want to repeat motion exactly,
    use the hou.cyclet() function instead.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED
      * hou.bezier
      * hou.constant
      * hou.cubic
      * hou.cycle
      * hou.cyclet
      * hou.cycleoffset
      * hou.ease
      * hou.easein
      * hou.easeinp
      * hou.easeout
      * hou.easeoutp
      * hou.easep
      * hou.linear
      * hou.match
      * hou.matchin
      * hou.matchout
      * hou.qlinear
      * hou.quintic
      * hou.spline
      * hou.vmatch
      * hou.vmatchin
      * hou.vmatchout

    REPLACES
      * cycleoffsett


    """
  return 0.0

def ease():
  """
    ease() -> float

    Interpolates between the left keyframe's outgoing value and the right
    keyframe's incoming value.

    The tangents will be flat at both ends of the function, so the curve
    will slowly ease from the left value and, near the end of the function,
    slowly reduce the speed until it is at rest at the right value.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED
      * hou.bezier
      * hou.constant
      * hou.cubic
      * hou.cycle
      * hou.cyclet
      * hou.easein
      * hou.easeinp
      * hou.easeout
      * hou.easeoutp
      * hou.easep
      * hou.linear
      * hou.match
      * hou.matchin
      * hou.matchout
      * hou.qlinear
      * hou.quintic
      * hou.repeat
      * hou.repeatt
      * hou.spline
      * hou.vmatch
      * hou.vmatchin
      * hou.vmatchout

    REPLACES
      * ease


    """
  return 0.0

def easein():
  """
    easein() -> float

    Interpolates between the left keyframe's outgoing value and the right
    keyframe's incoming value.

    The tangent will be flat at the left end of the function, so it will
    slowly ease from the outgoing value of the left keyframe.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED
      * hou.bezier
      * hou.constant
      * hou.cubic
      * hou.cycle
      * hou.cyclet
      * hou.ease
      * hou.easeinp
      * hou.easeout
      * hou.easeoutp
      * hou.easep
      * hou.linear
      * hou.match
      * hou.matchin
      * hou.matchout
      * hou.qlinear
      * hou.quintic
      * hou.repeat
      * hou.repeatt
      * hou.spline
      * hou.vmatch
      * hou.vmatchin
      * hou.vmatchout

    REPLACES
      * easein


    """
  return 0.0

def easeinp(ease_speed):
  """
    easeinp(ease_speed) -> float

    Interpolates between the values of two keyframes.

    This function is like hou.easein, except it has an additional parameter
    to say how fast the curve should ease into the motion.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED
      * hou.bezier
      * hou.constant
      * hou.cubic
      * hou.cycle
      * hou.cyclet
      * hou.ease
      * hou.easein
      * hou.easeout
      * hou.easeoutp
      * hou.easep
      * hou.linear
      * hou.match
      * hou.matchin
      * hou.matchout
      * hou.qlinear
      * hou.quintic
      * hou.repeat
      * hou.repeatt
      * hou.spline
      * hou.vmatch
      * hou.vmatchin
      * hou.vmatchout

    REPLACES
      * easeinp
    """
  return 0.0

def easeout():
  """
    easeout() -> float

    Interpolates between the left keyframe's outgoing value and the right
    keyframe's incoming value.

    The tangent will be flat at the right end of the function, so it will
    slowly come to rest at the incoming value of the right keyframe.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED
      * hou.bezier
      * hou.constant
      * hou.cubic
      * hou.cycle
      * hou.cyclet
      * hou.ease
      * hou.easein
      * hou.easeinp
      * hou.easeoutp
      * hou.easep
      * hou.linear
      * hou.match
      * hou.matchin
      * hou.matchout
      * hou.qlinear
      * hou.quintic
      * hou.repeat
      * hou.repeatt
      * hou.spline
      * hou.vmatch
      * hou.vmatchin
      * hou.vmatchout

    REPLACES
      * easeout


    """
  return 0.0

def easeoutp(ease_speed):
  """
    easeoutp(ease_speed) -> float

    Interpolates between the values of two keyframes.

    This function is like hou.easeout, except it has an additional parameter
    to say how fast the curve should ease into the motion.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED
      * hou.bezier
      * hou.constant
      * hou.cubic
      * hou.cycle
      * hou.cyclet
      * hou.ease
      * hou.easein
      * hou.easeinp
      * hou.easeout
      * hou.easep
      * hou.linear
      * hou.match
      * hou.matchin
      * hou.matchout
      * hou.qlinear
      * hou.quintic
      * hou.repeat
      * hou.repeatt
      * hou.spline
      * hou.vmatch
      * hou.vmatchin
      * hou.vmatchout

    REPLACES
      * easeoutp


    """
  return 0.0

def easep(ease_bias):
  """
    easep(ease_bias) -> float

    Interpolates between the values of two keyframes.

    An ease bias of less than one slow the animation near right keyframe,
    while an ease bias greater than one will slow it near the left keyframe.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED
      * hou.bezier
      * hou.constant
      * hou.cubic
      * hou.cycle
      * hou.cyclet
      * hou.ease
      * hou.easein
      * hou.easeinp
      * hou.easeout
      * hou.easeoutp
      * hou.linear
      * hou.match
      * hou.matchin
      * hou.matchout
      * hou.qlinear
      * hou.quintic
      * hou.repeat
      * hou.repeatt
      * hou.spline
      * hou.vmatch
      * hou.vmatchin
      * hou.vmatchout

    REPLACES
      * easep


    """
  return 0.0

def linear():
  """
    linear() -> float

    Linearly interpolates between the left keyframe's outgoing value and the
    right keyframe's incoming value.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED
      * hou.bezier
      * hou.constant
      * hou.cubic
      * hou.cycle
      * hou.cyclet
      * hou.ease
      * hou.easein
      * hou.easeinp
      * hou.easeout
      * hou.easeoutp
      * hou.easep
      * hou.match
      * hou.matchin
      * hou.matchout
      * hou.qlinear
      * hou.quintic
      * hou.repeat
      * hou.repeatt
      * hou.spline
      * hou.vmatch
      * hou.vmatchin
      * hou.vmatchout

    REPLACES
      * linear


    """
  return 0.0

def match():
  """
    match() -> float

    Creates a smooth curve between the left keyframe's incoming slope and
    the right keyframe's outgoing slope.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED
      * hou.bezier
      * hou.constant
      * hou.cubic
      * hou.cycle
      * hou.cyclet
      * hou.ease
      * hou.easein
      * hou.easeinp
      * hou.easeout
      * hou.easeoutp
      * hou.easep
      * hou.linear
      * hou.matchin
      * hou.matchout
      * hou.qlinear
      * hou.quintic
      * hou.repeat
      * hou.repeatt
      * hou.spline
      * hou.vmatch
      * hou.vmatchin
      * hou.vmatchout

    REPLACES
      * match


    """
  return 0.0

def matchin():
  """
    matchin() -> float

    Creates a straight line from the left keyframe's incoming value,
    matching the left keyframe's incoming slope.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED
      * hou.bezier
      * hou.constant
      * hou.cubic
      * hou.cycle
      * hou.cyclet
      * hou.ease
      * hou.easein
      * hou.easeinp
      * hou.easeout
      * hou.easeoutp
      * hou.easep
      * hou.linear
      * hou.match
      * hou.matchout
      * hou.qlinear
      * hou.quintic
      * hou.repeat
      * hou.repeatt
      * hou.spline
      * hou.vmatch
      * hou.vmatchin
      * hou.vmatchout

    REPLACES
      * matchin


    """
  return 0.0

def matchout():
  """
    matchout() -> float

    Creates a straight line from the right keyframe's outgoing value,
    matching the right keyframe's outgoing slope.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED
      * hou.bezier
      * hou.constant
      * hou.cubic
      * hou.cycle
      * hou.cyclet
      * hou.ease
      * hou.easein
      * hou.easeinp
      * hou.easeout
      * hou.easeoutp
      * hou.easep
      * hou.linear
      * hou.match
      * hou.matchin
      * hou.qlinear
      * hou.quintic
      * hou.repeat
      * hou.repeatt
      * hou.spline
      * hou.vmatch
      * hou.vmatchin
      * hou.vmatchout

    REPLACES
      * matchout


    """
  return 0.0

def qlinear():
  """
    qlinear() -> float

    Linearly interpolates between keyframes using quaternions.

    The neighboring parameters must also be animated; for example, if "rx"
    uses qlinear(), "ry" and "rz" should also use qlinear().

    Because the interpolation is done in quaternion spaces, the orientations
    will blend smoothly with no gimbal lock or unexpected spins. The Euler
    rotation values may appear to jump suddenly, but that's simply because
    different rotation values can represent the same orientation.

    Note that the graph editor will display a qlinear() segment as a dashed
    straight line. This line does not represent the actual intermediate
    channel values, but it does give an accurate visual feel for the
    behavior of the interpolation.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED
      * hou.bezier
      * hou.constant
      * hou.cubic
      * hou.cycle
      * hou.cyclet
      * hou.ease
      * hou.easein
      * hou.easeinp
      * hou.easeout
      * hou.easeoutp
      * hou.easep
      * hou.linear
      * hou.match
      * hou.matchin
      * hou.matchout
      * hou.quintic
      * hou.repeat
      * hou.repeatt
      * hou.spline
      * hou.vmatch
      * hou.vmatchin
      * hou.vmatchout

    REPLACES
      * qlinear


    """
  return 0.0

def quintic():
  """
    quintic() -> float

    Evaluate an interpolation function for an animated parameter that gives
    a smooth curve between the left keyframe's outgoing value and the right
    keyframe's incoming value, using the left's outgoing slope and
    acceleration and the right's incoming slope and acceleration.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED
      * hou.bezier
      * hou.constant
      * hou.cubic
      * hou.cycle
      * hou.cyclet
      * hou.ease
      * hou.easein
      * hou.easeinp
      * hou.easeout
      * hou.easeoutp
      * hou.easep
      * hou.linear
      * hou.match
      * hou.matchin
      * hou.matchout
      * hou.qlinear
      * hou.repeat
      * hou.repeatt
      * hou.spline
      * hou.vmatch
      * hou.vmatchin
      * hou.vmatchout

    REPLACES
      * quintic


    """
  return 0.0

def repeat(start_frame, end_frame):
  """
    repeat(start_frame, end_frame) -> float

    Repeats the motion between two times.

    The repeated values are repeated exactly. If you want to line up the
    values with the value of the previous keyframe, use hou.cycle() instead.

    This function is the same as hou.repeatt() except hou.repeatt() accepts
    times instead of frames.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED
      * hou.bezier
      * hou.constant
      * hou.cubic
      * hou.cycle
      * hou.cyclet
      * hou.ease
      * hou.easein
      * hou.easeinp
      * hou.easeout
      * hou.easeoutp
      * hou.easep
      * hou.linear
      * hou.match
      * hou.matchin
      * hou.matchout
      * hou.qlinear
      * hou.quintic
      * hou.repeatt
      * hou.spline
      * hou.vmatch
      * hou.vmatchin
      * hou.vmatchout

    REPLACES
      * repeat


    """
  return 0.0

def repeatt(start_time, end_time):
  """
    repeatt(start_time, end_time) -> float

    Repeats the motion between two times.

    The repeated values are repeated exactly. If you want to line up the
    values with the value of the previous keyframe, use hou.cyclet()
    instead.

    This function is the same as hou.repeat() except hou.repeat() it accepts
    frames instead of times.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED
      * hou.bezier
      * hou.constant
      * hou.cubic
      * hou.cycle
      * hou.cycleoffset
      * hou.cyclet
      * hou.ease
      * hou.easein
      * hou.easeinp
      * hou.easeout
      * hou.easeoutp
      * hou.easep
      * hou.linear
      * hou.match
      * hou.matchin
      * hou.matchout
      * hou.qlinear
      * hou.quintic
      * hou.spline
      * hou.vmatch
      * hou.vmatchin
      * hou.vmatchout

    REPLACES
      * repeatt


    """
  return 0.0

def spline():
  """
    spline() -> float

    Fits a spline through consecutive keyframe values.

    The resulting spline interpolates the channel values at the keyframes,
    and slope values are not used.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED
      * hou.bezier
      * hou.constant
      * hou.cubic
      * hou.cycle
      * hou.cyclet
      * hou.ease
      * hou.easein
      * hou.easeinp
      * hou.easeout
      * hou.easeoutp
      * hou.easep
      * hou.linear
      * hou.match
      * hou.matchin
      * hou.matchout
      * hou.qlinear
      * hou.quintic
      * hou.repeat
      * hou.repeatt
      * hou.vmatch
      * hou.vmatchin
      * hou.vmatchout

    REPLACES
      * spline


    """
  return 0.0

def vmatch():
  """
    vmatch() -> float

    Matches the incoming and outgoing values and slopes.

    Unlike hou.match, this function will use its left keyframe's outgoing
    value and the right keyframe's incoming value, so hou.vmatch() can
    produce curves that are discontinuous with the previous segment.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED
      * hou.bezier
      * hou.constant
      * hou.cubic
      * hou.cycle
      * hou.cyclet
      * hou.ease
      * hou.easein
      * hou.easeinp
      * hou.easeout
      * hou.easeoutp
      * hou.easep
      * hou.linear
      * hou.match
      * hou.matchin
      * hou.matchout
      * hou.qlinear
      * hou.quintic
      * hou.repeat
      * hou.repeatt
      * hou.spline
      * hou.vmatchin
      * hou.vmatchout

    REPLACES
      * vmatch


    """
  return 0.0

def vmatchin():
  """
    vmatchin() -> float

    Matches the left keyframe's incoming slope.

    The curve will be a straight line from the left keyframe's outgoing
    value, and will not match the right keyframe's outgoing value. Unlike
    the hou.matchin() function, the left keyframe's outgoing value can
    differ from its incoming value, so so hou.vmatchin() can produce curves
    whose left tangent matches the left keyframe but whose left values do
    not line up.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED
      * hou.bezier
      * hou.constant
      * hou.cubic
      * hou.cycle
      * hou.cyclet
      * hou.ease
      * hou.easein
      * hou.easeinp
      * hou.easeout
      * hou.easeoutp
      * hou.easep
      * hou.linear
      * hou.match
      * hou.matchin
      * hou.matchout
      * hou.qlinear
      * hou.quintic
      * hou.repeat
      * hou.repeatt
      * hou.spline
      * hou.vmatch
      * hou.vmatchout

    REPLACES
      * vmatchin


    """
  return 0.0

def vmatchout():
  """
    vmatchout() -> float

    Matches the right keyframe's outgoing slope.

    The curve will be a straight line ending at the right keyframe's
    incoming value, and will not match the left keyframe's incoming value.
    Unlike the hou.matchout() function, the right keyframe's incoming value
    can differ from its outgoing value, so so hou.vmatchout() can produce
    curves whose right tangent matches the right keyframe but whose right
    values do not line up.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED
      * hou.bezier
      * hou.constant
      * hou.cubic
      * hou.cycle
      * hou.cyclet
      * hou.ease
      * hou.easein
      * hou.easeinp
      * hou.easeout
      * hou.easeoutp
      * hou.easep
      * hou.linear
      * hou.match
      * hou.matchin
      * hou.matchout
      * hou.qlinear
      * hou.quintic
      * hou.repeat
      * hou.repeatt
      * hou.spline
      * hou.vmatch
      * hou.vmatchin

    REPLACES
      * vmatchout


    """
  return 0.0

def hscriptCommandHelp(command_name):
  """
    hscriptCommandHelp(command_name) -> string

    Return the text help of an hscript command. This function is used to
    help re-implement hscript commands in Python.


    """
  return ''

def hscript(command):
  """
    hscript(command) -> tuple of strings

    Executes the given hscript command and returns a 2-tuple of strings
    where the first string contains the regular output of the executed
    command and the  second string contains the error output.  You can
    specify multiple commands by using ';' or the newline character as the
    separator.

    REPLACES
      * execute


    """
  return ('',)

def almostEqual(x, y):
  """
    almostEqual(x, y) -> bool

    Compares two numbers and returns True if they are almost equal in terms
    of how far apart they are when represented as floating point numbers.


    """
  return True

def findFile(file_name):
  """
    findFile(file_name) -> string

    Search the Houdini path for a specified file, returning the first match
    found. The filename specified should be relative to the Houdini
    directory.

    If the file cannot be found in the Houdini path, OperationFailed is
    raised. Directories are not found, for directories use hou.findDirectory
    instead.

    RELATED
      * hou.findFiles
      * hou.findDirectory
      * hou.findDirectories
      * hou.houdiniPath

    REPLACES
      * findfile


    """
  return ''

def findFiles(file_name):
  """
    findFiles(file_name) -> tuple of strings

    Search the Houdini path for the specified file, returning a tuple of all
    the matches.  The filename specified should be relative to the Houdini
    directory.

    If the file cannot be found on the Houdini path, OperationFailed is
    raised. Directories are not found, for directories use
    hou.findDirectories instead.

    RELATED
      * hou.findFile
      * hou.findDirectory
      * hou.findDirectories
      * hou.houdiniPath

    REPLACES
      * findfiles


    """
  return ('',)

def findDirectory(directory_name):
  """
    findDirectory(directory_name) -> string

    Search the Houdini path for a specified directory, returning the first
    match found. The directory name specified should be relative to the
    Houdini directory.

    If the directory cannot be found in the Houdini path, OperationFailed is
    raised.

    RELATED
      * hou.findDirectories
      * hou.findFile
      * hou.findFiles
      * hou.houdiniPath


    """
  return ''

def findDirectories(directory_name):
  """
    findDirectories(directory_name) -> tuple of strings

    Search the Houdini path for the specified directory, returning a tuple
    of all the matches.  The directory name specified should be relative to
    the Houdini directory.

    If the directory cannot be found in the Houdini path, OperationFailed is
    raised.

    RELATED
      * hou.findDirectory
      * hou.findFile
      * hou.findFiles
      * hou.houdiniPath


    """
  return ('',)

def houdiniPath():
  """
    houdiniPath() -> bool

    Return the contents of the Houdini path as a tuple of strings.

    Houdini uses the Houdini path when searching for various files, like
    otls, shelf tools, preferences, desktops, icons, etc.  By adjusting the
    HOUDINI_PATH environment variable, you can add entries to the path that
    are specific to the current user, job, or studio.

    See the output of hconfig -ap for more information on the current value
    of Houdini path and how to change it.

    RELATED
      * hou.findFile
      * hou.findFiles
      * hou.findDirectory
      * hou.findDirectories
    """
  return True

def homeHoudiniDirectory():
  """
    homeHoudiniDirectory() -> str

    Return the path to the Houdini directory in your $HOME directory.

    Return the directory in your $HOME directory where Houdini stores user-
    specific settings.  On many platforms, this directory is
    $HOME/houdiniX.Y, where X is the Houdini major version and Y is the
    minor version.  Note that on the Mac, though, this directory might be in
    a different location.

    See hou.houdiniPath for more information about how Houdini searches for
    files.

    RELATED
      * hou.houdiniPath
      * hou.applicationVersion
      * hou.findFile
      * hou.findFiles
      * hou.findDirectory
      * hou.findDirectories


    """
  return ''

def readFile(file_path):
  """
    readFile(file_path) -> string

    Read a file, returning the contents in a string.  Supports regular
    files, opdef: and oplib: paths, and http URLs.

    Opdef paths can be specified with the string opdef:/node?section (e.g.
    opdef:/Object/subnet1?my_section).  Oplib paths can be specified with
    oplib:/operator?operator (e.g. oplib:/Cop2/grain?Cop2/grain).

    If the file does not exist or an error occurs while reading, this
    function raises hou.OperationFailed.


    """
  return ''

def saveCPIODataToString(data_tuples):
  """
    saveCPIODataToString(data_tuples) -> str

    Given a sequence of (name, value) string tuples, encode that data into a
    string in CPIO format.

    The inverse of this function is hou.loadCPIODataFromString.  See it for
    more information about CPIO data format.

    RELATED
      * hou.loadCPIODataFromString


    """
  return ''

def loadIndexDataFromFile(file_path):
  """
    loadIndexDataFromFile(file_path) -> dict

    Given a file containing data in index data format, decode the data and
    return a dictionary representing the data.

    This function could be implemented as follows:

      def loadIndexDataFromFile(file_path):
          hou.loadIndexDataFromString(hou.readFile(file_path))

    See hou.loadIndexDataFromString for more details.

    RELATED
      * hou.saveIndexDataToFile
      * hou.loadIndexDataFromString
      * hou.saveIndexDataToString


    """
  return {}

def saveIndexDataToString(data_dict):
  """
    saveIndexDataToString(data_dict) -> str

    Given a dictionary mapping strings to strings, encode that data into a
    string in index data format.

    The inverse of this function is hou.loadIndexDataFromString.  See it for
    more information about index data format.

    RELATED
      * hou.loadIndexDataFromString
      * hou.loadIndexDataFromFile
      * hou.saveIndexDataToFile


    """
  return ''

def saveIndexDataToFile(file_path, index_data):
  """
    saveIndexDataToFile(file_path, index_data)

    Given a dictionary mapping strings to strings, encode that data in index
    data format and save it into a file.

    This function could be implemented as follows:

      def saveIndexDataToFile(file_path, index_data):
          with open(file_path, "wb") as open_file:
              open_file.write(hou.saveIndexDataToString(index_data))

    See hou.loadIndexDataFromString for more details.

    RELATED
      * hou.loadIndexDataFromFile
      * hou.loadIndexDataFromString
      * hou.saveIndexDataToString
    """

def vexContexts():
  """
    vexContexts() -> tuple of VexContexts


    """
  return (VexContexts(),)

def vexContextForShaderType(shader_type):
  """
    vexContextForShaderType(shader_type) -> VexContext or None
    """
  return VexContext()

def vexContextForNodeTypeCategory(node_type_category):
  """
    vexContextForNodeTypeCategory(node_type_category) -> VexContext or None
    """
  return VexContext()

def setSessionModuleSource(source):
  """
    setSessionModuleSource(source)

    Sets the contents of the hou.session module.  The new contents is made
    available immediately.  You do not have to re-import hou.session.

    This function throws a hou.OperationFailed exception if it fails to
    update the hou.session module.  This can happen if the new contents has
    syntax errors.

    RELATED
      * hou.appendSessionModuleSource
      * hou.session
      * hou.setSessionModuleSource
    """

def appendSessionModuleSource(source):
  """
    appendSessionModuleSource(source)

    Appends the given source code to the hou.session module.  The appended
    code is made available immediately.  You do not have to re-import
    hou.session.

    This function throws a hou.OperationFailed exception if it fails to
    update the hou.session module.  This can happen if the appended source
    has syntax errors or if it conflicts with the existing contents of the
    module.

    RELATED
      * hou.session
      * hou.sessionModuleSource
      * hou.setSessionModuleSource
    """

def sessionModuleSource():
  """
    sessionModuleSource() -> string

    Returns the contents of the hou.session module.

    RELATED
      * hou.appendSessionModuleSource
      * hou.session
      * hou.setSessionModuleSource
    """
  return ''

def _hdaTrustedFunction(f):
    """_hdaTrustedFunction(f)

    A decorator for granting functions extra access privileges.

    This decorator grants a function defined in an HDA PythonModule
    section access privileges to the internals of that HDA.

    This function is only intended for internal Side Effects Software use.
    """
    return

def applicationVersion():
  """
    applicationVersion() -> tuple of 3 ints

    Returns the application's version number as a tuple of integers --
    (major_version, minor_version, build_version).

    If this method is executed in python, then it returns the hou module's
    version number.

    REPLACES
      * version

    RELATED
      * hou.applicationCompilationDate
      * hou.applicationName
      * hou.applicationVersionString
      * hou.applicationPlatformInfo
      * hou.licenseCategory
      * hou.isApprentice


    """
  return (1,1,1)

def applicationVersionString():
  """
    applicationVersionString() -> string

    Returns the application's version number as a string.

    The format of the string is 'major_version.minor_version.build_version'.
    If this method is executed in python, then it returns the hou module's
    version number.

    REPLACES
      * version

    RELATED
      * hou.applicationCompilationDate
      * hou.applicationName
      * hou.applicationVersion
      * hou.applicationPlatformInfo
      * hou.licenseCategory
      * hou.isApprentice
    """
  return ''

def selectedNodes(include_hidden=False):
  """
    Return a list of all selected nodes.

    selectedNodes(include_hidden=False) -> tuple of hou.Node

    If include_hidden is False, hidden nodes will not in the result, even if
    they are selected.  See hou.Node.isHidden for more information about
    hidden nodes.

    The last selected node (i.e. the last node in the return value) has
    special meaning to Houdini, and unpinned panes in Houdini follow this
    node.

    The following example will print the names of all selected nodes:
      for n in hou.selectedNodes():
          print n.name()


      def lastSelectedNode():
          '''Return the last selected node, or None if there isn't one.'''
          selected_nodes = hou.selectedNodes()
          return (selected_nodes[-1] if len(selected_nodes) > 0 else None)

    REPLACES
      * opselectrecurse


    """
  return (Node(),)

def getenv(name, default_value=None):
  """
    getenv(name, default_value=None) -> str

    Return the value of the specified Houdini environment variable.

    Return the value of the specified Houdini environment variable.  Return
    default_value if the environment variable does not exist.

    RELATED
      * hou.putenv
      * hou.unsetenv
    """
  return ''

def updateProgressAndCheckForInterrupt(percentage=-1):
  """
    updateProgressAndCheckForInterrupt(percentage=-1) -> bool

    Deprecated: Use InterruptableOperation.

    Check if the user pressed Escape to interrupt the current operation, and
    optionally update the completion progress.


    This is deprecated.  Use hou.InterruptableOperation instead.

    Return True if the user pressed Escape and False otherwise.

    percentage
        An integer value containing the percentage complete to display in
        the taskbar.  If the percentage is -1, the taskbar will not display
        the completion percentage.

    You would typically call this function from inside a Python SOP, to let
    the user of the SOP press escape to interrupt a long cook.

    See Define a new SOP type using Python for an example.


    """
  return True

def saveImageDataToFile(color_and_alpha_data, width, height, file_name):
  """
    saveImageDataToFile(color_and_alpha_data, width, height, file_name)

    Create an image file from color and alpha pixel data.

    color_and_alpha_data
        Either a sequence of floats or a string containing the image data.
        The data must be in interleaved format, meaning that the first 4
        values are the red, green, blue, and alpha (RGBA) values for the
        first pixel, the next 4 are for the second pixel, and so on.  The
        first row of pixels in the data corresponds to the top scanline in
        the image.

        The length of this sequence must be width * height * 4.

        If you are writing a .pic file, the file will store 32-bit float
        data if you pass in a sequence of floats and 8-bit unsigned data if
        you pass in a string.

    width, height
        The width and height of the image to be written.

    file_name
        The name of the output image file to create.  Houdini will
        automatically determine which type of file to create based on this
        file's extension.

    This function provides two features not provided by other imaging
    libraries:

    * It lets you create files in Houdini's .pic format.
    * It lets you save images with 32-bit float data.
    Raises hou.OperationFailed if the data is not the correct size, the
    output file could not be created, or the output file format is not
    supported by Houdini.

    The following example uses the Python imaging library (PIL) to read in a
    file and calls this function to write it out.  Using the convertImage
    function below, you can convert any image that can be read by PIL into
    Houdini's .pic format.
      import Image

      def convertImage(input_image, output_image):
          im = Image.open(input_image)
          im.mode != "RGBA":
              raise ValueError("The image must contain alpha information")
          hou.saveImageDataToFile(im.tostring(), im.size[0], im.size[1], output_image)

      convertImage("image.png", "image.pic")


    See also Writing a COP in Python.
    """

def nodeType(category, name):
  """
    nodeType(category, name) -> NodeType or None

    Given a node type category object and a name, or possibly just a node
    type name that includes the category, return the corresponding NodeType
    object. Return None if there is no such type with that name.

    ARGUMENTS
        category
            A hou.NodeTypeCategory object (_not_ a string). You can use the
            hou.nodeTypeCategories() function to get a dict of category name
            strings to NodeTypeCategory objects.  You can also use the
            helper functions hou.sopNodeTypeCategory,
            hou.objNodeTypeCategory, etc.

            Note that this parameter is optional.  If omitted, the name
            parameter must contain the node type category.

        name
            The internal name of a node type. To get the internal name of
            any node type in Houdini, right-click a node of that type and
            choose Type properties. The internal name is listed at the top
            of the type properties window beside *Operator type*. For
            example, the internal name of the Geometry object is geo.

            If the category parameter is omitted, the name must include the
            category name.  For example, you can pass Object/geo to get the
            Geometry object's node type.


    EXAMPLES
          # The following four ways of looking up the copy SOP's node type are equivalent:
          >>> hou.nodeType("Sop/copy")
          <hou.SopNodeType for Sop copy>

          >>> hou.nodeType(hou.sopNodeTypeCategory(), "copy")
          <hou.SopNodeType for Sop copy>

          >>> hou.sopNodeTypeCategory().nodeTypes()["copy"]
          <hou.SopNodeType for Sop copy>

          >>> hou.nodeType(hou.sopNodeTypeCategories()["Sop"], "copy")
          <hou.SopNodeType for Sop copy>


    REPLACES
      * optype
      * optype
      * optypeinfo

    RELATED
      * hou.NodeType
      * hou.NodeTypeCategory
      * hou.NodeTypeCategory.nodeTypes
      * hou.nodeTypeCategories


    """
  return NodeType()

def fileReferences(project_dir_variable='HIP'):
  """
    fileReferences(project_dir_variable='HIP') -> tuple of Parm and string
    tuples

    OTL references will use a collapsed string containing the project
    directory variable if they are inside that directory.  For example, if
    the otl is in /mnt/projects/tools/tool.otl and JOB is /mnt/projects and
    project_dir_variable is JOB, the otl reference will be
    $JOB/tools/tool.otl.

    REPLACES
      * fdependls


    """
  return ('',Parm(),)

def nodeTypeCategories ():
    """
    Return a dictionary where the keys are the category names (e.g. Object, Sop) and the values are hou.NodeTypeCategory objects.
    :return:
    """
    return {'name':NodeTypeCategory()}

def vexContexts ():
    return (VexContexts(),)

